# P1：【录屏】理解PHP反序列化漏洞——第22期大咖berTrAM分享 - 漏洞银行BUGBANK - BV1g5411P7iX

小伙伴晚上好，歡迎收看漏洞銀行第二十二期的大咖面對面，我是主持人年念。

![](img/d1071b70aeaafee64a1287ab62a98b7d_1.png)

![](img/d1071b70aeaafee64a1287ab62a98b7d_2.png)

今晚我們邀請到了CTF的資深玩家Burgo來為我們分享理解PHP反序列化漏洞這個主題，難度係數為兩顆星。大咖分享時間，希望大家能多和大咖進行互動和交流，希望大家避免探討與分享內容無關的話題。

保持對大咖的尊重。那我們現在就有請大咖Burgo開始今天的分享吧。大家好，我是Burgo，是一個CTF戰隊裡面最菜的webgold，今天我要分享的主題是理解PHP反序列化漏洞。

主要是講一下PHP反序列化漏洞的成因，以及一些CTF題目的解析，希望在這個過程中能和大家一起交流探討。因為這次的議題是面向，大多數可能有的是沒有基礎的。

說一下PHP反序列化漏洞肯定是需要有基礎知識的補充。首先說一下PHP的類和對象，如果學過Java或者其他面向對象的話，應該是比較好理解的。幾個概念首先要明確一下，一個是類。

就是對現實生活中一類共同事物的抽象。概念就是這樣，對象就是對所說的事物就是對象，類中對象所具有的性質就是屬性，方法就是用來操作該對象或者該對象可以使用哪些方法。怎麼理解的話，其實我想了一下。

最簡單就是人就是最簡單的類，每個人的個體就是一個對象，每個個體也有相同的屬性，比如說那些名字、身高什麼的，方法就是這個對象會進行的動作，比如說如果是人作為對象的話，那就是吃飯、睡覺什麼的。

首先這是一個簡單的PHP類，這裡可以看到一個定義了class type的類，裡面有兩個屬性，A和B兩個屬性，裡面還有一個ecovar的方法，分別是輸出了A和B。對象的話。

更好理解就是test是我的一個對象，我要通過一個實例化出這個類，對象裡面的A進行複製，B進行複製，然後再調用這個方法。然後我們看一下這個結果，結果就是大家都知道會發生什麼了，調用了這個方法。

輸出了first和second，然後序列化是為了保存對象方便重用，怎麼說就是把你生成的對象轉換成一個字符串的形式去保存，方便保存嘛。然後反序列化就是把它從一個字符串的狀態恢復成一個可以用的對象的狀態。

舉個例子就是這樣，就是我們剛剛的那個例子，然後用這個sale_real_life這個函數，就是一個序列化的函數，然後對這個test進行一個序列化。

然後再用這個on_sale_real_life這個對生成的序列化字符串進行反序列化。看一下結果的話，就是這個是我們剛剛那個第一個發生出來的一個test的對象，是這樣子的。

然後這裡主要要注意的一個地方就是序列化是不會對方法進行一個序列化的，它只會對對象中所存儲的那些屬性進行一個序列化。然後看一下這個，這個就是我們第二個序列化成的字符串，它存成了一個字符串形式嘛。

然後我這邊複製，為什麼會有這個回車，是因為我這個複製的時候就直接給它複製了一個first_n，然後second_n吧。然後經過那個反序列化以後，大家可以看到恢復了和原來一樣的一個類的狀態，對象的狀態。

然後說到這個，說到這個序列化的話，肯定還要講一下這個PSP類中的魔術方法。魔術方法是什麼呢？就是先看一下代碼吧。還是和原來那個test的一個類一樣，我也是先進行了一個複製。

這裡是直接在這個類裡面進行複製嘛。

![](img/d1071b70aeaafee64a1287ab62a98b7d_4.png)

然後是在這個裡面定義了ecovar一個方法，然後這些字，這些是construct和wakeup，to_string，destruct這些方法的。等一下我們看完結果以後再，然後還有sleep這些方法。

過程就是跟剛剛那個序列化和反序列化的過程是一樣的。先看結果吧。然後結果就是this is a construct，從我們這裡就可以看見它是首先，它先進行了一個new嘛。

new也就是說先把這個類實例化成對象，然後實例化成對象，然後在實例化的過程中它肯定會調用這個construct的方法。因為construct如果java面向對象的話就會知道那個。

java中對一個類如果要把它實例化出來，它是需要調用一個構造函數的。構造函數在java中和它的類的名字是一樣的，但是在php中它是默認定義了一個construct的方法。然後再是一個sleep。

sleep的話就是對一個，因為我們這裡第二步就是進行了一個序列化的過程。所以sleep就是在序列化，在對一個對象進行序列化的時候會調用的，然後輸出這個序列化的結果。然後再進行一個反序列化。

也就是說它在wakeup，wakeup這個函數，它是在將一個反序列化自我串重新恢復成正常的對象的時候會調用。然後因為我們這裡還調用了一個equal tester。

equal tester就是將toString，toString就是在一個對象，在一個類作為，toString就是在一個類的對象作為自輔輸出的時候才會調用的。然後最後是一個distractor。

distractor的話就更好理解了，就是從內存中抽出正在使用的那一部分，因為已經使用完了。然後一般來說的話，這些方法的話，不管你有沒有在你的類中定義，只要你使用了這些過程，它都會默認調用的。

然後這個wakeup和wakeup，toString，distractor這三個方法就比較經典了，是各種CTF中被玩壞的魔術方法，應該這樣講吧。然後接下來我們講一下如何利用。然後首先明確一下利用條件吧。

如果有一個序列化的對象中存在魔術方法，而且魔術方法中的代碼可控，那麼這個就是一個反序列化漏洞。那麼特定構造便可以造成命令執行或者搜索注入等高危漏洞。也就是說在這些條件成立的結果下。

就有可能是一個反序列化漏洞。然後這是一題南京CTF2017的一道題吧，是比較基礎比較簡單的一道題。然後題目只給了這樣一串代碼，然後前面找出代碼的過程我就不說了，因為比較不是我們今天所講的主題。

然後看了一遍原碼，很容易就可以看出這是一個反序列化漏洞，因為它是利用一個toString的方法，然後在裡面對一個對Source這個屬性進行一個高量輸出。

然後就可以利用這個Source屬性去任意讀取文件吧。然後在頁面和HTTP頭中發掘信息發現Cookie是對ShareOne以後的一個反序列化字幕串。

然後在Cookie是對Cookie就是以一個ShareOne反序列化字幕串，然後再加上反序列化字幕串進行一個組合吧，然後以這種格式存儲。然後接下來就是既然理解這個過程，那我們就肯定要先構造攻擊代碼。

思路的話就很清楚了，首先是直接在我們的攻擊代碼中導入這個它所給出的這個類，然後把這個類實例化出來並進行複製，對這個Source屬性進行複製。然後Array的話是因為它這個在數組中存儲的時候。

在這個Cookie中看到它的格式就是一個Array的格式，它分別存儲了黑黑黑。txt，然後另外一個也是黑黑黑嗎？然後第二個根據我們上面的那個就可以看到這個Source。

Source就是我們需要去注入的一個地方了。然後看一下，然後這個再進行一個序列化，最後是一個生成校驗和再加上序列化的一個字幕串的一個攻擊代碼。然後結果就是這樣子一串，然後直接去，因為它這個題直接是。

因為它沒有告訴你Flag的其他的位置，然後我當時就直接用這個index。php，直接先試了一下，然後發現它那個Flag文件信息是存在這個index。php的一個注釋當中。然後說到反序列化的話。

就提一下幾個比較知名的反序列化漏洞。然後其中這個php三星反序列化及反序列化處理器設置不當帶來的安全隱患是就是一個應該有人知道吧，就是去年還是前年的時候那個中瀨那個反序列化漏洞的成因吧。

這個地方我們等一下再看，然後參考鏈接的話，這個如果大家還有那個物流資料庫可以搜一下那個3909這篇文章。然後這這題是暗恆429這題是就是針對我們這個php三星反序列化和反序列化處理器設置不當。

然後然後出的一道題吧。然後再說一下cve-2016-7124這個漏洞吧，這個漏洞影響版本是5。6。25以下，然後php7是7。0。1以下吧。然後大家都知道那個php的源碼是c寫的。

也就是說很多c語言的程序在寫c語言c程序的時候肯定會出現各種需要debug的地方。那這個php的cve也是因為這個，因為這些就是比如說他某些地方他沒有做完整的處理，然後他會造成需要debug，對吧？

然後他這個地方也是因為漏洞的代碼，原生的代碼沒有寫好，然後對這個屬性的個數，也就是我們上面提到的那個A或者B這些屬性吧，個數沒有進行校驗，然後在反序列化的時候。

反序列化的時候就是造成了一個wakeup的一個失效，然後就跳過了這個反序列化。然後講一下這個漏洞的附件，漏洞附件的話，首先我們先創建了一個序列化串，對吧？就是正常的一個序列化串，我們這裡定義的兩個方法。

前面先不用看了，因為我只是對這個屬性進行了複製，然後將這個序列化字母串放到了這個1。txt中，然後正常的話，然後我們進行一個反序列化這個字母串，裡面的字母串。

然後可以看見他正常的運行的這個destruct和這個wakeup。前面已經提到過了，就是一個在反序列化的過程中，在序列化重新進行那個反序列化的過程中，一個會調用的一個方法。

然後destruct就是在因為他這個反序列化以後，他就生成了一個對象，然後把這個對象因為使用結束以後就會進行一個銷毀。然後非正常輸出，這是我們前面那個對象進行序列化以後的正常的字母串。

也就是說我們的objective是四個字母串，一個test的長度，然後裡面有一個屬性，屬性的名字也是一個string型的，是一個字節的長度，然後S也是屬性的那個值，就是一個bitram這個值。

它是一個S的。然後我們將這個string這個屬性的個數如果改為2以後，然後再進行一個就是按照我們這個方法再進行一個輸出的話，它就會造成他那個wakeup的一個跳過。

但是destruct這個方法仍舊被執行。然後比較知名的利用這個漏洞的話，就有那個sugarCRM的6。5。3，6。5。23的一個反序列化注入漏洞的話。然後這裡我列了。

然後CTFT的話主要是HITCOM2016的那個baby trick，然後因為那個時間這麼短，然後因為那個篇幅的限制，我這裡就不再追溯這個CVE了，然後有興趣的同學可以等一會自己去那個谷歌一下。

或者有問題可以來問我。然後我們著重講一下這個PHP三星序列化及反序列化處理器設置不當帶來的安全隱患。這個首先要看一下這篇文。PHP三星序列化及反序列化處理器的話。

其實在一個在在他的PHP默認的是有三種存儲形式嗎？然後我們可以看到PHP默認的一個處理格式的話，就是建名加上書寫，然後經過序列化以後的字幕串。

然後有一個這個跟我們這個漏洞相關的也就是PHP cell rails LICE這個處理器，它是一個經過它就是我們正常的那個經過cell rails LICE處理的一個一個數組。

然後我們看一下他這個利用的過程，他這個在利用的時候是先是使用了一個PHP cell rails LICE這個處理器去處理這個字幕串。然後再用一個PHP默認的這個PHP的這個處理器去處理生存的這個字幕串。

這個字幕串默認的我們這個cell rails LICE這個我們先看一下，他就是這樣一個字幕串，然後進行一個反序列化。然後我們長度的話肯定是20，然後他的名字就是三星的一個名字嗎？然後進行一個數組，對吧？

然後如果使用PHP的話，PHP的這個處理器的話，他因為他這個PHP處理器默認有一個建名，建名對應後面的序列化的值，然後中間有一個速限，但是我們在這裡速限速限這裡進行了一個注入嗎？

然後就會導致他這個利用那個PHP處理器的話會生成這樣一個就是實例化，那個反序列化出這樣一個對象。然後就是可以利用這這幾個點吧，這個點去實現一個注入。然後再講一講這個題。

因為我們前面因為前面這個PHP三星反序列化及序列化這個處理器的話，他這個題的話應該來說是就是在PHP反序列化漏洞中是比較經典的一個題吧。這幾年做到的，然後先看一下那個源碼。

源碼我們當時給了是三個三個頁面。這是第一個頁面，然後第一個頁面也就是說啊，不對，應該先看那個class。php。class。php的話，class-1就是一個先定義了一個file的屬性嘛。

然後裡面再調用了幾個construct和destruct的方法。然後construct的話就是默認他裡面的發的只是index。php，然後destruct這個就比較有意思了。

他是對這個文件存在是否存在進行一個輸出嗎？然後-2的話，-2的話就是一個也是跟前面一樣，但是他這有一個其實有一個小提示吧，object這個東西，一個屬性在。然後其實也是後面寫利用代碼的時候一個引子吧。

然後construct這個先無論他有沒有先進行一個複製為null，然後toString的時候調用一個execute的方法，然後這裡你會發現他這個-2裡面是沒有調用這個。

是沒有定義這個execute的方法的。然後是在後面的-3裡面，也就是說他大概就是讓你去寫這樣一個，把這個裡面的對象放到這裡面去使用，然後就可以了。然後說到這個toString。

前面就比較有意思的是因為他這有一個echo，echo就是在輸出的時候會調用這個toString。然後-3的話就比較常規execute這個方法定義以後，然後一個eval。

eval也就是我們可以使用我們無論我們輸入什麼只要權限夠都可以玩，對吧？然後還給了一個phpinfo的頁面，phpinfo的這個頁面就其實也是一個引子吧。

因為他這個sanshine的地方有一個autostart是關閉的，然後比較重要的是在這，sanshineupload和sanshinecleanup。

uploadprogress這個sanshine裡面的方法的話主要是因為他這個enable_all，也就是說我們在一個上傳的過程中是可以進行一個去控制我們的sanshine。

然後cleanup如果是開啟的話，就是你對那個sanshine控制以後他可能就會被清除掉。然後思路就比較清晰嘛，然後就是構造代碼的問題，但是我們回頭再看一下，他這個無論是index。

php還是phpinfo還是class。php三個頁面都是沒有那個普通的我們比如說傳值的那些get啊，什麼post啊，或者cookie什麼的，然後更別說那些xff對吧。

那麼就是因為我們剛剛我也講過了那個phpinfo這個裡面的sanshine，他可以是做到一個控制我們的sanshine的一個變量，那麼思路就比較清晰嘛，就是分別構造一個，等一下我代碼放一下。

前面就是很常規的先引入這三個for，然後對三個for都進行一個實例化，然後實例化出三個對象，for1，for2，for3嘛。然後我們對思路再理一遍，首先是要用到這個for3。

因為無論如何這個for3裡面這個evil這個肯定是要注入你想要的代碼的，然後我們這裡就可以注入這樣一個代碼，這個應該都懂吧，system就是一個調用系統函數的一個API接口，然後進行一個ls-l。

然後for2的一個objector，就是將這個for3複製到這個for2的objector，也就是說我們目的就是讓這個toString執行，然後這個objector可以execute。最後。

畢竟要用到這個toString這個方法，肯定是要一個equal的，equal的話，那我們就對這個for1裡面的for，也就是它的屬性進行一個複製，將這個for2複製進去。然後我們看一下結果。

結果就是這樣一串序列劃串吧，然後這個怎麼用的話，我這裡是要先構造一個上傳的表單吧，表單其實我已經構造好了。正常的話肯定是輸出這樣一個，就跟我們前面的源碼一樣，然後我這邊已經構造好上傳的一個表單了。

直接拿去打就可以了。這個三順，因為我前面已經用過了，它可能會有保留那些我已經打過的那些函數。然後這個點我要講一下，a_'的話，就是我們剛剛看的那個，就是這個裡面，這個裡面的利用吧。

就是對一個a_進行一個注入，然後後面的一個實例化組串可以，就是讓它使用的時候可以實例化出來。然後看一下結果，就可以順利的打到那個php的flag的文件，然後接下來就是再構造這個。

跟剛剛這個slow一樣的，然後我們直接去cut這個文件就可以了。前面這個a，然後一個'管道夫嗎，不要更改，然後可以看見我這邊已經打出一個flag。png了。因為我是把它放在注釋裡面。

然後我這邊因為是環境是重新搭建的，也沒有當時的那個flag了，我就直接自己寫了一個注釋在裡面，可以看見很順利的打到這個flag。然後幾篇文章，幾篇文章的話，這個web3的這個，是當時我看了，我沒看明白。

是我是看了另外一個人的那個復現，就是重新復現出來的。然後這幾篇文章我等一下都可以分享給大家。Samsung Auto Start，這個我不用說，就是我們在一個php文件裡面，對，php文件裡面。

比如說我們要定一個Samsung，一般都會用Samsung Start，對吧？然後Auto Start開啟的話，就是無論你有沒有使用這個Samsung Start都會直接給你產生一個Samsung。

然後在php。ini裡面我設置了是這樣一個php serialize這個方法，但是我在代碼裡是使用了php的方法，也就是這個漏洞的主要成因嘛。然後Cleanup。

這個就是防止我這個放進去的Samsung立即被銷毀。然後Enable，就是我們可以控制這個Samsung的一個上傳，Name的話。

就是我們通過這個upload的這個progress可以去控制它的一個存儲的文件名字。然後下面這個跟上面這些，基本上對於我們漏洞的原理來說沒有什麼大的，反正就是它這個上傳的話。

就是我們可以理解為一個post和get的一個過程，然後造成一個Samsung的一個注入。好了，我的分享就到此結束了。好的，是講完了是嗎？嗯。好，那非常感謝Bobo的分享，接下來就是我們的行長問答環節。

時間為10分鐘，對今天所講的內容有疑問的小夥伴，可以用文字在心裡提問。這個，先@一下它，它這個為什麼會調用兩次，因為你生成一個對象，肯定會有一個，對，就是這。你生成一個，首先我們這個。我找找代碼在哪。

首先我們不是生成了一個test的這個對象嗎？然後它肯定是在內存中有位置，那這個肯定是要被銷毀的，對吧？這個肯定是要被銷毀的，就是我們第一次就是生成了一個對象，然後存儲成一個序列化自主串以後。

然後再進行一個反序列化，它又是就是重新生成了一個對象，也就是說我們在這個。這段代碼裡面會有兩個對象存在，對，所以會進行兩次destruct。ToString跟destruct是一樣的。

因為我們那個ToString都是進行了一個echo，懂嗎？就是我這裡不是有一個echo嗎？然後這裡也有一個echo，然後就進行了兩次toString方法。

PHP Unserialized這個不是只獲得一個數字，我這邊演示給你看一下。因為我那個，等一下我找一下那個，就進行一個簡單的那個。這下面就是實例，這個它並不是直接用方法，只要是你這個object。

它那個前面那個array這個樹組是因為它那個存儲格式就是一個array的格式，所以我會用到那個array。然後反序列化字母串的話就相當於我們的json了，比如說我生成一個array。57行報錯。

上面報錯。然後就可以看到它這個array是實例化出一個樹組，然後這個array的話就是int行。反正就是這樣子，無論是只要是可以序列化的東西都可以反序列化。好。可以看到就是可以恢復它原來的那個樣子。

就跟我們json存儲的一樣。還有小夥伴有問題嗎？然後可以現在提出來。抓緊時間啊。它這個當序列化字母串中，對呀，它這個就是會跳過那個，就是因為它會，它大於那個真實屬性的格數的時候才會跳過。

如果等於它真實屬性就正常執行了呀。通過這個漏洞可以進行哪些操作？哪些操作怎麼說呢？應該都是些騷操作吧。



![](img/d1071b70aeaafee64a1287ab62a98b7d_6.png)

通過這個漏洞的話，就是你在那個console，就是它比如說一些魔術方法裡面寫了一些就是比較敏感的，就像剛剛那道題的evo，或者裡面有一個注入一樣，都是可以執行的。然後比較著名的就是那些那個框架的漏洞。

或者說那些CMOS的漏洞。這個就是收割CRM這個PHP犯序列化漏洞，這個是比較著名的，然後還有一個那個joomla，joomla，我在這裡打一下。還有嗎？還有嗎？這個漏洞一般會出現在。

比如說那些就是它裡面，一般現在它那個PHP的一些CMOS一般都是會用一些寫一些類吧，它不會像原始的那些就是不方便那些就是更改的，它肯定會寫在一些類裡面。那既然用到類肯定會用到那個construct方法。

如果它如果那些類裡面就是魔術方法，就是裡面沒有重新定義的話，那肯定是沒有的。但是它如果魔術方法對它進行一些重新定義了，或者在裡面寫了一些不可描述的一些方法，然後就很有可能會造成這個漏洞。

那本次的行長問答環節就先告一個段落吧。有時間的問題，如果還有疑問的小夥伴可以等下集結束之後，和大咖繼續交流。那我們就先進入今天的行長分書環節。

今天我們的大咖為群裡的小夥伴挑選了一本深入PHP面向對象模式與實踐這本書。那接下來就有請Virgo在剛剛所有參與交流互動的小夥伴裡面選擇一位你覺得今晚聽客最認真互動最積極的小夥伴，然後在群裡@一下。

@一下就可以了？對，先@一下。就一吧？12345，就這個吧。因為我就@過他。好，洛基是吧？嗯。那恭喜洛基是我們今天的新女兒。剛剛那個突發情況，因為說洛基之前有拿到過我們的自傳書，所以今天這個，對。

這本書我們要換一位新的小夥伴。那就N2吧。@一下。OK，N2，在嗎？在的話可以冒一下泡。@一下。好，那恭喜安秋成為今天的新女兒。

然後你將獲得由漏洞銀行代表本期的大咖為你送出的深入PHP面向對象模式與實踐這本書。那一會活動結束之後我們會聯繫你。關於送書環節後續的結果呢，我們也會在後期官方發布的本期大咖面對面推文中公示給大家。

可以通過我們的微信公眾號或者是官方微博了解後續的詳情。沒有抽獎的小夥伴也不要感到遺憾，以後可以多多關注漏洞銀行官方群的各種活動。那今天晚上大咖面對面的視頻直播就到此結束。

對今天晚上所講的內容有疑問可以繼續在視頻裡和大咖進行交流。我們下周再見吧。(音樂)。

![](img/d1071b70aeaafee64a1287ab62a98b7d_8.png)

更多美食视频 请订阅我的频道。