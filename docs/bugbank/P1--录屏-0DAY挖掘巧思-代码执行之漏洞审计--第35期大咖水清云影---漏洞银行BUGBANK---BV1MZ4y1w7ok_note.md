# 代码审计与漏洞挖掘实战教程 - 第35期

![](img/2bd75888f153eff653c65b6782e52f0d_1.png)

![](img/2bd75888f153eff653c65b6782e52f0d_3.png)

在本节课中，我们将学习代码审计的核心思路，并通过两个具体的PHP代码执行漏洞案例，深入理解如何发现和利用这类安全漏洞。课程内容涵盖审计方法论、基础概念回顾以及实战案例分析。

## 概述：代码审计的核心思路 🧠

![](img/2bd75888f153eff653c65b6782e52f0d_5.png)

进行有效的代码审计需要一个清晰的思路。总体可以分为以下四点：

![](img/2bd75888f153eff653c65b6782e52f0d_7.png)

![](img/2bd75888f153eff653c65b6782e52f0d_9.png)

![](img/2bd75888f153eff653c65b6782e52f0d_11.png)

以下是四种核心的审计思路：

1.  **通读全文**：了解整个应用的业务逻辑是挖掘有价值漏洞的基础。可以从几个关键点入手：
    *   从公共函数文件入手，例如包含 `common`、`function` 关键字的文件。
    *   关注配置文件，例如包含 `config` 关键字的文件，其中常有数据库等关键配置。
    *   关注安全过滤文件，例如包含 `check`、`filter` 等关键字的文件，这是程序的全局过滤点。
    *   从 `index.php` 等入口文件入手，了解程序的架构和运行流程。

![](img/2bd75888f153eff653c65b6782e52f0d_13.png)

![](img/2bd75888f153eff653c65b6782e52f0d_14.png)

![](img/2bd75888f153eff653c65b6782e52f0d_16.png)

2.  **敏感关键字回溯**：这是最常用的方法。根据敏感函数（如 `eval()`, `system()`），逆向追踪其参数的传递过程，判断参数是否可控。

![](img/2bd75888f153eff653c65b6782e52f0d_18.png)

![](img/2bd75888f153eff653c65b6782e52f0d_20.png)

![](img/2bd75888f153eff653c65b6782e52f0d_22.png)

![](img/2bd75888f153eff653c65b6782e52f0d_24.png)

3.  **功能点审计**：这是比较高效的方法。部署CMS后，先浏览其功能，例如找回密码、文件上传、登录认证、留言板等。这些功能点通常是漏洞的高发区，积累其他CMS的漏洞知识有助于举一反三。

![](img/2bd75888f153eff653c65b6782e52f0d_26.png)

![](img/2bd75888f153eff653c65b6782e52f0d_28.png)

![](img/2bd75888f153eff653c65b6782e52f0d_30.png)

![](img/2bd75888f153eff653c65b6782e52f0d_32.png)

4.  **查找可控变量**：在代码追踪过程中，重点关注用户可控的变量，并追踪其是否传递到了危险函数。可以借助工具（如RIPS）的“User Input”功能来辅助查找。

![](img/2bd75888f153eff653c65b6782e52f0d_34.png)

![](img/2bd75888f153eff653c65b6782e52f0d_36.png)

上一节我们介绍了代码审计的整体思路，本节中我们来看看今天的主角——代码执行漏洞。

![](img/2bd75888f153eff653c65b6782e52f0d_38.png)

![](img/2bd75888f153eff653c65b6782e52f0d_40.png)

![](img/2bd75888f153eff653c65b6782e52f0d_41.png)

![](img/2bd75888f153eff653c65b6782e52f0d_43.png)

![](img/2bd75888f153eff653c65b6782e52f0d_45.png)

![](img/2bd75888f153eff653c65b6782e52f0d_47.png)

## 代码执行漏洞原理 ⚙️

![](img/2bd75888f153eff653c65b6782e52f0d_49.png)

![](img/2bd75888f153eff653c65b6782e52f0d_51.png)

![](img/2bd75888f153eff653c65b6782e52f0d_53.png)

代码执行漏洞的利用条件非常明确，只有两点：
1.  存在一个**危险函数**。
2.  传递给该函数的**参数可以被用户控制**。

![](img/2bd75888f153eff653c65b6782e52f0d_55.png)

![](img/2bd75888f153eff653c65b6782e52f0d_57.png)

![](img/2bd75888f153eff653c65b6782e52f0d_58.png)

![](img/2bd75888f153eff653c65b6782e52f0d_60.png)

常见的危险函数包括：
*   `eval()`： 将字符串作为PHP代码执行。
    ```php
    eval($_GET[‘code’]); // 如果code参数可控，则存在漏洞
    ```
*   `assert()`： 检查一个断言是否为 `FALSE`，也可执行代码。
*   `preg_replace()`： 执行一个正则表达式的搜索和替换。当使用 `/e` 模式修正符时，第二个参数（替换字符串）会被作为代码执行。
    ```php
    // 如果$pattern, $replacement, $subject 均可控，且模式中包含 /e，则可能造成代码执行
    preg_replace($pattern, $replacement, $subject);
    ```
*   `call_user_func()` / `array_map()` 等：动态执行函数。

![](img/2bd75888f153eff653c65b6782e52f0d_61.png)

![](img/2bd75888f153eff653c65b6782e52f0d_63.png)

![](img/2bd75888f153eff653c65b6782e52f0d_65.png)

![](img/2bd75888f153eff653c65b6782e52f0d_67.png)

![](img/2bd75888f153eff653c65b6782e52f0d_69.png)

![](img/2bd75888f153eff653c65b6782e52f0d_71.png)

其中，`preg_replace()` 函数需要特别讲解，因为它涉及的漏洞模式比较有特色。

![](img/2bd75888f153eff653c65b6782e52f0d_73.png)

![](img/2bd75888f153eff653c65b6782e52f0d_74.png)

![](img/2bd75888f153eff653c65b6782e52f0d_76.png)

`preg_replace()` 函数有三个参数，如果第一个参数（模式）中包含了 `/e` 模式修正符，那么第二个参数（替换字符串）将被作为 `PHP` 代码来执行。因此，只要这三个参数中有一个可控，并且能构造出包含 `/e` 的模式，就可能引发代码执行。

![](img/2bd75888f153eff653c65b6782e52f0d_78.png)

![](img/2bd75888f153eff653c65b6782e52f0d_80.png)

理解了基本原理后，接下来我们通过两个实战案例来具体分析。

![](img/2bd75888f153eff653c65b6782e52f0d_82.png)

![](img/2bd75888f153eff653c65b6782e52f0d_84.png)

## 实战案例一：某CMS preg_replace() 代码执行漏洞 🔍

![](img/2bd75888f153eff653c65b6782e52f0d_86.png)

![](img/2bd75888f153eff653c65b6782e52f0d_88.png)

![](img/2bd75888f153eff653c65b6782e52f0d_90.png)

![](img/2bd75888f153eff653c65b6782e52f0d_92.png)

![](img/2bd75888f153eff653c65b6782e52f0d_93.png)

第一个案例来自某公司CMS。漏洞的出发点是寻找危险函数 `preg_replace()`。

![](img/2bd75888f153eff653c65b6782e52f0d_95.png)

![](img/2bd75888f153eff653c65b6782e52f0d_97.png)

![](img/2bd75888f153eff653c65b6782e52f0d_99.png)

![](img/2bd75888f153eff653c65b6782e52f0d_101.png)

![](img/2bd75888f153eff653c65b6782e52f0d_103.png)

**漏洞分析：**
1.  **定位危险函数**：在 `/lib/` 目录下的某个文件中，我们找到了 `preg_replace()` 函数。
2.  **判断参数可控性**：这是漏洞利用的关键。我们需要查看传递给 `preg_replace()` 的参数是否来自用户输入。
    *   代码首先判断是否通过 `GET` 或 `POST` 传递了 `catid` 参数。
    *   然后，这个 `catid` 被传递到一个封装的 `get()` 函数中，最终进入 `preg_replace()`。
    *   通过追踪，发现 `catid` 的值被放入一个数组，并作为 `preg_replace()` 的第三个参数（`$subject`）的一部分。而该函数的第一、二个参数（`$pattern`, `$replacement`）在代码中是固定的。
3.  **构造利用链**：虽然 `$pattern` 是固定的，但其内容包含需要匹配的字符串。我们需要让用户可控的 `catid` 值去匹配这个模式，从而触发代码执行。
    *   固定的模式类似于：`/.*(.+)$/e`
    *   我们需要构造 `catid` 的值，使其能被此模式匹配。例如，`catid` 可以构造为 `{${phpinfo()}}`。当 `preg_replace()` 执行时，匹配到的内容 `phpinfo()` 会被当作代码执行。

**漏洞复现：**
在存在漏洞的功能点（如投稿功能）提交数据，并在 `catid` 参数中插入Payload：`{${phpinfo()}}`，即可成功执行 `phpinfo()` 函数。同理，`typeid` 等同样可控的参数也可用于利用。

![](img/2bd75888f153eff653c65b6782e52f0d_105.png)

![](img/2bd75888f153eff653c65b6782e52f0d_107.png)

![](img/2bd75888f153eff653c65b6782e52f0d_109.png)

这个案例清晰地展示了“危险函数+可控参数”的漏洞模式。接下来，我们看一个思路更巧妙的案例。

![](img/2bd75888f153eff653c65b6782e52f0d_111.png)

![](img/2bd75888f153eff653c65b6782e52f0d_113.png)

## 实战案例二：ThinkPHP框架下的奇技淫巧 🎩

![](img/2bd75888f153eff653c65b6782e52f0d_115.png)

第二个案例涉及一个基于ThinkPHP框架的影视CMS。审计框架类程序，通常从控制器（Controller）入手。

![](img/2bd75888f153eff653c65b6782e52f0d_117.png)

![](img/2bd75888f153eff653c65b6782e52f0d_119.png)

![](img/2bd75888f153eff653c65b6782e52f0d_121.png)

**漏洞背景：**
该漏洞的发现源于一个公开的ThinkPHP漏洞，涉及 `display()` 函数，这是TP框架中用于模板展示的函数。

![](img/2bd75888f153eff653c65b6782e52f0d_123.png)

![](img/2bd75888f153eff653c65b6782e52f0d_125.png)

**漏洞分析：**
1.  **入口点**：在某个控制器中，`display()` 函数接收一个 `tpl` 参数，该参数未经过滤。
2.  **错误日志机制**：ThinkPHP框架在开启调试模式时，会将错误信息写入日志文件（位于 `/Runtime/Logs/`，按日期命名，如 `18_08_18.log`）。
3.  **奇特的利用链**：
    *   首先，我们通过请求传入一个特殊的 `tpl` 参数值，例如 `<?php phpinfo();?>`。由于 `tpl` 参数未过滤，且指向一个不存在的模板文件，程序会抛出异常。
    *   这个包含 `<?php phpinfo();?>` 的错误信息会被**写入到错误日志文件**中。
    *   然后，我们**直接通过URL访问这个错误日志文件**。由于ThinkPHP的URL路由机制（兼容模式），我们可以构造URL来“调用”日志文件。
    *   关键点在于，ThinkPHP在渲染时，可能会将日志文件**当作模板文件来解析执行**，从而导致其中写入的PHP代码被执行。

**漏洞复现：**
1.  请求：`http://target.com/index.php?m=My&a=show&tpl=<?php phpinfo();?>`，触发错误并将代码写入日志。
2.  请求：`http://target.com/index.php?m=Runtime/Logs/18_08_18.log&a=show&tpl=aaa` （具体URL需根据路由调整），访问日志文件，触发代码执行。

![](img/2bd75888f153eff653c65b6782e52f0d_127.png)

![](img/2bd75888f153eff653c65b6782e52f0d_129.png)

这个案例的巧妙之处在于，它利用了框架的错误处理机制，将“写入日志”和“包含日志”两个步骤结合，最终实现了代码执行。它启示我们，审计时不仅要关注直接的参数传递，还要关注程序的其他功能（如日志、缓存）是否能被间接利用。

## 总结与问答要点 📝

![](img/2bd75888f153eff653c65b6782e52f0d_131.png)

![](img/2bd75888f153eff653c65b6782e52f0d_133.png)

本节课中我们一起学习了代码审计的基本思路和代码执行漏洞的挖掘技巧。

![](img/2bd75888f153eff653c65b6782e52f0d_135.png)

![](img/2bd75888f153eff653c65b6782e52f0d_137.png)

![](img/2bd75888f153eff653c65b6782e52f0d_139.png)

**核心总结：**
1.  代码执行漏洞的利用条件始终围绕 **危险函数** 和 **可控参数**。
2.  审计思路多样，包括通读全文、回溯关键字、功能点审计和追踪可控变量。
3.  对于框架类程序，应从控制器入手，并熟悉其URL路由、配置、日志等机制。
4.  工具（如RIPS）可以辅助审计，但核心还是对代码逻辑的理解。

![](img/2bd75888f153eff653c65b6782e52f0d_141.png)

![](img/2bd75888f153eff653c65b6782e52f0d_143.png)

**课堂问答精选：**
*   **代码审计需要什么基础？** 需要具备编程基础（如PHP），了解基本的语言特性和函数调用。建议先学习开发，再转向安全，能更深入理解漏洞原理。
*   **什么是可控变量？** 指用户可以控制其值的变量，例如通过 `$_GET`、`$_POST` 传入的参数。
*   **审计框架是否从控制器着手？** 是的，对于MVC框架，控制器是处理用户请求的核心，是审计的重点。
*   **如何绕过过滤规则？** 这取决于过滤规则的实现。如果只是简单的黑名单或字符串替换，通常存在绕过方法；如果是严格的白名单限制，则难以绕过。需要具体分析过滤代码。
*   **PHP审计会被Java取代吗？** 不会。只要PHP和Java语言仍在被使用，就会存在相应的代码审计需求。两者是并行的领域。

![](img/2bd75888f153eff653c65b6782e52f0d_145.png)

![](img/2bd75888f153eff653c65b6782e52f0d_147.png)

希望本教程能帮助你入门代码审计，并建立起挖掘代码执行漏洞的基本方法论。记住，多读代码、多积累、多思考，是提升审计能力的不二法门。