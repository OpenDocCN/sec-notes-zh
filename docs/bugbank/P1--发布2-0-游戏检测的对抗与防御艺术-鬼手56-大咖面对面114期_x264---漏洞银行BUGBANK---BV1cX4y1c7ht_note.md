# 课程 P1：游戏检测的对抗与防御艺术 🛡️🎮

![](img/b353d85daebf75f275e682d3a9d29a11_0.png)

![](img/b353d85daebf75f275e682d3a9d29a11_2.png)

在本课程中，我们将学习游戏安全领域中，针对外挂行为的检测原理以及相应的对抗（绕过）方法。课程内容将涵盖变量检测、堆栈检测、CRC检测和数据检测这四种核心检测手段，并通过实例演示其工作原理和绕过思路。

## 概述

游戏外挂行为主要分为两类：**修改游戏关键数据与代码**（篡改行为）和**调用游戏内部函数**（越权访问行为）。游戏安全人员针对这两种行为设计了多种检测方式。本课程将深入讲解其中最常用的四种检测技术及其对抗方法。

---

## 1. 变量检测

上一节我们概述了外挂的两种主要行为。本节中，我们来看看第一种针对函数调用（Call）的检测方式：变量检测。

### 1.1 原理

变量检测的核心思想是验证函数调用链的完整性。正常游戏逻辑调用一个功能时，会经过一系列前置函数，形成一个完整的调用链。而外挂通常会直接调用最终的关键功能函数，跳过了中间步骤。

基于此差异，可以在关键函数上方设置一个标志变量（例如初始化为0）。在正常的调用链中，会在调用关键函数前将此标志置为1。关键函数内部则检查此标志：若为1，则正常执行；若为0，则判定为异常调用（可能来自外挂），并触发处理逻辑。执行完毕后，需将标志变量恢复为0，以备下次检测。

**核心逻辑伪代码**：
```c
// 全局检测标志
int g_detect_flag = 0;

// 正常调用链中的某个前置函数
void NormalCallChain() {
    // ... 执行一些操作
    g_detect_flag = 1; // 调用关键函数前，置位标志
    CriticalFunction();
    // ... 其他操作
}

// 关键功能函数
void CriticalFunction() {
    if (g_detect_flag == 1) {
        // 正常游戏逻辑
        ExecuteGameLogic();
        g_detect_flag = 0; // 检测后复位
    } else {
        // 检测到异常调用，可能是外挂
        HandleCheat();
    }
}

// 外挂直接调用
void CheatCall() {
    // 直接调用，g_detect_flag 仍为 0
    CriticalFunction(); // 这将触发检测
}
```

### 1.2 对抗方法

变量检测的致命弱点是其依赖一个存储在内存中的全局变量。攻击者可以利用内存搜索工具（如Cheat Engine）定位并修改此变量。

以下是定位和修改检测变量的步骤：

1.  **定位变量地址**：在检测未触发时（标志为0），使用工具扫描内存中的0值。然后触发一次正常功能调用（使标志变为1），再次扫描变化后的值（如1）。通过反复筛选，可以定位到唯一的标志变量地址。
2.  **处理方法**：找到地址后，有两种主要对抗方式：
    *   **修改游戏代码**：直接修改检测代码中的关键跳转指令（如JNZ改为JMP），使其永远执行正常逻辑。
    *   **修改内存值（推荐）**：在外挂调用关键函数前，手动将该标志变量的值设置为1。调用结束后，游戏自身的代码会将其复位。这种方式不修改游戏原始代码，更隐蔽。

---

## 2. 堆栈检测

上一节我们介绍了利用全局变量的检测方法。本节中我们来看看另一种更隐蔽的检测方式：堆栈检测。

### 2.1 原理

堆栈检测通过检查函数调用时的返回地址来判断调用是否源自游戏本身。正常游戏逻辑中，调用链上的所有返回地址都位于游戏主模块的内存空间内。而外挂通常作为一个独立的DLL注入，其调用关键函数时，返回地址会指向外挂模块。

检测代码会在关键函数入口处，检查调用栈上一层的返回地址。如果该地址不在游戏主模块的预期范围内，则判定为外挂调用。

**调用栈对比**：
```
正常游戏调用栈：
[游戏模块] 返回地址 A
[游戏模块] 返回地址 B
[系统模块] ...
[关键函数]

外挂调用栈：
[外挂DLL模块] 返回地址 X
[系统模块] ...
[关键函数]
```

### 2.2 对抗方法

堆栈检测没有全局变量那样的内存访问痕迹，因此对抗思路不同。

1.  **单层堆栈检测**：只校验一层返回地址。
    *   **方法**：在调用游戏函数前，通过钩子（Hook）技术修改本层返回地址，将其伪造为游戏模块内的一个合法地址。在函数返回前，再恢复为真实地址。
2.  **多层堆栈检测**：校验多层返回地址。
    *   **方法**：在调用前，主动布局堆栈，连续伪造多层的返回地址均为游戏模块内地址。调用结束后，再将堆栈还原。此方法比处理单层检测更简单，因为无需保存原始值，直接还原堆栈指针即可。

---

## 3. CRC检测与数据检测

前面两节我们讨论了针对函数调用的检测。本节中我们来看看针对代码和数据篡改的检测方法。

### 3.1 CRC检测原理

CRC（循环冗余校验）是一种校验算法，其特点是原始数据中任何一个字节发生改变，计算出的CRC值都会发生巨大变化。游戏利用这一特性进行代码完整性校验。

**流程**：游戏在启动时或某个时刻，计算关键代码段（.text段）的CRC值并存储。随后，游戏会启动一个独立的检测线程，持续或定期地重新计算代码段的CRC值，并与存储的原始值进行比较。若不一致，则判定代码已被修改（例如被外挂打补丁），并采取相应措施。

### 3.2 对抗方法

CRC检测需要检测线程反复读取代码段内容进行计算。这提供了一个关键的突破口：**内存访问关系**。

*   **方法**：在游戏的代码段（具有可执行权限）设置内存访问断点。由于正常情况下，除了CRC检测线程，几乎没有其他代码会去“读取”可执行代码段的内容。因此，断点触发的位置极大概率就是CRC检测代码所在。定位到检测代码后，即可通过修改跳转等方式将其绕过。

### 3.3 数据检测原理

数据检测的原理与CRC检测完全相同，区别在于校验对象是游戏的数据段（.data段等），其中存放着变量、字符串等。

### 3.4 对抗方法

对抗数据检测的步骤与CRC检测类似，但更复杂一些。

1.  **定位访问代码**：在数据段设置内存访问断点。
2.  **筛选检测代码**：与代码段不同，数据段会被游戏正常逻辑频繁访问（例如读取NPC名字、物品属性）。因此断点会多次触发，产生多条访问记录。攻击者需要从这些记录中，分析并筛选出哪一条属于检测线程的校验代码（通常不在游戏主模块，或具有周期性访问特征）。

---

## 总结

本节课中我们一起学习了游戏安全中四种常见的检测与对抗技术：

1.  **变量检测**：利用CE等工具搜索并修改内存中的检测标志位。优点是原理简单，缺点是有明显的内存痕迹。
2.  **堆栈检测**：通过钩子或内联汇编伪造返回地址，以绕过对调用栈的校验。这是目前较主流的调用检测方式。
3.  **CRC检测**：利用代码段访问断点直接定位检测线程，并进行处理。对抗相对直接。
4.  **数据检测**：同样利用访问断点定位，但需要从多条访问记录中排查出真正的检测代码。

![](img/b353d85daebf75f275e682d3a9d29a11_4.png)

![](img/b353d85daebf75f275e682d3a9d29a11_5.png)

在实际对抗中，若调用某个功能失败，可优先尝试搜索变量检测；若无果，则很可能遇到了堆栈检测。理解这些原理是进行有效分析和对抗的基础。