![](img/4cea6cb6b5353fc844656021e7df07af_0.png)

# i春秋零基础入门Android逆向 - P12：课时1 阶段考核 🧪

在本节课中，我们将对一个阶段考核题目进行思路讲解。该题目涵盖了APK反调试、签名校验和函数分析三个核心知识点。通过学习本教程，你将掌握如何分析并绕过这些常见的Android应用保护机制。

## 概述 📋

本次考核的题目相对简单，函数量不大，主要考察对基础知识的掌握。如果你能独立完成，说明前一阶段的学习效果良好。如果未能完成，通过以下分析，你也会发现其原理并不复杂。

## 第一部分：APK反调试 🛡️

上一节我们介绍了课程概述，本节中我们来看看APK反调试的实现与绕过方法。

应用程序在`APP`类中对模拟器与调试状态进行了简单检测。如果发现异常，程序将直接结束进程。

以下是绕过此检测的两种方法：
1.  直接删除`smali`代码中调用`Process`函数的代码。
2.  在`MainActivity`的`onCreate`函数起始处插入`waitForDebugger`函数，启动程序后再进行`attach`调试。

看到这里，可能有同学会疑惑：程序的入口点通常在带有`launcher`属性的`Activity`中，为何会找到`APP`类？

答案在`AndroidManifest.xml`文件中。对于未指定入口点的进程，初始化流程是`Application` -> `Activity`。而此应用在`Manifest`中定义了自己编写的进程入口点（`APP`类）。因此，程序的初始化流程应为：`APP` -> `MainActivity`。

一个进程内可以有多个窗口，但进程实例只能有一个。因此，程序初始化时会先初始化进程，再初始化窗口，这就区分了进程入口点与窗口入口点。

## 第二部分：签名校验 🔑

上一节我们介绍了如何绕过反调试，本节中我们来看看程序中的签名校验机制。

程序的整个校验流程与签名校验关系密切，相关调用都在`Check`类中。因此，我们重点关注`check`函数的流程。

该函数调用`RC4`函数对输入的`flag`进行操作，然后与`C_flag`这个定值进行比较。而`RC4`的第一个参数是调用`getKey`函数的返回值。显然，分析重点在`getKey`部分。

我们来看`getKey`的实现：
*   它通过系统的`PackageManager`获得程序的`PackageInfo`中的`signatures`信息（即签名信息），并将其取出返回。
*   这个签名信息将直接作为`RC4`算法的密钥参与运算。

因此，如果对原始APK包进行修改并重新签名，这里的签名值就会改变，导致`RC4`运算结果不同，最终无法得到正确的`flag`。直接调试不可行，因为`APP`类中有调试校验。

在这里简单提供几种绕过签名校验的方法：
1.  **Hook关键函数**：通过`Xposed`或`Frida`对`getKey`函数进行`Hook`，直接获取其返回值，该值便可直接用于`RC4`解密。
2.  **Hook `isDebuggerConnected`函数**：直接返回`false`，以阻止调试检测。
3.  **编写程序获取签名**：`getPackageInfo`函数也可获取其他应用的签名数据，因此可以编写一个应用来获取此考核题目的签名信息。
4.  **直接提取签名信息**：APK的签名信息存放在`META-INF`文件夹的`CERT.RSA`文件中。签名值即为该文件中`0x038`到`0x337`偏移位置的数据（具体格式可自行查阅资料）。

签名校验常用于应用保护。如果发现应用反编译重打包后运行异常，可考虑程序中带有签名校验。签名校验相关的关键词为`signature`、`certificate`等。

## 第三部分：函数分析与Flag获取 🏁

上一节我们探讨了签名校验，本节中我们通过函数分析来最终获取`flag`。

使用`JEB`或`Android Killer`进行反编译，可以获得非常接近源码的`Java`代码。通过`Java`或安卓还原算法，即可找到`flag`。

以下是其核心逻辑的伪代码描述：
```java
// 伪代码逻辑
String input = 用户输入的字符串；
byte[] key = getKey(); // 获取签名作为密钥
byte[] encrypted = RC4(key, input.getBytes());
boolean isCorrect = compare(encrypted, C_flag); // 与预设值比较
```

即使不认识`RC4`函数，只要看懂其变换核心是异或操作，也能猜出这是一个对称加密算法，加解密使用同一套算法。

因此，可以直接拷贝反编译的`Java`代码，将签名信息的字节逐个取出，最多补充一些类型转换语法即可使用。使用`Android Studio`或`Eclipse`编写程序即可获得`flag`。

以下是使用`Java`和`Eclipse`还原算法并获得`flag`的思路：
1.  **模拟程序校验**：字符串`input`是我们在程序输入框中输入的字符串（注意`MainActivity`中对输入长度有限制）。经过`RC4`处理后，`result`是加密后的字符串，程序会将其与`C_flag`字符串进行比较。
2.  **逆向获取Flag**：由于是对称加密，我们将`C_flag`字符串作为输入，用相同的`RC4`算法和密钥（即签名）进行处理，得到的`result`字符串就是最终的`flag`。

## 总结 📝

![](img/4cea6cb6b5353fc844656021e7df07af_2.png)

本节课我们一起学习了Android逆向中的一个阶段考核题目。我们分析了**APK反调试**的检测点与绕过方法，探讨了**签名校验**的原理与多种绕过思路，最后通过**函数分析**，还原了算法并掌握了获取`flag`的完整流程。掌握这些基础技能是进行更复杂Android逆向分析的基石。