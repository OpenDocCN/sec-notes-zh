# i春秋零基础入门Android逆向 - P26：课时1 Android脱壳中的思路与技巧 🛡️

在本节课中，我们将要学习Android应用脱壳的基本思路与核心技巧。脱壳是指从经过加固保护的APK文件中，提取出原始的、未加密的代码（DEX文件）的过程。我们将通过分析一个简单的阿里加固早期版本APK，来演示完整的静态与动态分析脱壳流程。

## 概述：Android加固与脱壳原理

![](img/2576e293366fab7c5f234ba3650cce49_1.png)

![](img/2576e293366fab7c5f234ba3650cce49_2.png)

![](img/2576e293366fab7c5f234ba3650cce49_3.png)

![](img/2576e293366fab7c5f234ba3650cce49_4.png)

目前市面上存在的一种加固服务，会对APK中的DEX文件进行加密，以达到减少体积和隐藏代码的效果。这种加密加固技术常让新手感到无从下手。

![](img/2576e293366fab7c5f234ba3650cce49_6.png)

从今天开始，我将用几节课重点讲解如何进行脱壳。

首先说明Android壳的大致流程。这一类加固软件和Windows上的壳原理大致相同。程序运行时，会先执行壳的代码。在壳的代码中，执行解密和解码操作，把原始的程序代码还原回去，最后再执行原始代码。

根据这个流程，我们要脱壳时，需要在程序解码解密完毕之后，并且在到达程序的真实入口之前，在中间的某个位置把原始字节码导出并还原。这样一来，脱壳就完成了。当然，这里说得简单，实际操作起来有不少需要注意的地方。

![](img/2576e293366fab7c5f234ba3650cce49_8.png)

![](img/2576e293366fab7c5f234ba3650cce49_10.png)

## 目标APK分析

![](img/2576e293366fab7c5f234ba3650cce49_12.png)

![](img/2576e293366fab7c5f234ba3650cce49_14.png)

本节课我将使用一个简单的APK文件进行示例。我们的目标文件是一个APK文件，这是阿里加密的早期版本，难度偏简单。

在Android Studio中加载后，它有提示这是一个阿里加固的壳。查看其内部，点击类文件会提示文件已丢失，无法直接打开。这是显然的，因为它已经把类文件数据隐藏起来了。在APK中打开查看，能直接看到的函数很少。

![](img/2576e293366fab7c5f234ba3650cce49_16.png)

![](img/2576e293366fab7c5f234ba3650cce49_18.png)

实际上这里只有一个类，继承自`StartApplication`类。查看代码，它继承自`Application`，在壳代码中基本没做什么，只是加载了一个SO文件。这个SO文件就是关键。

## 应用入口点分析

![](img/2576e293366fab7c5f234ba3650cce49_20.png)

首先查看APK的`AndroidManifest.xml`文件。这个文件指明了整个APK所有窗体的入口和其他属性。这个APK比较简单，里面有一个`Activity`，带有`launcher`属性，标明它是程序的入口点。

![](img/2576e293366fab7c5f234ba3650cce49_22.png)

![](img/2576e293366fab7c5f234ba3650cce49_23.png)

![](img/2576e293366fab7c5f234ba3650cce49_25.png)

但是，像这样代码被隐藏起来后，这里已经无法直接加载了。那么整个APK程序如何能正常打开呢？这是因为对于所有`Activity`来说，有一个更早于它们执行的类，就是`Application`类。

查看`Application`的标签，有一个`android:name`属性，指定了这样一个类。`Application`的执行早于所有的`Activity`。所以很多壳，基本上所有的壳，都选择在这个地方执行它的解壳代码。

![](img/2576e293366fab7c5f234ba3650cce49_27.png)

因此，对于加壳程序，我们一定要注意`Application`标签。壳的入口就在`Application`标签中。另外一个入口是带有`main`、`launcher`属性的`Activity`。这里它的入口点加载了那个SO文件，然后后续操作都在SO层（Native层）进行了。

## 定位与分析SO文件

![](img/2576e293366fab7c5f234ba3650cce49_29.png)

我们找到这个SO文件进行分析。这是一个自压缩包，直接解压缩，然后找到要分析的SO文件用IDA打开。

在开始分析前需要说明，脱壳用到的技术是前面所有课程技术的综合。如果跳过了前面的课程，这节课可能看不懂。建议把前面的课程，特别是开发相关的课程先学习一下，那是解密课程的基础。

整个程序对原始代码进行了加壳保护，必然有一个地方用来存储原始代码。这个地方很显然，就是`assets`资源目录。我们找到并打开它，可以看到有4个文件，这4个文件显然就是存储原始代码文件的地方。

![](img/2576e293366fab7c5f234ba3650cce49_31.png)

图片文件可以不管，重点关注另外三个文件：一个`classes.jar`文件，一个`jiagu_data`文件。显然它们被某种算法压缩过，前面有标志位，后面数据无法直接看到，都是被加密后的代码。还有一个`f.jar`，这是一个非常简单的ZIP压缩包，实际上这个文件不怎么重要，可以直接忽略。

![](img/2576e293366fab7c5f234ba3650cce49_33.png)

![](img/2576e293366fab7c5f234ba3650cce49_34.png)

这一节我们重点关注`classes.jar`文件和`jiagu_data`文件，分析在SO层（JNI层）如何对它们进行操作。

## 动态注册与JNI函数分析

在IDA中打开SO文件进行分析。首先找到两个`native`函数：`attachBaseContext`和`onCreate`。我们在SO层找到它们对应的实现。

![](img/2576e293366fab7c5f234ba3650cce49_36.png)

![](img/2576e293366fab7c5f234ba3650cce49_37.png)

直接搜索`attachBaseContext`是搜索不出来的，这是非常理所当然的，因为它是一个动态注册的东西。关于动态注册，我们来看前几节课所写的JNI函数就知道，注册一般都放在`JNI_OnLoad`函数中执行。

![](img/2576e293366fab7c5f234ba3650cce49_39.png)

`JNI_OnLoad`函数是所有SO函数的一个入口点。跳转过去，这里有一个`JNI_OnLoad`函数。在这里很显然就是对我们的`native`函数进行注册，对应着这里的几个函数。

![](img/2576e293366fab7c5f234ba3650cce49_41.png)

![](img/2576e293366fab7c5f234ba3650cce49_43.png)

![](img/2576e293366fab7c5f234ba3650cce49_45.png)

`JNI_OnLoad`函数里面有两个参数，第一个是`JavaVM`指针，第二个是一个`reserved`参数。在`JavaVM`中，先通过`GetEnv`函数来获取到一个`JNIEnv`数据。把`JNIEnv`取出来以后，就能够调用里面的`RegisterNatives`方法来注册`native`函数了。

![](img/2576e293366fab7c5f234ba3650cce49_47.png)

![](img/2576e293366fab7c5f234ba3650cce49_48.png)

注册时，先要进行`FindClass`来获得`Java`类对象，然后调用`RegisterNatives`函数。这里面有三个参数：前面找到的`class`，指向`JNINativeMethod`结构体的指针，以及要注册的函数数量。

![](img/2576e293366fab7c5f234ba3650cce49_49.png)

![](img/2576e293366fab7c5f234ba3650cce49_50.png)

![](img/2576e293366fab7c5f234ba3650cce49_52.png)

![](img/2576e293366fab7c5f234ba3650cce49_54.png)

它大致的注册流程是这个样子的。我们对其进行还原，导入JNI头文件，然后对变量重命名。第一步调用`GetEnv`来获得`JNIEnv`，然后下面进行`FindClass`来找到想要注册的类，这里就是到`StartApplication`中来找这个类，然后注册`native`函数。

![](img/2576e293366fab7c5f234ba3650cce49_56.png)

![](img/2576e293366fab7c5f234ba3650cce49_58.png)

`RegisterNatives`对应着这里的函数。第一个参数是`class`，然后是`JNINativeMethod`结构体，这里要注册两个函数。重命名后跳过去，看一下地址指向的两个函数：`attachBaseContext`和`onCreate`，和我们自己的一一对应了。

![](img/2576e293366fab7c5f234ba3650cce49_60.png)

![](img/2576e293366fab7c5f234ba3650cce49_62.png)

![](img/2576e293366fab7c5f234ba3650cce49_63.png)

那么这里就是它在`JNI_OnLoad`中进行注册。我们把方法名字命名上去，记录下地址。`attachBaseContext`的基址是这个地方，`onCreate`的基址是另一个地方。

![](img/2576e293366fab7c5f234ba3650cce49_65.png)

![](img/2576e293366fab7c5f234ba3650cce49_67.png)

那么问题来了，为什么一定是这两个方法？其实这是有一定道理的。对于`Application`类，它是比较特殊的，因为它有两个函数：`attachBaseContext`和`onCreate`。`onCreate`函数不用说，它在对象创建时肯定会被调用。但实际上在这个函数之前，有一个方法是优先被调用的，就是`attachBaseContext`函数，它优先于所有方法被调用到。所以很多壳会在这个函数中执行代码的还原。然后在`onCreate`中，来进行`Application`的构造操作。这是很多壳进行操作的两个函数，这两个函数是自动被调用的。

![](img/2576e293366fab7c5f234ba3650cce49_69.png)

![](img/2576e293366fab7c5f234ba3650cce49_71.png)

![](img/2576e293366fab7c5f234ba3650cce49_73.png)

所以我们这里重点关照`attachBaseContext`函数，看它如何对原始代码进行还原。

![](img/2576e293366fab7c5f234ba3650cce49_75.png)

![](img/2576e293366fab7c5f234ba3650cce49_76.png)

![](img/2576e293366fab7c5f234ba3650cce49_78.png)

## 深入`attachBaseContext`函数

![](img/2576e293366fab7c5f234ba3650cce49_80.png)

![](img/2576e293366fab7c5f234ba3650cce49_81.png)

![](img/2576e293366fab7c5f234ba3650cce49_83.png)

跳转到它的地方进行分析。它里面有三个参数。在`native`层有三个参数，对应着Java层只有一个`Context`参数，所以第三个参数肯定是`Context`。它前面的两个参数，第二个是`jobject`，第一个是`JNIEnv`参数。

![](img/2576e293366fab7c5f234ba3650cce49_85.png)

往下分析，它调用的第一个函数是`init_classes`函数，传递的参数是我们刚才获取到的`JNIEnv`参数。双击跳过去看这个函数做什么。它获取`Java`层的一些属性、变量的`fieldID`，还有一些方法的`ID`值，保存到全局变量中。这是对于`Java`层的一些方法和属性进行获取。最后还对`Java`运行环境的版本进行了判断，是运行在`Dalvik`模式还是`ART`模式。这是一个进行初始化的操作。

初始化启动以后就调用下面的解壳代码了。我们来看它的解壳代码如何操作。前面一坨代码其实很简单，就是获取一些全局变量，比如资源路径、代码资源应该释放到哪个目录下，和前面无关，直接略过。

我们往下慢慢跑，关注它如何对我们的`dex`文件进行解密。可以看到两个非常关键的函数：`parseDex`和`replaceClassLoaderCookie`。根据名字就能够知道，第一个是对`dex`文件进行解码，第二个就是把它替换到`ClassLoader`中去了。

`parseDex`函数中，第一个参数是前面传递过来的，第二个参数`v38`初始化为0，显然这是一个输出的地方，把`parseDex`输出的值放到下面的函数中进行替换。所以这里很明显，这个函数是我们最为关注的函数。在这个函数内部就完成了对`dex`文件进行解密和还原的操作。

## 动态调试解密过程

![](img/2576e293366fab7c5f234ba3650cce49_87.png)

我们直接进行调试，把断点下好。调试需要打开命令行，进行端口转发，然后`attach`。但是这种`Application`标签的程序，执行起来后瞬间就会运行，选择挂接的时候时间已经错过了。我们应该用`am start`命令的`--start-application`方法来进行挂接。

![](img/2576e293366fab7c5f234ba3650cce49_89.png)

![](img/2576e293366fab7c5f234ba3650cce49_90.png)

输入它的`package`名和入口`Activity`的`launcher`来进行挂接启动。以调试方式启动，这样启动的时候，整个程序就停留在刚开始加载的情况下，而且这个时候连`Application`的地方也还没有执行。这个时候它刚开始要准备执行`attachBaseContext`函数了。这个时候我们就能够进行`attach`了。

![](img/2576e293366fab7c5f234ba3650cce49_92.png)

找到刚启动起来的程序进程，打开`monitor`，在`Java`层把`GDB`挂上去。注意端口可能被占用，需要关闭`Android Studio`等可能占用端口的程序。重新进行一次调试，从`adb`进入手机`shell`，然后进行挂接，把程序启动起来，`GDB`挂上去。调试起来以后就能够直接跑起来了。

程序在我们关注的函数中断下来了，开始对这个函数进行分析。它有两个参数，第一个是`JNIEnv`参数，第二个是一个输出的参数。进入函数，进行单步跟踪，看整个程序如何执行。

首先判断手机的运行环境是`Dalvik`模式还是`ART`模式。如果是`Dalvik`模式，就执行这段代码。这里已经开始去解压我们的压缩文件了。首先是`classes.jar`文件，把它取出来，调用`open`函数来打开这个`jar`文件，保存到内存中去。

![](img/2576e293366fab7c5f234ba3650cce49_94.png)

如果`SDK`版本大于13，执行这样一个函数；如果不是，执行另一个函数。由于我们的`API`版本是4点多，大于13（`API 19`），就选择这个地方下断点，看程序怎么做。

首先用`stat`获取文件信息，获取到文件大小，然后把它`mmap`进内存中去。这里就把我们整个文件给放到一个内存映射中去了。接着使用`RC4`算法对映射进去的内存进行`RC4`解密。解密完以后，再进行`LZMA`解压。所有一切都解密完以后，再进行返回。这是一个非常简单地在内存中解密文件的操作：读取并且解密文件。

![](img/2576e293366fab7c5f234ba3650cce49_96.png)

这里就是解密我们的`classes.dex`文件了。既然知道它是一个解密操作，我们关注一下它解密以后的代码放到什么地方。解密以后放到一个内存地址，例如`0x75199000`。解密完以后，就能看到内存中已经出现了原始的代码，这是一个`dex.035`...，很显然是一个`dex`文件。

## 导出初步解密数据

既然这里已经把一个原始`dex`文件弄出来，我们就可以把这些数据保存起来，完成脱壳。我们跑一下脚本，把它的地址导出来。可以使用`IDC`脚本，打开一个文件，以二进制写入方式打开，指定开始地址和文件长度，进行导出。

那么它的长度怎么算？这是一个`dex`文件，起始地址是这个地方。它的长度到底是多少？我们前几节课学到的`dex`文件知识能派上用场。查看它的`dex header`里面有一个`fileSize`，这个`fileSize`就表明了整个`dex`文件原本的长度。这个长度存放在偏移为`0x20`的地方，对应着这样一个`DWORD`数据，存放着原始的文件大小。

跑一下脚本，把数据导出来，存放到一个目录下。打开查看，理论上这就是原始的脱壳数据了。用`010 Editor`打开，能正常加载。随便找一个类，例如`MainActivity`，发现所有类已经还原出来了，但里面的每一个函数都是`native`方法，进行`postDelayed`一个`Runnable`。这是为什么？

那是因为虽然主体的`dex`文件解码了，但里面函数中的真实代码还没有被解压出来。这个道理和我们上一节课中提到的`DVM`字节码自修改的原理是一样的。它就是在程序执行环节以后，再对这些原始代码进行还原。下面就应该有一个还原的代码。

## 代码还原与内存Patch

![](img/2576e293366fab7c5f234ba3650cce49_98.png)

首先它已经把一个`dex`文件读取到一块内存中去了。慢慢跑下去，看它接下来怎么做。它会判断`API`版本，如果大于`10`，执行这一段代码；如果不是，执行另一段代码。如果是大于`10`，就调`dlopen`函数来获取`libdvm.so`模块的基址，接着读取这个`SO`文件中的导出函数，这就是获取函数地址的方法。`dvmDecodeIndirectRef`是一个函数，通过对函数列表进行遍历来获取到这个函数的地址。

![](img/2576e293366fab7c5f234ba3650cce49_100.png)

如果`API`版本小于`13`，会发现它调用另一个函数`dvmRawDexFileOpen`。这个函数我们应该比较熟悉，前几节课中已经讲到过，这是在内存中解析`DEX`文件的函数。那么理所当然的上面这个函数也是一样的，从内存中对原始`DVM`还原`dex`进行解析。

我们打开`Android`源代码查看一下。像这种脱壳的时候一定要多去看一下源代码，知道它的一些内存数据结构和它的一些方法是怎么作用的。搜索`dvmRawDexFileOpen`，查到方法名和描述。对应它的实现，是一个静态方法，`int dvmRawDexFileOpen(...)`，里面传递`dex`文件的基址地址。这个函数会从中取出参数，把它转换成一个`DvmDex`结构体并返回。

![](img/2576e293366fab7c5f234ba3650cce49_102.png)

这个函数的作用就是把内存中的`dex`文件转成这样一个结构体。具体的实现有兴趣可以跟一下。跟的方法很简单，`R3`的地址就是一个`open`函数，里面调`BLX`进行跳转。`R3`地址是一个奇数，跳转过去时可以实现指令集的切换（切换到Thumb模式）。真实的指令基址地址应该是`R3 & ~1`。

已经把原始代码分析出来，然后调用函数。这里就是一个`open`函数了，里面的一些参数、类型，喜欢的话可以去跟踪。这里直接跳过。调用`dvmRawDexFileOpen`函数获取到对内存中的数据进行解析，解析完以后往下跑。

![](img/2576e293366fab7c5f234ba3650cce49_104.png)

![](img/2576e293366fab7c5f234ba3650cce49_106.png)

![](img/2576e293366fab7c5f234ba3650cce49_108.png)

取出一个值，这个值就是我们刚取出来的返回值，这是一个`DvmDex`结构体。这个结构体到底能够做什么？先不管，往下跑，看后面到底做了些什么。

![](img/2576e293366fab7c5f234ba3650cce49_110.png)

后面又打开另外一个文件，就是`jiagu_data`文件，然后使用这个文件对我们的原始`dex`文件进行`patch`操作，也就是对原始`dex`文件进行某种修复操作。很显然，这个修复操作就是遍历内存中的`dex`结构体，然后把一些`code`代码给还原过去。这就是一个还原代码的操作。

目前它怎么还原暂时不关心，我们只看这个函数过后，它对我们原始`dex`文件的代码产生了什么样的修改。看一下它的参数，第一个参数是我们`dex`文件的起始地址。注意这个`dex`文件的地址和我们刚才记录下来的地址不一样，因为这个地址是经过解析后的`DvmDex`结构体中的地址，这是被`Android`系统管理的一个地址。

第二个参数是文件长度。这个函数过后，就会对内存中的数据进行`patch`。我们来看一下`patch`过后的效果。单步步过，这里已经对我们的内存产生了修改。我们再次把这个内存数据导出来，看一下怎么回事。

其他不变，继续跑脚本导出。导出的数据放到另一个文件。对比一下，这里的这些数据，这些偏移地址的数据已经被补丁过了。本来是这个样子，就补丁成这个样子。这些偏移都经过修正了。既然是修正过，那么这里导出来的数据就应该是原始的数据了。

## 修正DEX文件并导出

![](img/2576e293366fab7c5f234ba3650cce49_112.png)

![](img/2576e293366fab7c5f234ba3650cce49_114.png)

用`010 Editor`打开，它报了一个错误，说这是一个无效`DEX`文件。为什么？既然这个`dex`文件还有问题，就在`010 Editor`中打开，跑一下模板看一下存在哪些问题。它报一个错误，主要关心`class_data`。可以看到这里的所有`class_data`都变成了一个错误标志符，表明发生了解析上的错误。

![](img/2576e293366fab7c5f234ba3650cce49_116.png)

`class_data_item`指向一个方法，查看它的`code`，本来应该指向方法实现代码的`DexCode`结构体。但是这里，它的指针偏移地址指向了一个地址，但这个地址已经超出了整个`dex`文件。证明我们当初导出的`dex`文件，已经不包括这个`code`的地址了。说明程序解码完以后，把它的代码放到了`dex`文件的后面。

这个时候处理也很简单，把它外面的数据也补进来就完事了。看一下那个地址在哪个地方。本来它有一个类似基址的地方，加上它的长度，可以发现它的`code`地址就存放在另一个段里面。也就是说真实的`DEX`文件应该是包含这两个段的数据的。所以我们要同时把这两个段都导出来。

![](img/2576e293366fab7c5f234ba3650cce49_118.png)

我们直接计算大小，另一个段的起始地址和结束地址，减去起始地址得到长度。这个才是`dex`文件的真实地址。跑一下脚本再导一次。导完以后，文件变大了。继续用`010 Editor`打开，已经能够正常解析了。打开一个类查看，可以看到里面的真实代码已经全部补上来了。

那么到这里为止，我们的脱壳已经成功了。这是一个脱壳基本步骤：在内存中找到它原始的`dex`文件代码，进行导出。

## 脱壳后续处理与总结

当然，如果就脱壳来说，到目前为止已经完事了。但我们有追求一点，来看一下它是怎么还原我们的代码的，就是这个`patch`函数，它怎么样对原始的`dex`代码进行还原。我们继续进行调试，重新来一遍，分析那个方法。

重新调试，又回到`parseDex`函数中。`patchDex`就是一个对内存中的`dex`数据进行修正的函数。往下走，看这个函数里面做了些什么。首先打开了我们的`jiagu_data`文件，向下跑把它`mmap`到内存中去。然后在这个循环中，就对原始数据进行补丁。

![](img/2576e293366fab7c5f234ba3650cce49_120.png)

![](img/2576e293366fab7c5f234ba3650cce49_122.png)

![](img/2576e293366fab7c5f234ba3650cce49_124.png)

这样的补丁实际上就和`DVM`字节码自修改是一样的。只是说这里有点不一样。我课程中讲的自修改是直接修改`Method`结构体的数据，这里就是一个`patch` `DexCode`的数据了。这就是一个修复。

我们来调试看一下。单步进入这个函数，这是一个`write`函数。看一下它的参数，第一个是`dex`文件的起始地址，第二个是它的偏移地址，第三个就是要写入的偏移数据。这就是一个`patch`函数。它也是一样，对于这类加壳解壳软件，内存中要还原`dex`数据时，肯定要定位到相关的位置，然后直接对内存页的数据进行读取和修改。

![](img/2576e293366fab7c5f234ba3650cce49_126.png)

![](img/2576e293366fab7c5f234ba3650cce49_128.png)

把这个修改搞完以后，就能够正常地把`dex`数据还原回去并加载起来了。这是对于在`Dalvik`中加密和加壳加固的通用方法，也是我在上一节课中提到的方法。这都是通用的，所以