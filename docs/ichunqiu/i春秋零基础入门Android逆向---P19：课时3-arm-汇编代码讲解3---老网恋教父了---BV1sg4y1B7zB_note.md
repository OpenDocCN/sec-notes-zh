![](img/9449045488383bb7539bbc5f64744cb1_1.png)

# i春秋零基础入门Android逆向 - P19：课时3 ARM汇编代码讲解3 🔍

![](img/9449045488383bb7539bbc5f64744cb1_3.png)

![](img/9449045488383bb7539bbc5f64744cb1_4.png)

在本节课中，我们将学习如何利用IDA Pro的F5反编译功能，对一个实际的Android应用进行静态分析，并逆向其注册验证算法。我们将通过一个来自腾讯安全竞赛的入门级APK作为案例，演示从Java层到Native层的完整分析流程。

---

## 概述

本节课的核心是掌握IDA Pro的F5插件功能。该插件能够将ARM汇编代码反编译为可读性更高的C/C++伪代码，极大地简化了逆向分析过程。我们将分析一个包含Native层验证逻辑的APK，理解其注册校验流程，并最终推导出注册算法。

---

## 加载目标APK与初步分析

首先，我们使用JD-GUI工具打开目标APK，查看其Java代码结构。

该应用的界面非常简单：包含一个用户名输入框、一个密码输入框和一个验证按钮。这是一个典型的CrackMe程序。

![](img/9449045488383bb7539bbc5f64744cb1_6.png)

![](img/9449045488383bb7539bbc5f64744cb1_7.png)

在MainActivity中，我们找到了按钮的点击事件监听器。其核心逻辑是：获取输入的用户名和密码，检查用户名长度（需在6到20个字符之间），然后调用一个Native函数进行校验。如果该函数返回1，则验证成功。

关键代码段如下：
```java
if(nativeCheckRegister(name, pass) == 1) {
    // 验证成功
}
```

这表明核心的验证逻辑位于Native层的 `libcheck.so` 库中。

---

## 分析Native层SO文件

接下来，我们使用IDA Pro加载 `libcheck.so` 文件。

在导出函数中，我们找到了对应的 `Java_com_example_MainActivity_checkRegister` 函数。这就是我们需要分析的目标。

### 使用F5反编译功能

在函数体任意位置按下 `F5` 键，IDA会将ARM汇编代码反编译为C/C++伪代码。这是本节课的核心技巧。

反编译出的伪代码结构清晰。我们可以看到，函数首先通过JNI接口将Java层传入的 `jstring` 类型参数转换为C语言中的 `char*` 字符串。

关键步骤伪代码示意：
```c
const char* name = (*env)->GetStringUTFChars(env, j_name, 0);
const char* pass = (*env)->GetStringUTFChars(env, j_pass, 0);
// ... 后续处理
```

转换完成后，程序调用了另一个核心校验函数，我们将其重命名为 `real_check`。我们的目标是让 `real_check` 函数返回1。

---

## 深入核心校验函数

双击进入 `real_check` 函数，再次使用 `F5` 反编译。

该函数逻辑较长，我们采用从结果反推的方法进行分析。我们发现，函数最终的返回值 `result` 被赋值的地方有几处，其中只有一处赋值 `result = 1` 代表成功，其余赋值 `result = 0` 均代表失败。

我们的目标就是让程序执行流能够走到 `result = 1` 的分支。

### 梳理校验流程

通过分析伪代码，我们将整个校验流程梳理如下：

1.  **长度检查**：用户名长度必须在6到20之间。
2.  **用户名变换**：对用户名字符串进行一轮运算，生成一个中间数组 `encrypted_name`。
    *   运算公式类似于：`encrypted_name[i] = name[i] * (i + 某个常数) % name_length`
3.  **密码解码**：对输入的密码字符串，调用两个函数进行处理，生成中间数组 `encrypted_pass`。分析发现，这两个函数共同实现了 **Base64解码** 功能。
    *   识别依据：存在一个典型的Base64编码表（字符顺序为A-Z, a-z, 0-9, +, /），并且解码逻辑是4个字符转换为3个字节。
4.  **最终计算与比对**：将 `encrypted_name` 和 `encrypted_pass` 进行一系列数学运算，得到5个最终值（命名为L0-L4和P0-P4）。校验通过的条件是满足一组线性方程。

方程组的简化形式如下：
```
P4 = L1 + L0
P? = ... (涉及L1, P4)
P3 = L? + L3
P0 = ... (涉及P3)
L4 + P1 - 3*P?*L2 <= 0
```

---

## 推导注册算法（Keygen）

![](img/9449045488383bb7539bbc5f64744cb1_9.png)

![](img/9449045488383bb7539bbc5f64744cb1_11.png)

![](img/9449045488383bb7539bbc5f64744cb1_12.png)

根据上述分析，我们可以逆向推导出注册算法（即Keygen）的步骤：

1.  **输入**：合法的用户名（长度6-20）。
2.  **生成 encrypted_name**：按照步骤2中的公式，根据用户名计算出 `encrypted_name` 数组。
3.  **计算 final_pass**：根据步骤4中的方程组，以 `encrypted_name`（即L0-L4）为已知量，解出 `encrypted_pass`（即P0-P4）的值。
4.  **生成注册码**：将计算得到的 `encrypted_pass` 字节数组，进行 **Base64编码**，得到的字符串就是该用户名对应的正确密码。

![](img/9449045488383bb7539bbc5f64744cb1_14.png)

![](img/9449045488383bb7539bbc5f64744cb1_16.png)

![](img/9449045488383bb7539bbc5f64744cb1_17.png)

注册机（Keygen）的核心代码逻辑如下：
```python
# 伪代码示意
def generate_key(username):
    encrypted_name = transform_username(username) # 步骤2
    final_pass = solve_equations(encrypted_name)  # 步骤3，解方程组
    registration_code = base64_encode(final_pass) # 步骤4，Base64编码
    return registration_code
```

![](img/9449045488383bb7539bbc5f64744cb1_19.png)

![](img/9449045488383bb7539bbc5f64744cb1_20.png)

---

## 总结

![](img/9449045488383bb7539bbc5f64744cb1_22.png)

本节课我们一起学习了以下内容：

![](img/9449045488383bb7539bbc5f64744cb1_24.png)

1.  **IDA F5插件的强大应用**：我们利用F5功能快速将ARM汇编反编译为伪代码，理解了Native层函数的整体逻辑。
2.  **完整的Android逆向流程**：从Java层定位到JNI调用，再到分析SO库文件，最后深入Native函数内部。
3.  **算法识别与逆向**：在逆向过程中，我们识别出了Base64编码/解码算法，并通过静态分析推导出一组线性校验方程。
4.  **注册机（Keygen）的构造**：基于对校验逻辑的完全理解，我们能够从用户名出发，反向计算出正确的注册码。

![](img/9449045488383bb7539bbc5f64744cb1_26.png)

![](img/9449045488383bb7539bbc5f64744cb1_28.png)

![](img/9449045488383bb7539bbc5f64744cb1_29.png)

**重要提示**：虽然F5插件极其强大，但它并非万能。在面对经过混淆、加壳或控制流平坦化等保护的代码时，F5可能失效或产生不准确的伪代码。因此，扎实的ARM汇编代码阅读能力仍然是逆向工程不可或缺的基础。

![](img/9449045488383bb7539bbc5f64744cb1_31.png)

![](img/9449045488383bb7539bbc5f64744cb1_32.png)

![](img/9449045488383bb7539bbc5f64744cb1_34.png)

---

![](img/9449045488383bb7539bbc5f64744cb1_36.png)

![](img/9449045488383bb7539bbc5f64744cb1_37.png)

![](img/9449045488383bb7539bbc5f64744cb1_39.png)

![](img/9449045488383bb7539bbc5f64744cb1_41.png)

## 课后练习

![](img/9449045488383bb7539bbc5f64744cb1_43.png)

![](img/9449045488383bb7539bbc5f64744cb1_44.png)

![](img/9449045488383bb7539bbc5f64744cb1_45.png)

![](img/9449045488383bb7539bbc5f64744cb1_46.png)

请尝试逆向分析另一款CTF竞赛中的APK文件（老师提供的练习材料）。该应用同样包含Native层验证逻辑。请使用本节课所学的方法，静态分析其SO文件，理解其注册算法，并编写出对应的注册机。

![](img/9449045488383bb7539bbc5f64744cb1_48.png)

![](img/9449045488383bb7539bbc5f64744cb1_50.png)

祝你练习顺利！