![](img/a8be00fd3c8eef507db70a06640ca653_1.png)

# 经典15年i春秋渗透测试系统化教程 - P38：课时2 远程命令执行-PHP命令执行 🚀

在本节课中，我们将要学习PHP中的远程命令执行漏洞。我们将从一段存在问题的代码入手，分析其原理，并探讨多种利用和绕过安全限制的方法，包括使用特殊符号、不同的PHP函数以及代码注入等。

---

![](img/a8be00fd3c8eef507db70a06640ca653_3.png)

![](img/a8be00fd3c8eef507db70a06640ca653_5.png)

## 代码调试与路径问题 🔧

![](img/a8be00fd3c8eef507db70a06640ca653_7.png)

上一节我们介绍了命令执行的基本概念，本节中我们来看看一个具体的代码示例。首先，我们遇到了一段代码，其路径配置存在问题，导致无法正常执行。

![](img/a8be00fd3c8eef507db70a06640ca653_9.png)

![](img/a8be00fd3c8eef507db70a06640ca653_11.png)

![](img/a8be00fd3c8eef507db70a06640ca653_1.png)

![](img/a8be00fd3c8eef507db70a06640ca653_13.png)

![](img/a8be00fd3c8eef507db70a06640ca653_15.png)

代码中的路径指向错误，例如将 `test.php` 错误地指向了不存在的 `DVWA` 目录。修正路径后，代码才能正常执行 `system` 函数。

**核心代码逻辑如下：**
```php
$dr = $_GET['dr'];
system($dr);
echo $dr;
```
这段代码从URL参数 `dr` 获取值，并通过 `system()` 函数执行。如果传入 `dr=ls`，则会执行 `ls` 命令并输出结果。

---

![](img/a8be00fd3c8eef507db70a06640ca653_17.png)

![](img/a8be00fd3c8eef507db70a06640ca653_19.png)

## 利用连接符绕过限制 ⛓️

![](img/a8be00fd3c8eef507db70a06640ca653_21.png)

按理说，上述代码是“安全”的，因为程序员意图是只允许执行 `ls` 命令。参数 `$dr` 被硬编码为 `ls`，似乎无法执行其他命令。

![](img/a8be00fd3c8eef507db70a06640ca653_23.png)

但是，攻击者可以利用PHP中的**连接符**来绕过这个限制。

在PHP中，符号 `|`（管道符）和 `||`（逻辑或）可以用于连接命令。
*   单个 `|` 会执行其后面的命令。
*   两个 `||` 则会先尝试执行前面的命令，无论成功与否，都会继续执行后面的命令。

**利用示例：**
假设原意图是执行 `ls`，但我们可以构造参数：
```
dr=ls||id
```
这样，`system()` 函数实际执行的命令就变成了 `ls || id`。在Linux系统中，这会先执行 `ls`，然后执行 `id` 命令，从而实现了命令注入。

![](img/a8be00fd3c8eef507db70a06640ca653_23.png)

这就是命令执行漏洞的核心：程序员忽略了特殊符号（如管道符 `|`、分号 `;`、与符号 `&` 等）可以连接并执行额外命令的可能性。

![](img/a8be00fd3c8eef507db70a06640ca653_25.png)

---

## 其他PHP命令执行函数 📚

![](img/a8be00fd3c8eef507db70a06640ca653_27.png)

![](img/a8be00fd3c8eef507db70a06640ca653_28.png)

除了 `system()`，PHP还提供了多个可以执行系统命令的函数，了解它们对于渗透测试和漏洞防范都至关重要。

以下是常见的PHP命令执行函数：

1.  **`exec()` 函数**
    *   **功能**：执行一个外部程序。
    *   **原型**：`string exec ( string $command [, array &$output [, int &$return_var ]] )`
    *   **说明**：`$command` 是要执行的命令，`$output` 存储输出，`$return_var` 是返回状态。

2.  **`passthru()` 函数**
    *   **功能**：执行外部程序并显示原始输出。
    *   **适用场景**：当命令输出是二进制数据（如图像）并需要直接返回给浏览器时使用。

3.  **`shell_exec()` 函数**
    *   **功能**：通过Shell执行命令，并将完整输出以字符串返回。
    *   **原型**：`string shell_exec ( string $cmd )`

4.  **反引号运算符**
    *   **功能**：与 `shell_exec()` 函数作用相同。
    *   **示例**：`` `ls -la` `` 会执行 `ls -la` 命令并返回结果。
    *   这种写法在绕过某些安全过滤规则（黑名单）时可能有用。

**代码示例（反引号运算符）：**
```php
$cmd = $_GET['cmd'];
echo `$cmd`;
```
访问 `?cmd=whoami` 即可执行 `whoami` 命令。这种简洁的代码常被用作“一句话木马”，在渗透测试中用于获取Webshell。

---

## `eval()` 函数与代码注入 💉

![](img/a8be00fd3c8eef507db70a06640ca653_30.png)

![](img/a8be00fd3c8eef507db70a06640ca653_32.png)

除了上述执行系统命令的函数，PHP中还有一种更危险的注入方式：**`eval()` 代码注入**。

`eval()` 函数会将传入的字符串参数当作PHP代码来执行。

![](img/a8be00fd3c8eef507db70a06640ca653_34.png)

![](img/a8be00fd3c8eef507db70a06640ca653_36.png)

**示例代码：**
```php
$cmd = $_GET['cmd'];
eval($cmd);
```
如果攻击者传入 `?cmd=phpinfo();`，服务器就会执行 `phpinfo()` 函数。如果传入的是一句话木马代码，攻击者就能完全控制服务器。

![](img/a8be00fd3c8eef507db70a06640ca653_38.png)

![](img/a8be00fd3c8eef507db70a06640ca653_40.png)

类似功能的函数还有 `assert()`、`create_function()` 等，它们都可能被用于代码注入攻击。

![](img/a8be00fd3c8eef507db70a06640ca653_42.png)

---

## 实战案例：DedeCMS漏洞分析 🎯

通过前面的学习，我们了解了命令注入的原理。现在，我们结合一个真实案例——DedeCMS 5.7 SP1版本的漏洞，来分析如何利用命令注入进行攻击。

在该版本的 `/plus/car.php` 文件中，存在一段有问题的代码，它直接使用了 `eval()` 函数处理未过滤的用户输入。

**漏洞利用思路：**
1.  找到存在漏洞的文件路径（例如 `/plus/car.php`）。
2.  通过POST方式向该文件提交构造好的恶意数据。
3.  数据中包含要执行的PHP代码，例如 `echo 'test';`。
4.  如果服务器返回了 `test`，说明漏洞存在，`eval()` 函数执行了我们提交的代码。

在此基础上，攻击者可以进一步提交写入Webshell的代码，从而完全控制网站服务器。互联网上已有公开的利用工具（EXP），可以自动化完成攻击。

---

## 安全绕过与防御思路 🛡️

![](img/a8be00fd3c8eef507db70a06640ca653_44.png)

![](img/a8be00fd3c8eef507db70a06640ca653_45.png)

许多服务器会配置安全软件（WAF）或修改PHP设置来禁用危险函数，例如在 `php.ini` 中配置：
```
disable_functions = system,exec,passthru,shell_exec,proc_open,...
```

![](img/a8be00fd3c8eef507db70a06640ca653_47.png)

![](img/a8be00fd3c8eef507db70a06640ca653_49.png)

但这并不能完全防御，因为：
1.  **函数未列全**：黑名单可能遗漏某些执行函数（如 `pcntl_exec`、`imap_open` 等）。
2.  **自定义代码**：攻击者可以上传自定义的PHP文件，使用未被禁用的函数或方法（如通过 `COM` 组件、`FFI` 扩展）来执行命令。
3.  **动态调用**：使用 `call_user_func()`、`array_map()` 等函数动态调用代码，或利用 `create_function()` 创建匿名函数来执行命令。

**根本的防御方法在于代码层：**
*   **严格过滤输入**：对用户输入进行白名单验证，只允许预期的字符。
*   **避免直接执行**：尽量避免使用 `eval()`、`assert()` 等函数。
*   **使用安全函数**：如果必须执行系统命令，应使用 `escapeshellarg()` 或 `escapeshellcmd()` 对参数进行转义。
*   **降低权限**：运行Web服务的用户权限应尽可能低，避免使用root权限。

---

## 总结 📝

本节课中我们一起学习了PHP远程命令执行漏洞。
1.  我们从一个简单的 `system()` 函数示例开始，理解了命令注入的基本原理。
2.  我们探讨了如何利用管道符 `|` 等特殊字符绕过简单的代码限制。
3.  我们列举了 `exec()`、`passthru()`、`shell_exec()` 和反引号运算符等多种执行命令的PHP函数。
4.  我们深入了解了更危险的 `eval()` 代码注入漏洞。
5.  通过分析DedeCMS的真实漏洞案例，我们将理论应用于实战。
6.  最后，我们讨论了常见的WAF绕过思路和从代码层面进行防御的最佳实践。

![](img/a8be00fd3c8eef507db70a06640ca653_51.png)

理解这些原理和方法，对于从事渗透测试和安全防御都至关重要。在后续课程中，我们将进一步分析DVWA等靶场中的命令执行漏洞及其修复方案。