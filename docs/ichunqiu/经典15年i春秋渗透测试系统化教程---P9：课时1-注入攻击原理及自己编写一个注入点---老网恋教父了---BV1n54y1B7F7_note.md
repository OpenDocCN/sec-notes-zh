# 经典15年i春秋渗透测试系统化教程 - P9：课时1 注入攻击原理及自己编写一个注入点 🔍

![](img/a992d2e6e86395588614d7755ac32e17_1.png)

![](img/a992d2e6e86395588614d7755ac32e17_3.png)

![](img/a992d2e6e86395588614d7755ac32e17_4.png)

![](img/a992d2e6e86395588614d7755ac32e17_6.png)

![](img/a992d2e6e86395588614d7755ac32e17_8.png)

![](img/a992d2e6e86395588614d7755ac32e17_10.png)

![](img/a992d2e6e86395588614d7755ac32e17_12.png)

![](img/a992d2e6e86395588614d7755ac32e17_14.png)

![](img/a992d2e6e86395588614d7755ac32e17_16.png)

![](img/a992d2e6e86395588614d7755ac32e17_18.png)

在本节课中，我们将要学习SQL注入攻击的基本原理，并通过分析一个简单的网页代码示例，理解注入漏洞是如何产生的，以及如何进行基础的防御。

![](img/a992d2e6e86395588614d7755ac32e17_20.png)

![](img/a992d2e6e86395588614d7755ac32e17_22.png)

## 概述 📖

![](img/a992d2e6e86395588614d7755ac32e17_24.png)

![](img/a992d2e6e86395588614d7755ac32e17_26.png)

![](img/a992d2e6e86395588614d7755ac32e17_28.png)

SQL注入是Web安全领域中最常见且危害极大的漏洞之一。本节课我们将从原理入手，分析其成因，并通过动手编写一个存在注入漏洞的页面和一个防御页面，来直观地理解整个过程。

![](img/a992d2e6e86395588614d7755ac32e17_30.png)

![](img/a992d2e6e86395588614d7755ac32e17_32.png)

## SQL注入的原理与危害 ⚠️

上一节我们介绍了课程概述，本节中我们来看看SQL注入的原理与它在现实世界中的危害。

![](img/a992d2e6e86395588614d7755ac32e17_34.png)

SQL注入攻击的根源在于程序命令和用户输入的数据之间没有做到泾渭分明。这使得攻击者有机会将程序命令“夹带”在用户输入的数据中，一并提交给Web程序执行，从而为所欲为。

![](img/a992d2e6e86395588614d7755ac32e17_36.png)

**核心原理公式**可以概括为：
`有漏洞的查询 = 静态查询语句 + 未过滤的用户输入`

![](img/a992d2e6e86395588614d7755ac32e17_38.png)

![](img/a992d2e6e86395588614d7755ac32e17_40.png)

![](img/a992d2e6e86395588614d7755ac32e17_42.png)

![](img/a992d2e6e86395588614d7755ac32e17_44.png)

注入攻击与数据库直接相关，与服务器平台（如Windows/Linux）或脚本语言（如PHP/ASP/JSP）无关。只要应用程序将未经验证的用户输入直接拼接进数据库查询语句，就可能产生注入漏洞。

![](img/a992d2e6e86395588614d7755ac32e17_45.png)

![](img/a992d2e6e86395588614d7755ac32e17_47.png)

![](img/a992d2e6e86395588614d7755ac32e17_48.png)

![](img/a992d2e6e86395588614d7755ac32e17_50.png)

![](img/a992d2e6e86395588614d7755ac32e17_52.png)

根据OWASP（开放Web应用程序安全项目）发布的报告，SQL注入长期位列Web安全十大漏洞的前列。在实际的漏洞提交平台（如乌云）上，大量的高危漏洞报告也属于SQL注入类型，这充分说明了其普遍性和危险性。

![](img/a992d2e6e86395588614d7755ac32e17_54.png)

![](img/a992d2e6e86395588614d7755ac32e17_56.png)

![](img/a992d2e6e86395588614d7755ac32e17_57.png)

## 注入攻击的实施条件 🎯

![](img/a992d2e6e86395588614d7755ac32e17_59.png)

![](img/a992d2e6e86395588614d7755ac32e17_61.png)

![](img/a992d2e6e86395588614d7755ac32e17_63.png)

理解了原理和危害后，本节中我们来看看成功实施一次SQL注入攻击，攻击者通常需要确认哪些条件。

![](img/a992d2e6e86395588614d7755ac32e17_65.png)

![](img/a992d2e6e86395588614d7755ac32e17_67.png)

![](img/a992d2e6e86395588614d7755ac32e17_69.png)

攻击者需要将恶意的SQL语句“混入”常规输入中。为了达成攻击，通常需要确定三件事：

以下是攻击前需要确认的三个关键信息：
1.  **确定Web应用程序所使用的技术**：例如，通过查看网页后缀、报错信息或HTTP头，判断是PHP、ASP还是JSP程序。这有助于推测后端数据库类型（如MySQL、MSSQL），从而构造对应的注入语句。
2.  **确定参数输入方式**：参数是通过`GET`、`POST`还是`COOKIE`方式传递的。例如，URL中 `?id=1` 是GET方式；表单提交通常是POST方式。某些程序使用`$_REQUEST`来接收参数，它会同时接受GET、POST和COOKIE三种方式的数据，这可能绕过一些只防护了GET或POST的防御措施。
3.  **寻找可用于注入的用户输入点**：即找到那些与数据库交互的参数。例如，`news.php?id=1` 中的 `id` 参数，`login.php` 中的用户名和密码框等。静态页面（如 `.html`）或没有参数的页面通常无法直接注入（伪静态除外）。

## 手工检测SQL注入点 🛠️

在了解了攻击条件后，本节我们将学习如何手动检测一个URL是否存在SQL注入漏洞。

![](img/a992d2e6e86395588614d7755ac32e17_71.png)

![](img/a992d2e6e86395588614d7755ac32e17_73.png)

![](img/a992d2e6e86395588614d7755ac32e17_75.png)

![](img/a992d2e6e86395588614d7755ac32e17_77.png)

在进行手工注入前，建议调整浏览器设置以显示详细错误信息，这有助于判断。在IE浏览器中，需取消“Internet选项”->“高级”->“显示友好HTTP错误信息”的勾选。

![](img/a992d2e6e86395588614d7755ac32e17_79.png)

![](img/a992d2e6e86395588614d7755ac32e17_81.png)

![](img/a992d2e6e86395588614d7755ac32e17_83.png)

![](img/a992d2e6e86395588614d7755ac32e17_85.png)

![](img/a992d2e6e86395588614d7755ac32e17_87.png)

![](img/a992d2e6e86395588614d7755ac32e17_89.png)

以下是两种最基础的手工检测方法：
*   **单引号检测法**：在参数值后添加一个单引号 `‘`，例如将 `id=1` 改为 `id=1‘`。如果页面返回数据库错误信息（如MySQL语法错误），则此处**可能**存在注入点。
*   **逻辑值检测法**：利用 `and`（逻辑与）构造永真和永假条件进行判断。
    *   永真条件：`id=1 and 1=1`。页面应正常显示。
    *   永假条件：`id=1 and 1=2`。由于 `1=2` 为假，整个查询条件不成立，页面可能显示异常（如空白、内容缺失或错误）。
    *   如果“永真”和“永假”两种情况下页面返回内容**有明显差异**，则此处**极有可能**存在SQL注入漏洞。

![](img/a992d2e6e86395588614d7755ac32e17_91.png)

![](img/a992d2e6e86395588614d7755ac32e17_93.png)

![](img/a992d2e6e86395588614d7755ac32e17_95.png)

**检测原理代码示例**：
假设原查询语句为：
```sql
SELECT * FROM articles WHERE id = 用户输入的ID值
```
*   当用户输入 `1 and 1=1`，语句变为：
    ```sql
    SELECT * FROM articles WHERE id = 1 and 1=1
    ```
    条件成立，正常查询。
*   当用户输入 `1 and 1=2`，语句变为：
    ```sql
    SELECT * FROM articles WHERE id = 1 and 1=2
    ```
    条件恒假，查询不到结果，页面表现异常。

![](img/a992d2e6e86395588614d7755ac32e17_97.png)

![](img/a992d2e6e86395588614d7755ac32e17_99.png)

![](img/a992d2e6e86395588614d7755ac32e17_101.png)

![](img/a992d2e6e86395588614d7755ac32e17_103.png)

![](img/a992d2e6e86395588614d7755ac32e17_105.png)

## 代码实例分析：一个存在注入的页面 💻

![](img/a992d2e6e86395588614d7755ac32e17_106.png)

![](img/a992d2e6e86395588614d7755ac32e17_108.png)

![](img/a992d2e6e86395588614d7755ac32e17_110.png)

![](img/a992d2e6e86395588614d7755ac32e17_112.png)

![](img/a992d2e6e86395588614d7755ac32e17_114.png)

理论需要结合实践，本节中我们通过分析一段简单的PHP代码，来看注入漏洞在代码层面是如何出现的。

以下是一个存在SQL注入漏洞的PHP页面（`sqlin.php`）核心代码分析：

```php
<?php
// 1. 连接数据库
$conn = @mysql_connect("localhost", "root", "password");
if (!$conn) {
    die("数据库连接失败");
}
// 2. 选择数据库
mysql_select_db("sql", $conn);
// 3. 获取用户输入（未过滤！）
$id = $_GET[‘id‘];
// 4. 拼接SQL查询语句（危险！）
$sql = "SELECT * FROM users WHERE id=‘$id‘";
// 5. 执行查询
$result = mysql_query($sql, $conn);
// 6. 遍历输出结果
while($row = mysql_fetch_array($result)) {
    echo "用户ID: ".$row[‘id‘]."<br/>";
    echo "用户名: ".$row[‘username‘]."<br/>";
    echo "密码: ".$row[‘password‘]."<br/>";
    echo "邮箱: ".$row[‘email‘]."<br/>";
}
// 7. 关闭连接
mysql_close($conn);
?>
```

**漏洞关键点**：第3行和第4行。程序直接通过 `$_GET[‘id‘]` 获取用户输入，并将其**直接拼接**到SQL查询字符串中。如果用户输入 `1‘ or ‘1‘=‘1`，最终的查询语句将变为：
```sql
SELECT * FROM users WHERE id=‘1‘ or ‘1‘=‘1‘
```
这将导致查询出`users`表中的所有数据，造成信息泄露。

![](img/a992d2e6e86395588614d7755ac32e17_116.png)

![](img/a992d2e6e86395588614d7755ac32e17_117.png)

## 如何防御SQL注入 🛡️

![](img/a992d2e6e86395588614d7755ac32e17_119.png)

![](img/a992d2e6e86395588614d7755ac32e17_121.png)

![](img/a992d2e6e86395588614d7755ac32e17_123.png)

![](img/a992d2e6e86395588614d7755ac32e17_125.png)

分析了漏洞代码后，本节我们来看看如何修复它，实现一个安全的页面。

![](img/a992d2e6e86395588614d7755ac32e17_127.png)

![](img/a992d2e6e86395588614d7755ac32e17_129.png)

防御的核心思想是：**对用户输入进行严格的过滤和验证，或使用安全的数据库操作方式**。

![](img/a992d2e6e86395588614d7755ac32e17_131.png)

![](img/a992d2e6e86395588614d7755ac32e17_133.png)

以下是一个增加了基础防御的PHP页面（`safe.php`）代码：

![](img/a992d2e6e86395588614d7755ac32e17_134.png)

```php
<?php
// ... 数据库连接代码同上 ...
// 获取用户输入
$id = $_GET[‘id‘];
// 关键防御：检查输入是否为纯数字
if (!is_numeric($id)) {
    die("输入参数非法，防止SQL注入！");
}
// 经过检查后，$id被认为是安全的数字，进行查询
$sql = "SELECT * FROM users WHERE id=$id"; // 注意：因为$id是数字，去掉了周围的单引号
// ... 执行查询和输出代码同上 ...
?>
```

**防御原理**：使用 `is_numeric()` 函数判断 `$id` 是否为数字。如果用户输入包含单引号、SQL关键字等非数字字符，程序将直接终止并提示，从而阻止恶意SQL语句被拼接和执行。

这是一种“白名单”过滤思想，在明确参数应为数字时非常有效。更通用的高级防御方法包括：
*   **使用参数化查询（Prepared Statements）**：这是最推荐的方式，能从根本上分离代码与数据。
*   **使用特定的转义函数**：如 `mysql_real_escape_string()`（针对MySQL），对特殊字符进行转义。
*   **最小权限原则**：为数据库操作账户配置仅能满足需求的最小权限。

![](img/a992d2e6e86395588614d7755ac32e17_136.png)

![](img/a992d2e6e86395588614d7755ac32e17_138.png)

![](img/a992d2e6e86395588614d7755ac32e17_140.png)

![](img/a992d2e6e86395588614d7755ac32e17_142.png)

## 总结 🎓

![](img/a992d2e6e86395588614d7755ac32e17_143.png)

![](img/a992d2e6e86395588614d7755ac32e17_144.png)

![](img/a992d2e6e86395588614d7755ac32e17_146.png)

本节课中我们一起学习了SQL注入攻击的核心知识。我们首先了解了SQL注入的高危性和基本原理，即“用户输入被直接拼接为代码执行”。然后，我们探讨了实施注入所需的条件和手工检测漏洞的简单方法。

![](img/a992d2e6e86395588614d7755ac32e17_148.png)

![](img/a992d2e6e86395588614d7755ac32e17_150.png)

通过剖析一段存在漏洞的PHP代码，我们直观地看到了漏洞产生的代码级原因。最后，我们学习了如何通过输入验证（如`is_numeric()`函数）来实施最基础的防御，并提及了参数化查询等更安全的方案。

![](img/a992d2e6e86395588614d7755ac32e17_152.png)

![](img/a992d2e6e86395588614d7755ac32e17_154.png)

![](img/a992d2e6e86395588614d7755ac32e17_156.png)

![](img/a992d2e6e86395588614d7755ac32e17_158.png)

![](img/a992d2e6e86395588614d7755ac32e17_160.png)

理解这些基础概念是后续学习更复杂注入技巧、自动化工具利用以及高级防御手段的基石。