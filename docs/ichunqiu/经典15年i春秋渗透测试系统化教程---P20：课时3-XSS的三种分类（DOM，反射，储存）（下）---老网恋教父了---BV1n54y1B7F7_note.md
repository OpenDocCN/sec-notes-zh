![](img/f48ef4784097777bf8e1964e6a08957f_1.png)

![](img/f48ef4784097777bf8e1964e6a08957f_3.png)

# 经典15年i春秋渗透测试系统化教程 - P20：课时3 XSS的三种分类（DOM，反射，储存）（下）🔍

![](img/f48ef4784097777bf8e1964e6a08957f_5.png)

在本节课中，我们将深入学习XSS的第三种类型——DOM型XSS。我们将理解其独特的工作原理、与反射型和储存型XSS的区别，并掌握如何发现和测试这类漏洞。

![](img/f48ef4784097777bf8e1964e6a08957f_7.png)

![](img/f48ef4784097777bf8e1964e6a08957f_9.png)

---

![](img/f48ef4784097777bf8e1964e6a08957f_11.png)

![](img/f48ef4784097777bf8e1964e6a08957f_13.png)

![](img/f48ef4784097777bf8e1964e6a08957f_14.png)

上一节我们介绍了反射型和储存型XSS，本节中我们来看看DOM型XSS。DOM型XSS与前两种类型有本质区别，它不涉及服务端与浏览器的交互，而是发生在浏览器内部的两个层次之间。

![](img/f48ef4784097777bf8e1964e6a08957f_16.png)

![](img/f48ef4784097777bf8e1964e6a08957f_17.png)

![](img/f48ef4784097777bf8e1964e6a08957f_19.png)

DOM型XSS涉及的两个层次是**JavaScript层**和**HTML层**。更精确地说，是服务器脚本的输出变成了客户端脚本的输入。

![](img/f48ef4784097777bf8e1964e6a08957f_21.png)

许多现代框架都对常见的XSS攻击向量（如尖括号`<>`）进行了过滤和防御。然而，DOM型XSS由于其触发机制的特殊性，通常能绕过这些常规过滤。

![](img/f48ef4784097777bf8e1964e6a08957f_23.png)

![](img/f48ef4784097777bf8e1964e6a08957f_25.png)

以下是DOM型XSS的一个核心特征：
*   **触发位置**：漏洞发生在客户端的DOM解析过程中，而非服务端响应。

![](img/f48ef4784097777bf8e1964e6a08957f_27.png)

![](img/f48ef4784097777bf8e1964e6a08957f_28.png)

---

![](img/f48ef4784097777bf8e1964e6a08957f_30.png)

![](img/f48ef4784097777bf8e1964e6a08957f_32.png)

### 理解DOM型XSS的工作原理

![](img/f48ef4784097777bf8e1964e6a08957f_34.png)

为了理解DOM型XSS，我们可以分析一段典型的漏洞代码。查找DOM型XSS漏洞的方法通常是使用浏览器开发者工具（按F12键），并借助插件（如Firebug）进行调试。通过工具中的“选择元素”箭头，可以定位到网页中用户可控内容的位置，从而分析潜在的DOM型XSS点。

![](img/f48ef4784097777bf8e1964e6a08957f_36.png)

![](img/f48ef4784097777bf8e1964e6a08957f_38.png)

![](img/f48ef4784097777bf8e1964e6a08957f_39.png)

这里有一段示例代码，它演示了DOM型XSS的一个常见场景：

![](img/f48ef4784097777bf8e1964e6a08957f_41.png)

```javascript
var url = document.URL;
document.write(url.substring(url.indexOf("id=") + 3));
```

![](img/f48ef4784097777bf8e1964e6a08957f_43.png)

![](img/f48ef4784097777bf8e1964e6a08957f_45.png)

![](img/f48ef4784097777bf8e1964e6a08957f_47.png)

这段代码的含义是：
1.  第一行：使用 `document.URL` 获取当前页面的完整地址。
2.  第二行：从地址中查找“id=”参数，并截取其后部分，然后通过 `document.write()` 方法写入到页面中。

![](img/f48ef4784097777bf8e1964e6a08957f_49.png)

![](img/f48ef4784097777bf8e1964e6a08957f_51.png)

DOM型XSS通过DOM树操作，在JavaScript层执行恶意代码。它不像反射型XSS那样有明显的参数输入和输出，而是通过这种模式获取地址栏等位置的输入。

![](img/f48ef4784097777bf8e1964e6a08957f_53.png)

例如，攻击者可以在URL的`id`参数后输入恶意代码：
```
http://example.com/page.html?id=<script>alert('XSS')</script>
```
当上述示例代码执行时，就会将`<script>alert('XSS')</script>`写入页面，从而触发XSS。查看网页源代码时，可能看不到直接的恶意代码，因为它是通过JavaScript动态生成的。

![](img/f48ef4784097777bf8e1964e6a08957f_55.png)

![](img/f48ef4784097777bf8e1964e6a08957f_57.png)

---

![](img/f48ef4784097777bf8e1964e6a08957f_59.png)

![](img/f48ef4784097777bf8e1964e6a08957f_61.png)

### 如何挖掘DOM型XSS漏洞

![](img/f48ef4784097777bf8e1964e6a08957f_63.png)

![](img/f48ef4784097777bf8e1964e6a08957f_64.png)

![](img/f48ef4784097777bf8e1964e6a08957f_66.png)

DOM型XSS的隐蔽性较高，很多扫描器无法发现，需要手工挖掘。其基本思路是：先提交一个正常内容，然后在可能被JavaScript处理的地方替换为恶意代码进行调试。

![](img/f48ef4784097777bf8e1964e6a08957f_68.png)

![](img/f48ef4784097777bf8e1964e6a08957f_70.png)

![](img/f48ef4784097777bf8e1964e6a08957f_72.png)

以下是手工测试的步骤：
1.  使用浏览器开发者工具，点击“选择元素”箭头（或类似图标）。
2.  定位到你提交内容在页面中显示的位置。
3.  检查该位置对应的HTML元素，查看是否存在隐藏属性、自定义属性或可以被JavaScript操作的属性（如`innerHTML`、`document.write`的输入源、`location.hash`等）。
4.  在这些可能被客户端脚本处理的地方尝试插入Payload。

![](img/f48ef4784097777bf8e1964e6a08957f_74.png)

![](img/f48ef4784097777bf8e1964e6a08957f_76.png)

![](img/f48ef4784097777bf8e1964e6a08957f_78.png)

许多绕过技巧，例如对字符进行编码（如将`<`编码为`%3c`），常常被用于绕过简单的过滤。

![](img/f48ef4784097777bf8e1964e6a08957f_80.png)

![](img/f48ef4784097777bf8e1964e6a08957f_82.png)

---

![](img/f48ef4784097777bf8e1964e6a08957f_84.png)

![](img/f48ef4784097777bf8e1964e6a08957f_86.png)

![](img/f48ef4784097777bf8e1964e6a08957f_88.png)

### DOM型XSS实战测试

![](img/f48ef4784097777bf8e1964e6a08957f_90.png)

![](img/f48ef4784097777bf8e1964e6a08957f_91.png)

我们可以使用一些在线靶场或本地环境进行DOM型XSS的测试。测试时，可以尝试输入简单的Payload，例如：
```
<script>alert(document.domain)</script>
```
或者利用URL片段：
```
http://vuln-site.com/page.html#<img src=x onerror=alert(1)>
```
然后观察页面行为，并使用开发者工具查看动态生成的DOM结构，确认Payload是否被执行。

![](img/f48ef4784097777bf8e1964e6a08957f_93.png)

![](img/f48ef4784097777bf8e1964e6a08957f_94.png)

---

### 三种XSS类型总结

![](img/f48ef4784097777bf8e1964e6a08957f_96.png)

本节课我们一起学习了XSS的三种主要类型：
1.  **反射型XSS**：攻击者构造的恶意链接被用户点击后，服务器将恶意脚本“反射”回用户的浏览器执行。**过程是：用户输入 -> 服务器返回**。
2.  **储存型XSS**：攻击者将恶意脚本提交并保存到服务器数据库（如论坛发帖、评论），当其他用户浏览相关页面时，脚本被加载执行。**过程是：攻击者输入 -> 存入数据库 -> 其他用户访问时触发**。
3.  **DOM型XSS**：恶意Payload的触发完全在客户端完成，不经过服务器处理。JavaScript通过操作DOM（如`document.write`、`innerHTML`、`location.hash`）将用户输入的数据当作代码执行。**过程是：用户输入 -> 前端JS处理 -> 修改DOM并触发执行**。

DOM型XSS与反射型看似相似，但关键区别在于它没有明显的服务端参数回显，Payload的解析和执行依赖于前端JavaScript逻辑。挖掘DOM型XSS需要仔细分析前端代码的数据流。

![](img/f48ef4784097777bf8e1964e6a08957f_98.png)

![](img/f48ef4784097777bf8e1964e6a08957f_100.png)

---

![](img/f48ef4784097777bf8e1964e6a08957f_102.png)

![](img/f48ef4784097777bf8e1964e6a08957f_104.png)

下节课，我们将开始讲解利用工具来发现和利用XSS漏洞。