# i春秋学院 进阶篇 PHP代码审计 - P15：课程：越权操作 🔓

![](img/8764abf2443b7d12f4b0d411f8b4ea83_1.png)

在本节课中，我们将学习如何修复一个文件读取漏洞，并深入探讨越权操作（越权访问）这一常见安全问题。我们将通过分析代码、演示漏洞成因以及提供修复方案，来理解这些安全问题的本质。

---

## 争议文件读取漏洞的修复 🔧

![](img/8764abf2443b7d12f4b0d411f8b4ea83_3.png)

上一节我们介绍了文件读取漏洞的演示，本节中我们来看看如何修复它。该漏洞的出现是因为 `$fin` 变量未经任何过滤就直接拼接到了 SQL 语句中。

漏洞的核心在于以下代码：
```php
$sql = "SELECT * FROM `file` WHERE `filename`='{$fin}'";
```

![](img/8764abf2443b7d12f4b0d411f8b4ea83_5.png)

### 错误的修复思路

有些人可能会想到直接过滤整个 SQL 语句或相关函数，但这是行不通的。这会导致程序出现其他错误，例如影响 `tmp_name` 等变量的正常功能，最终导致文件上传失败。

![](img/8764abf2443b7d12f4b0d411f8b4ea83_7.png)

### 正确的修复方法

![](img/8764abf2443b7d12f4b0d411f8b4ea83_9.png)

我们需要有针对性地过滤出问题的变量，即即将代入 SQL 语句的那个变量。正确的做法是只对 `$fin` 变量进行转义处理。

![](img/8764abf2443b7d12f4b0d411f8b4ea83_11.png)

以下是修复后的关键代码：
```php
$fin = mysqli_real_escape_string($con, $_POST['filename']);
$sql = "SELECT * FROM `file` WHERE `filename`='{$fin}'";
```

经过这样修复后：
*   正常文件名可以成功上传。
*   包含单引号等特殊字符的恶意输入会被转义（例如 `'` 变为 `\'`），导致文件移动失败并报错，从而防止了漏洞利用。

![](img/8764abf2443b7d12f4b0d411f8b4ea83_13.png)

---

## 越权操作问题 👤➡️👥

接下来，我们探讨越权操作问题。这类问题通常源于开发者的疏忽，可能导致用户能够任意修改其他用户的信息，后果可能非常严重。

### 漏洞发现与分析

![](img/8764abf2443b7d12f4b0d411f8b4ea83_15.png)

我们在一个用户更新用户名的文件（例如 `update_name.php`）中发现了问题。

![](img/8764abf2443b7d12f4b0d411f8b4ea83_17.png)

![](img/8764abf2443b7d12f4b0d411f8b4ea83_19.png)

问题代码如下，它使用了用户可控的 `$_POST[‘id’]` 值：
```php
$clean_user_id = mysqli_real_escape_string($con, $_POST[‘id’]);
$sql = “UPDATE `users` SET `user_name` = ‘{$clean_user_name}’ WHERE `id` = ‘{$clean_user_id}’”;
```

这段代码没有验证当前传入的 `ID` 是否属于当前登录的用户。这意味着攻击者可以通过修改 POST 请求中的 `id` 参数，来更改数据库中任意用户的用户名。

![](img/8764abf2443b7d12f4b0d411f8b4ea83_21.png)

### 漏洞测试与现象

![](img/8764abf2443b7d12f4b0d411f8b4ea83_23.png)

通过构造一个 POST 请求，将 `id` 参数设置为其他用户的 ID（例如 13），并指定新的 `username`，可以成功更改该用户的数据库记录。

![](img/8764abf2443b7d12f4b0d411f8b4ea83_25.png)

但测试时会出现一个有趣的现象：提交后，当前登录用户的会话（`$_SESSION[‘user_name’]`）会立即变成我们修改的“新用户名”，而数据库里目标用户（ID 为 13）的用户名确实被更改了。这是因为代码在更新数据库后，将新的用户名直接赋给了当前会话变量。只需重新登录，当前用户的会话就会恢复正常，但这并不能掩盖越权修改的事实。

### 漏洞修复方案

修复方法很简单：不应该使用用户可控的 `$_POST[‘id’]`，而应该使用当前登录用户的会话 `ID`。

![](img/8764abf2443b7d12f4b0d411f8b4ea83_27.png)

观察其他功能（如更新头像）的代码，会发现它们正确使用了 `$_SESSION[‘user_id’]`。我们只需将问题代码中的 `$clean_user_id` 来源改为会话即可：

![](img/8764abf2443b7d12f4b0d411f8b4ea83_29.png)

```php
// $clean_user_id = mysqli_real_escape_string($con, $_POST[‘id’]); // 错误做法
$clean_user_id = $_SESSION[‘user_id’]; // 正确做法
$sql = “UPDATE `users` SET `user_name` = ‘{$clean_user_name}’ WHERE `id` = ‘{$clean_user_id}’”;
```

修复后，无论攻击者尝试修改哪个 `ID`，SQL 语句中的条件都会自动指向当前登录用户自身的 `ID`，从而彻底杜绝了越权修改。

---

![](img/8764abf2443b7d12f4b0d411f8b4ea83_31.png)

## 课程总结 📝

![](img/8764abf2443b7d12f4b0d411f8b4ea83_33.png)

本节课中我们一起学习了两个重要的安全议题：
1.  **文件读取漏洞的修复**：我们明确了不能盲目过滤，而应精准地对输入数据库的变量进行转义，例如使用 `mysqli_real_escape_string()` 函数。
2.  **越权操作漏洞**：我们分析了因直接使用用户可控参数（如 `$_POST[‘id’]`）作为数据库查询条件所导致的越权问题。修复的关键在于始终使用服务器端可信的来源（如 `$_SESSION[‘user_id’]`）来标识当前用户，从而确保用户只能操作属于自己的数据。

![](img/8764abf2443b7d12f4b0d411f8b4ea83_35.png)

理解这些漏洞的成因和修复方法，对于编写安全的代码至关重要。