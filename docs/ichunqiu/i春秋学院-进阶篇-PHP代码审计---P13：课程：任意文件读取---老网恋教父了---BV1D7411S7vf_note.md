# i春秋学院 进阶篇 PHP代码审计 - P13：任意文件读取漏洞审计 🔍

在本节课中，我们将学习任意文件读取漏洞的审计方法。我们将通过分析一个具体的代码案例，了解漏洞的成因、利用方式以及如何通过变量溯源来发现此类安全问题。

---

![](img/9fde8948d6d73e505dd295b43e5cefa6_1.png)

## 漏洞概述

![](img/9fde8948d6d73e505dd295b43e5cefa6_3.png)

任意文件读取漏洞属于文件操作漏洞的一种。攻击者利用此漏洞可以读取服务器上的任意文件，包括配置文件、系统重要文件等。在严重的情况下，甚至可能导致SSRF（服务器端请求伪造）漏洞，进而漫游内网。

## 核心原理

漏洞的核心在于能够读取文件的函数被不安全地使用。常见的函数如 `file_get_contents()`，如果其参数（通常是文件路径）可以被用户控制，就可能引发任意文件读取。

**关键函数示例：**
```php
$content = file_get_contents($user_controlled_path);
```

---

## 代码审计实战

上一节我们介绍了任意文件读取的基本概念，本节中我们来看看如何在一个具体的PHP应用中发现并利用此漏洞。

### 1. 定位文件读取点

在审计的代码中，发现用户头像的显示功能使用了 `file_get_contents` 函数。

![](img/9fde8948d73e505dd295b43e5cefa6_1.png)

该函数读取的内容来自用户会话（`$_SESSION`）中存储的头像路径。

### 2. 变量溯源

读取的路径来源于会话，那么会话中的这个值又是从哪里来的呢？我们需要进行全局搜索和溯源。

以下是溯源过程的关键步骤：

*   **来源一：登录时从数据库获取。**
*   **来源二：用户注册时，路径为默认值，不可修改。**
*   **来源三：用户上传头像时，路径会更新到数据库。**

审计发现，在上传功能的代码中，存在一个可疑的更新操作。文件名变量未经充分过滤就直接拼接到了SQL语句中。

### 3. 发现注入点

![](img/9fde8948d6d73e505dd295b43e5cefa6_5.png)

仔细查看上传功能的代码，发现用于更新数据库的 `$file` 变量是直接拼接进SQL语句的，没有经过过滤或转义。

![](img/9fde8948d6d73e505dd295b43e5cefa6_6.png)

```sql
UPDATE users SET avatar='$file' WHERE id='$id'
```

这构成了一个SQL注入点。攻击者可以通过注入修改数据库中存储的头像路径。

### 4. 利用技巧：UPDATE语句特性

为了利用这个注入点修改路径，我们需要了解MySQL `UPDATE` 语句的一个特性：`SET` 子句可以设置多个值，但最终生效的是最后一个值。

![](img/9fde8948d6d73e505dd295b43e5cefa6_8.png)

例如，执行以下语句：
```sql
UPDATE users SET avatar='1', avatar='2' WHERE username='test'
```
最终，`avatar` 字段的值会被设置为 `‘2’`。

![](img/9fde8948d6d73e505dd295b43e5cefa6_10.png)

利用这个特性，我们可以构造注入Payload，在闭合原有查询的同时，将路径设置为我们需要读取的文件。

### 5. 构造利用Payload

然而，上传功能还会检查文件名后缀是否为图片格式（如 `.jpg`, `.png`）。因此，我们的Payload需要满足两个条件：
1.  完成SQL注入，修改数据库路径。
2.  以图片后缀结尾，绕过文件类型检查。

同时，我们可能不知道当前用户的ID，因此可以利用用户名（`username`）作为查询条件。

一个初步的Payload构思如下：
```
test‘, avatar=0x2F6574632F7061737377642E70687023.jpg
```
其中，`0x2F6574632F7061737377642E706870` 是文件路径 `/etc/passwd` 的十六进制形式，`#` 用于注释掉后面的 `.jpg` 后缀。

![](img/9fde8948d6d73e505dd295b43e5cefa6_12.png)

### 6. 漏洞验证与利用

以下是验证漏洞的步骤：

![](img/9fde8948d6d73e505dd295b43e5cefa6_14.png)

1.  **拦截请求：** 使用代理工具拦截用户登录、上传头像和获取头像信息的HTTP请求。
2.  **修改上传请求：** 在上传请求的文件名字段中，插入我们构造的SQL注入Payload。
    ![](img/9fde8948d73e505dd295b43e5cefa6_8.png)
3.  **触发注入：** 发送修改后的上传请求。可以开启MySQL错误显示以确认注入是否成功。
    ![](img/9fde8948d73e505dd295b43e5cefa6_10.png)
4.  **重新登录：** 由于头像路径存储在会话中，需要让用户重新登录，从数据库获取新的（已被我们修改的）路径。
5.  **读取任意文件：** 访问获取头像信息的接口，此时 `file_get_contents` 函数将读取我们注入的路径（如 `/etc/passwd`），从而实现任意文件读取。
    ![](img/9fde8948d73e505dd295b43e5cefa6_12.png)
    ![](img/9fde8948d73e505dd295b43e5cefa6_14.png)
6.  **测试SSRF：** 将路径修改为 `http://www.baidu.com` 的十六进制形式，可以测试服务器是否能够对外发起网络请求，从而验证SSRF漏洞的存在。

---

## 总结与回顾

本节课中我们一起学习了任意文件读取漏洞的审计方法。我们通过一个案例，完整地实践了以下流程：

1.  **发现入口点：** 找到不安全的文件读取函数 `file_get_contents`。
2.  **变量溯源：** 追踪函数参数的来源，从会话（`$_SESSION`）追溯到数据库，再追溯到用户输入（上传的文件名）。
3.  **识别漏洞：** 在上传功能处发现未过滤的SQL注入点。
4.  **利用漏洞：** 利用SQL注入修改数据库记录，并结合 `UPDATE` 语句特性和十六进制编码绕过限制，最终实现任意文件读取和SSRF。

这种**变量溯源**的方法是代码审计中非常重要的思路，它帮助我们将一个看似微小的用户输入点，与一个严重的远程漏洞联系起来。

---

**本节课中我们一起学习了：**
*   任意文件读取漏洞的定义与危害。
*   如何定位不安全的文件操作函数。
*   如何进行变量溯源，追踪用户输入的影响路径。
*   如何利用SQL注入点结合数据库特性实现任意文件读取。
*   如何验证漏洞并拓展测试SSRF。

![](img/9fde8948d6d73e505dd295b43e5cefa6_16.png)

通过本课的学习，你应该对如何审计和利用任意文件读取漏洞有了更深入的理解。