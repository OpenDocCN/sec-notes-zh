# 经典15年i春秋渗透测试系统化教程 - P16：课时8 注入式攻击-Cookie手工注入（上） 🍪

在本节课中，我们将要学习一种特殊的SQL注入方式——Cookie注入。当网站的GET和POST参数都做了防注入过滤时，Cookie注入可能成为一个有效的绕过手段。我们将通过一个实际案例，演示如何发现并利用Cookie注入漏洞。

## 课程概述

上一节我们介绍了常规的GET和POST注入。本节中我们来看看当这两种方式都被防御时，如何利用Cookie参数进行注入攻击。我们将分析漏洞原理，并手工演示完整的利用过程。

## 数据接收方式回顾

在演示之前，我们先回顾一下ASP和PHP程序接收数据的几种常见方式。理解这些有助于我们判断注入点。

![](img/86318d3ae7a5990e1d901087e6970b8f_1.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_3.png)

以下是ASP和PHP中接收参数的几种方式：

*   **ASP中的 `Request`**：此方法会接收所有提交方式的数据，包括GET、POST和Cookie。
    *   代码示例：`id = Request("id")`
*   **ASP中的 `Request.QueryString`**：此方法仅接收GET方式提交的数据。
    *   代码示例：`id = Request.QueryString("id")`
*   **ASP中的 `Request.Form`**：此方法仅接收POST方式提交的数据。
    *   代码示例：`id = Request.Form("id")`
*   **ASP中的 `Request.Cookies`**：此方法仅接收Cookie方式提交的数据。
    *   代码示例：`id = Request.Cookies("id")`

![](img/86318d3ae7a5990e1d901087e6970b8f_5.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_7.png)

PHP中也有对应的`$_GET`、`$_POST`、`$_COOKIE`和`$_REQUEST`（类似ASP的Request）来接收不同来源的数据。

![](img/86318d3ae7a5990e1d901087e6970b8f_9.png)

## 目标站点分析

![](img/86318d3ae7a5990e1d901087e6970b8f_11.png)

下面我们来看一下目标站点。当我们尝试在URL（GET）或表单（POST）中进行注入测试时，防注入程序都会拦截。



![](img/86318d3ae7a5990e1d901087e6970b8f_13.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_15.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_1.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_17.png)

在URL中输入`id=1 and 1=1`，防注入程序弹出警告。



![](img/86318d3ae7a5990e1d901087e6970b8f_19.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_3.png)

使用Burp Suite等工具改为POST方式提交同样的参数，同样被拦截。



![](img/86318d3ae7a5990e1d901087e6970b8f_5.png)

这说明GET和POST方式都已被有效防御。我们需要寻找其他注入点。



![](img/86318d3ae7a5990e1d901087e6970b8f_7.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_21.png)

为了找到绕过方法，我们首先需要查看网站程序的源代码。



![](img/86318d3ae7a5990e1d901087e6970b8f_23.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_9.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_25.png)

## 源代码审计与漏洞发现

![](img/86318d3ae7a5990e1d901087e6970b8f_27.png)

首先，我们查看存在注入参数的文件（例如`news.asp`）是如何接收`id`参数的。



![](img/86318d3ae7a5990e1d901087e6970b8f_13.png)

关键代码为：`id = Request("id")`。这意味着程序使用`Request`对象接收数据，它会接收GET、POST和Cookie三种方式提交的参数。

我们之前测试了GET和POST都被拦截，那么Cookie方式呢？接着，我们查看其包含的防注入文件（例如`inc/checkSql.asp`）。



![](img/86318d3ae7a5990e1d901087e6970b8f_29.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_17.png)

在防注入文件中，我们发现了针对GET和POST的过滤函数。



![](img/86318d3ae7a5990e1d901087e6970b8f_19.png)

代码中明确定义了`CheckSql(get)`和`CheckSql(post)`来防御GET和POST注入，这正是我们之前被拦截的原因。



![](img/86318d3ae7a5990e1d901087e6970b8f_31.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_33.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_21.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_34.png)

但是，文件中**没有**定义`CheckSql(cookies)`来防御Cookie注入。然而，主程序文件却是通过`Request`接收数据的，这意味着它也会接收Cookie参数。这就产生了一个安全漏洞：**数据接收方（主程序）接受了Cookie，但数据检查方（防注入文件）却没有检查Cookie**。

## Cookie注入手工演示

手工演示Cookie注入，建议使用Burp Suite工具来拦截和修改请求。

1.  启动Burp Suite，配置浏览器代理。
2.  访问目标页面，Burp会抓取到HTTP请求包。
3.  将请求包发送到Repeater模块进行调试。

最初，注入参数`id=58`在URL（GET）中，我们添加单引号`‘`测试，请求被防注入程序拦截。



![](img/86318d3ae7a5990e1d901087e6970b8f_36.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_23.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_38.png)

现在，我们进行关键操作：**将注入参数从URL移动到Cookie中**。
*   在Repeater中，删除URL里的`id=58`。
*   在HTTP头部的Cookie字段里添加：`id=58`。



![](img/86318d3ae7a5990e1d901087e6970b8f_40.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_42.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_25.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_44.png)

再次发送包含单引号`‘`的请求（此时参数在Cookie里）。



![](img/86318d3ae7a5990e1d901087e6970b8f_46.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_27.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_48.png)

成功！防注入程序没有弹出，页面返回了数据库错误信息。这说明我们成功绕过了防御，并且该点存在SQL注入漏洞。

![](img/86318d3ae7a5990e1d901087e6970b8f_50.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_52.png)

我们可以通过对比HTTP响应包的长度来快速判断是否注入成功。正常请求（如`id=58`）的返回长度是固定的（例如16196字节）。当注入引发数据库错误时，返回长度通常会发生变化。

![](img/86318d3ae7a5990e1d901087e6970b8f_54.png)

## 注入利用过程

![](img/86318d3ae7a5990e1d901087e6970b8f_56.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_57.png)

现在我们已经确认存在Cookie注入点，接下来进行手工注入利用。

![](img/86318d3ae7a5990e1d901087e6970b8f_58.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_59.png)

1.  **判断字段数**：使用`order by`语句。
    *   在Cookie中构造：`id=58 order by 25`
    *   提交后页面报错（返回长度变化）。
    *   逐步减小数字测试，当`order by 20`时页面正常，说明当前查询的字段数为**20**。
2.  **联合查询探测显位**：使用`union select`语句。
    *   构造：`id=58 union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20 from admin`
    *   提交后页面正常，说明`admin`表存在，并且页面中会显示数字（如6,11,13,36），这些数字代表该位置可以回显查询结果。
3.  **获取管理员账号密码**：利用显位查询敏感信息。
    *   假设第6和第11位可显，构造：`id=58 union select 1,2,3,4,5,username,7,8,9,10,password,12,13,14,15,16,17,18,19,20 from admin`
    *   提交后，在页面回显位置（或查看响应包源码）即可看到管理员的用户名和MD5加密的密码。
4.  **解密并登录后台**：
    *   将获取的MD5密码值在CMD5等网站进行解密。
    *   使用解密后的用户名和密码尝试登录网站后台管理界面。



![](img/86318d3ae7a5990e1d901087e6970b8f_61.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_61.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_62.png)

至此，我们便利用Cookie注入漏洞成功获取了后台权限。

![](img/86318d3ae7a5990e1d901087e6970b8f_64.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_65.png)

## 漏洞修复建议

![](img/86318d3ae7a5990e1d901087e6970b8f_67.png)

本节课演示的漏洞根源在于防注入脚本不完整。修复方法非常简单：在防注入文件中增加对Cookie参数的检查。

![](img/86318d3ae7a5990e1d901087e6970b8f_69.png)

![](img/86318d3ae7a5990e1d901087e6970b8f_70.png)

以下是修复代码的思路：
在`checkSql.asp`文件中，添加对`Request.Cookies`的过滤，确保对所有用户输入来源进行统一的安全检查。

## 课程总结

![](img/86318d3ae7a5990e1d901087e6970b8f_72.png)

本节课中我们一起学习了Cookie手工注入的上半部分。我们了解到，当程序使用`Request`接收参数但只过滤了GET和POST时，可能会遗漏对Cookie的检查，从而形成注入漏洞。通过手工修改HTTP请求包，将参数移至Cookie中，即可绕过部分防御措施。我们还演示了从判断注入点到获取管理员凭证的完整流程。

![](img/86318d3ae7a5990e1d901087e6970b8f_74.png)

下节课，我们将继续深入Cookie注入的更多技巧和自动化工具使用。