# i春秋零基础入门Android逆向 - 课时10：Android DVM 脱壳3 🔍

![](img/a074413b930836132266df01fc81e417_1.png)

![](img/a074413b930836132266df01fc81e417_2.png)

在本节课中，我们将继续学习Android DVM脱壳技术，重点分析一个加壳程序如何定位并解密原始的DEX文件。我们将通过静态分析与动态调试相结合的方式，找到关键的脱壳点，并最终完成脱壳与APK修复。

![](img/a074413b930836132266df01fc81e417_4.png)

![](img/a074413b930836132266df01fc81e417_5.png)

---

![](img/a074413b930836132266df01fc81e417_6.png)

## 概述与回顾

![](img/a074413b930836132266df01fc81e417_8.png)

![](img/a074413b930836132266df01fc81e417_9.png)

上一节我们介绍了如何通过动态调试定位到加壳程序的关键函数。本节中，我们将深入分析这个函数，找到其解密和释放原始DEX文件的具体逻辑。

![](img/a074413b930836132266df01fc81e417_11.png)

![](img/a074413b930836132266df01fc81e417_12.png)

我们给IDA恢复到上一节课的调试状态。此时已经进入调试，并导出了一个内存映射（map）地址，且进行了一次重定位。

![](img/a074413b930836132266df01fc81e417_13.png)

![](img/a074413b930836132266df01fc81e417_15.png)

理论上，这样导出的map地址经过重定位后就能直接使用。因为整个Android程序每次加载时的基地址通常是相同的。但请注意，在某些设备上反馈可能不同。

我们需要找到函数对应的地址并进行重定位。

![](img/a074413b930836132266df01fc81e417_17.png)

## 定位关键函数

这里已经找到了 `JNI_OnLoad` 函数的地址。我们将其转换为函数，并按F5进行反编译。

直接转换出来的代码比较清晰。这里和之前一样，需要修改一些参数并加载头文件（header file）。

我们直接加载 `android.h` 头文件，但提示失败。这是因为最初加载时没有按照其loader的方式进行，许多默认属性没有设置。我们需要手动进行一些设置。

首先，需要设置编译器选项（Compiler options）。由于这个SO文件是使用GNU C++编译的，我们选择对应的编译器。

![](img/a074413b930836132266df01fc81e417_19.png)

接着，我们再次加载头文件，但提示一些本应有的数据没有被加载。这是因为其编译器特征库没有被正确加载。

![](img/a074413b930836132266df01fc81e417_21.png)

我们打开 `Load library` 视图，里面有两个库文件。插入 `gnu` 和 `gnu++` 的识别库。插入这两个库后，标准类型就能被识别了，此时也能正常加载头文件了。

![](img/a074413b930836132266df01fc81e417_23.png)

![](img/a074413b930836132266df01fc81e417_24.png)

加载完成后，就能像平时一样进行调试和分析。

## 分析JNI_OnLoad函数

我们继续分析 `JNI_OnLoad` 函数。

第一个参数是 `JNIEnv*`。第二个参数是一个 `jclass`。这里调用了 `JNIEnv` 的数据来获取一个 `JNIEnv` 结构体。

![](img/a074413b930836132266df01fc81e417_26.png)

可以看到，它开始对我们的Native函数进行注册。注册的信息存放在一个 `JNINativeMethod` 结构体数组中。我们修改其类型，它是一个长度为4的数组。

这样就把函数名、签名和函数地址分别存入了结构体。双击过去可以看到 `interface5` 和 `interface6` 等。我们可以记录下5和6的函数地址和签名，方便后续分析。

![](img/a074413b930836132266df01fc81e417_28.png)

回到 `JNI_OnLoad` 函数，我们继续分析。

接下来调用的一个函数是 `FindClass`，它用于寻找指定的类文件。因为要进行动态注册，就需要找到我们的 `Application` 入口类。

点击过去可以看到，它的第一个参数是 `JNIEnv*`，然后跳转到 `FindClass` 中来寻找我们的类。

找到类之后，就注册Native函数。写过JNI的都知道这个流程。

下面调用了一个不清楚用途的函数，我们双击进去查看。

第一个参数也是 `JNIEnv*`。这是一个清除异常的函数。清除异常后，进入下一个函数。

注意，下一个函数根据返回值是1或2，会跳转到不同的分支。我们进入这个函数进行进一步分析。

![](img/a074413b930836132266df01fc81e417_30.png)

## 判断运行模式与初始化

这个函数内部包含许多操作。我们可以根据字符串特征大致猜测其功能。

首先，它尝试加载一个 `Dex2Oat` 的SO文件，这可能是用来加载某些函数地址的。接着，看到有字符串判断是 `DVM` 还是 `ART` 模式，并根据模式返回1或2。

![](img/a074413b930836132266df01fc81e417_32.png)

很显然，这个函数是判断程序运行在ART模式还是DVM模式下，并进行某些初始化操作。

我们对其进行命名。如果是DVM模式，就执行某个函数；如果是ART模式，就执行另一个函数。如果都无法获取，则执行第三个函数，第三个函数是DVM模式下的一个函数。

![](img/a074413b930836132266df01fc81e417_34.png)

这两个函数内部具体做什么呢？大致看一下，这些地址很可能是用于解密的函数。实际上，这个函数就是根据加载模式对数据进行解密。解密完成后返回。

无论是DVM还是ART，这里实际上都是一个解密函数。下面则是一些结构体的初始化。

![](img/a074413b930836132266df01fc81e417_36.png)

前面的这些操作（资源释放或解密）并不最重要。我们最关心的是它在哪个地方将原始的DEX文件释放还原出来。我们需要找到这个点，并dump出原始数据。

## 定位脱壳点

在上一个函数返回的结构体中，下面进行了调用。如果调用返回-1，则SO文件加载失败；如果返回 `JNI_VERSION`，则加载成功。

从编程角度来说，这个函数非常重要。我们可以大胆猜想，这个函数就是用来释放DEX数据的地方。如果释放失败，就返回-1让程序崩溃；如果成功，则返回 `JNI_VERSION` 让程序继续运行。

因此，我们需要跟踪到这个函数，看它具体调用了哪里。这里是一个偏移地址的调用，我们找到它对应的地址并下断点。

断点命中后，准备跳转到目标函数。它仍处于 `.dex` 区段中，其地址末位是奇数。跳转过来后可以将其转换为代码模式。函数的起始地址就在这里，我们将其转成函数。

按F5进行反编译分析。第一个参数是传递过来的Dex指针，即一个 `jclass` 文件。

![](img/a074413b930836132266df01fc81e417_38.png)

我们假设这是一个解密函数。浏览反编译代码，首先从内存中定位到一个 `map` 文件。它找到这个文件做什么呢？继续往下看，有 `report` 和签名验证的迹象。如果验证失败，则记录错误信息并退出。

![](img/a074413b930836132266df01fc81e417_40.png)

这里有一个循环，很可能是在循环解密和释放资源。后面还有 `XOR` 操作。无论怎么看，这都很可能与DEX文件的释放有关。所以这个函数非常可疑，我们需要对其进行详细分析，必要时进行动态跟踪。

## 分析解密函数

![](img/a074413b930836132266df01fc81e417_42.png)

![](img/a074413b930836132266df01fc81e417_43.png)

首先，定义一个Dex指针。下面就是获取其内部函数地址。

![](img/a074413b930836132266df01fc81e417_44.png)

![](img/a074413b930836132266df01fc81e417_45.png)

我们遇到一个读取 `process` 内存数据的操作。点击过去，可以看到它读取内存中的 `map` 文件，并进行遍历和判断。里面有一个回调函数，找到文件后就调用这个回调函数做一些操作。

有过Android编程经验的都知道，这种内存中的 `map` 数据肯定指向自身加载的DEX起始地址。我们可以直接搜索验证。所以这里实际上就是定位到原始DEX的起始位置，并进行某些操作。

![](img/a074413b930836132266df01fc81e417_47.png)

360加固之所以这样做，是由其特殊性决定的。它加密后的DEX数据是直接存放在原DEX文件的扩展区域中的。

![](img/a074413b930836132266df01fc81e417_48.png)

我们可以查看原APK中的DEX文件，它特别大（500多KB）。而普通的DEX可能只有十几KB。既然有这么大，肯定包含冗余数据。我们跑一下脚本，查看有效数据结束的位置，后面的数据就是加密压缩后存放的原始DEX数据。

因此，360在解密时需要定位到原始DEX文件的基地址（即这块区域），并进行某种程度的解密。我们记录下这个位置，准备看它如何操作这块内存。

我们已经知道它开始定位内存地址了，并在这里进行关键操作。内部还有一些类的函数调用，可能需要跟踪才能看清。目前我们只需大致了解。

![](img/a074413b930836132266df01fc81e417_50.png)

大致浏览一下，这里有一些成功失败的判断。下面是一个 `while` 循环。这个 `while` 循环内的内容非常可疑。

![](img/a074413b930836132266df01fc81e417_52.png)

有一个调用 `AES` 的方法，可能是用AES进行解密。这可能是调用 `ART` 进行解密。这段 `while` 循环很可能与DEX文件解密相关。

![](img/a074413b930836132266df01fc81e417_54.png)

继续查找其他函数，例如这里初始化一个 `AES` 结构体。然后给某个变量赋值一个地址。这个地址是干什么的？我们可以跳过去查看。

![](img/a074413b930836132266df01fc81e417_56.png)

这些都可以大致浏览。有兴趣可以跟一下，这部分就是用于进行DEX文件释放的。

![](img/a074413b930836132266df01fc81e417_57.png)

最后一步是对DEX文件进行解码。接着判断其文件头，例如判断头四个字节是不是 `dex\n`。如果是，就证明解压成功，直接返回。下面的代码则进行函数表的替换等操作。

再下面可能是对某些类进行初始化。

通过静态分析，我们发现了几个可疑函数，特别是 `while` 循环部分，很可能与解密相关。并且在这里看到了DEX文件头的比较。我们记录下这些数据，准备进入 `while` 循环进行单步跟踪。

![](img/a074413b930836132266df01fc81e417_59.png)

## 动态跟踪解密过程

这是 `while` 循环的起始地址，我们在此处下断点，并进行单步调试。

我们关注寄存器窗口的变化，因为可能泄露关键信息。遇到可疑函数就跳转进去查看。

![](img/a074413b930836132266df01fc81e417_61.png)

例如，这里定位到 `0x75186000` 地址，这很可能就是APK中DEX文件的起始地址。上面已经进行了 `map` 数据的定位，下面将继续定位到压缩后的数据并进行操作。

![](img/a074413b930836132266df01fc81e417_63.png)

我们继续执行。这里定位到压缩后的加密数据区域。下面将进行相应的解密还原操作。

慢慢执行，注意内存变化。我们来到第一个 `while` 循环内部，但没有看到特别重要的信息，快速跳过。

到达下一个位置，对 `report` 字符串可能进行某些操作，但似乎不重要，继续执行。

因为这部分内容看不懂，直接跳过。继续执行，到达我们认为比较重要的地方，这里需要慢一点。

因为之前分析这部分可能与解码相关。注意 `R4`、`R5` 寄存器以及内存中泄露的数据，特别是函数调用时的参数。

例如这个函数可能是进行某种初始化。下一个函数调用就是 `AES` 相关的地方了。可能是获取AES函数或进行AES解密。

然后到达这个地方，这个地址在干什么目前还不知道。把这些可能有用的数据记录下来。

又是一个函数跳转，注意 `R0` 和 `R1` 寄存器。`R0` 是我们刚才赋值的地址，`R1` 是解密后数据存放的地址，长度是 `0x866C1`。这个长度大概就是除去加密头后的数据长度。这很像一个解密函数。

慢慢执行，查看其入参和出参。像这种样子的调用都需要留意。

下一个函数是 `memzero`，清零某段数据。继续执行。

又是一个跳转，内部数据还是这一块。我们看它用这块数据做什么，很可能用来进行加解密操作。

慢慢执行。注意，实际上到这里原始DEX数据已经出来了，只是我们还没看到。继续执行，就会看到函数将原始的DEX文件头还原回去。

熟悉DEX结构的话，会发现这段就是存放DEX数据的地方。这与DEX结构非常类似。这就是存放完整DEX文件的地方。

从这个函数开始，我们就可以进行脱壳，并将其dump出来。这里就是对DEX头四个字节进行判断的地方。

![](img/a074413b930836132266df01fc81e417_65.png)

## Dump原始DEX数据

我们查看这个地址的DEX数据，并运行dump脚本将其导出。

起始位置在这里。其长度在文件偏移 `0x20` 的地方，大小是 `0xEB91F8`。我们运行脚本将数据dump出来。

由于DEX文件较大，脚本需要运行一会儿。

![](img/a074413b930836132266df01fc81e417_67.png)

从对商业壳的分析来看，其加解密也是类似的原理。最关键的是耐心。只要有足够耐心，肯定能定位到解码段。因为程序要运行，必然存在解压解码的代码段。我相信只要有耐心，谁都能找到这个地方。其他壳也是类似的，只要找到脱壳点，就能把壳脱掉。

![](img/a074413b930836132266df01fc81e417_69.png)

额外说明一下，为什么这里是一个 `while` 循环？因为有些APK文件可能不只包含一个DEX文件，可能有多个。这里通过 `while` 循环将所有DEX文件解码出来。由于我们这个APK只有一个DEX数据，所以循环只执行一次。

![](img/a074413b930836132266df01fc81e417_71.png)

## 修复APK文件

![](img/a074413b930836132266df01fc81e417_73.png)

脚本运行完毕，我们已经将最原始的DEX数据全部dump出来了。这个DEX数据可以放回原始APK文件中完成修复。

![](img/a074413b930836132266df01fc81e417_75.png)

修复方法和DVM脱壳第一课中讲到的一样。既然得到了原始数据，我们就对其进行反编译，然后放回APK中。

![](img/a074413b930836132266df01fc81e417_76.png)

![](img/a074413b930836132266df01fc81e417_78.png)

使用 `baksmali` 和 `smali` 工具，加上 `-o` 参数指定输出路径，将dump出的所有数据还原回去。

![](img/a074413b930836132266df01fc81e417_80.png)

![](img/a074413b930836132266df01fc81e417_82.png)

找到 `smali` 路径，还原回去。然后进行替换。

![](img/a074413b930836132266df01fc81e417_84.png)

![](img/a074413b930836132266df01fc81e417_86.png)

接着，需要将其 `Application` 入口点移除。编译时可能会报错，因为除了 `application` 标签，可能还有其他标签导致反编译失败。检查 `AndroidManifest.xml`，移除相关标签后再编译。

这样一来就能成功编译，并可以安装运行了。程序能够正常跑起来。

这是一个手动脱壳的过程，需要较强的分析能力。最主要的是跟大家简单说明如何进行壳的分析。可以看到，整套流程操作下来，实际上可能没有想象中那么难。

![](img/a074413b930836132266df01fc81e417_88.png)

希望大家课后可以尝试自己找一些其他壳，或者再找一个360的壳，尝试进行脱壳练习。

![](img/a074413b930836132266df01fc81e417_90.png)

![](img/a074413b930836132266df01fc81e417_91.png)

---

## 总结

![](img/a074413b930836132266df01fc81e417_93.png)

![](img/a074413b930836132266df01fc81e417_95.png)

本节课我们一起学习了Android DVM脱壳的第三部分。我们通过静态分析与动态调试，深入追踪了一个加壳程序的解密流程，定位到了释放原始DEX文件的关键函数，并最终成功dump出解密后的DEX文件，完成了APK的修复。整个过程中，耐心和细致的分析是关键。