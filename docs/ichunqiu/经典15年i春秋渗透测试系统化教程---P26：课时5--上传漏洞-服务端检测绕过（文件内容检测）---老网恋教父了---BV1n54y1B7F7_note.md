![](img/40ce28f2f8175b588fe7033432512795_1.png)

![](img/40ce28f2f8175b588fe7033432512795_3.png)

# 经典15年i春秋渗透测试系统化教程 - P26：课时5 上传漏洞-服务端检测绕过（文件内容检测）🔍

![](img/40ce28f2f8175b588fe7033432512795_5.png)

在本节课中，我们将要学习如何绕过服务端对上传文件**内容**的检测。这是文件上传漏洞利用中较为深入的一层，主要针对服务器通过检查文件内部结构来判断文件类型的防御机制。

上一节我们介绍了客户端检测的绕过方法，本节中我们来看看服务端的文件内容检测。这种检测属于代码层，如果设置得非常严格，绕过会非常困难。但如果服务器安全配置存在疏漏，我们仍有成功的机会。

## 绕过文件内容检测的核心思路

![](img/40ce28f2f8175b588fe7033432512795_7.png)

![](img/40ce28f2f8175b588fe7033432512795_9.png)

![](img/40ce28f2f8175b588fe7033432512795_11.png)

服务端文件内容检测的核心是验证文件是否符合其声称的格式（如图片）。我们的绕过思路是：**将一个WebShell（如一句话木马）嵌入到一个真实的图片文件中，构造一个“图片马”**。这样，文件既能通过内容检测，又能在特定条件下被服务器解析为脚本执行。

![](img/40ce28f2f8175b588fe7033432512795_12.png)

![](img/40ce28f2f8175b588fe7033432512795_14.png)

以下是三种常见的服务端文件内容检测方式及对应的绕过方法。

![](img/40ce28f2f8175b588fe7033432512795_16.png)

![](img/40ce28f2f8175b588fe7033432512795_17.png)

### 1. 文件幻数检测绕过

文件幻数（Magic Number）是文件开头用于标识文件类型的特定字节序列。服务器通过检查这些字节来判断文件是否为允许的类型（如GIF、JPEG、PNG）。

绕过方法很简单：我们需要在WebShell代码的**最前面**，添加对应图片格式的文件头幻数。

*   **JPEG** 文件头：`FF D8 FF E0 00 10 4A 46 49 46 00 01`
*   **GIF** 文件头：`47 49 46 38 39 61` (GIF89a)
*   **PNG** 文件头：`89 50 4E 47 0D 0A 1A 0A`

**操作步骤**：
1.  找到一个正常的小图片。
2.  用十六进制编辑器（如WinHex、010 Editor）或记事本打开，复制文件开头的幻数字节。
3.  将复制的幻数粘贴到你的WebShell文件内容的最前面。
4.  将文件扩展名改为 `.php` 或 `.asp` 等脚本后缀进行上传。

### 2. 文件相关信息检测绕过

![](img/40ce28f2f8175b588fe7033432512795_19.png)

![](img/40ce28f2f8175b588fe7033432512795_21.png)

这种方法不仅检查文件头，还可能调用如 `getimagesize()` 这样的函数来获取图片尺寸等信息。单纯的幻数可能无法绕过。

![](img/40ce28f2f8175b588fe7033432512795_23.png)

![](img/40ce28f2f8175b588fe7033432512795_24.png)

**操作步骤**：
1.  首先，像方法一一样，在WebShell前添加正确的图片文件头。
2.  然后，在文件头之后、WebShell代码之前，可以添加一些图片格式允许的注释块或其他无关数据，进一步“迷惑”检测函数，使其确信这是一个完整的图片文件。
3.  最后插入WebShell代码。

![](img/40ce28f2f8175b588fe7033432512795_26.png)

![](img/40ce28f2f8175b588fe7033432512795_27.png)

![](img/40ce28f2f8175b588fe7033432512795_29.png)

### 3. 文件加载/渲染检测绕过（推荐使用工具）

![](img/40ce28f2f8175b588fe7033432512795_31.png)

![](img/40ce28f2f8175b588fe7033432512795_33.png)

这是最严格的检测方式。服务器可能会尝试真正地**加载**或**渲染**这个图片文件。如果文件结构在插入WebShell后被破坏，导致无法正常渲染，检测就会失败。

![](img/40ce28f2f8175b588fe7033432512795_35.png)

![](img/40ce28f2f8175b588fe7033432512795_36.png)

![](img/40ce28f2f8175b588fe7033432512795_38.png)

手动修改很容易破坏文件结构。因此，我们推荐使用专用工具，例如 **“中国菜刀”的图片马生成功能** 或类似工具（如 `edjpgcom`）。

![](img/40ce28f2f8175b588fe7033432512795_40.png)

这些工具的原理是：**在不破坏原图片文件结构的前提下，将WebShell代码插入到图片文件的注释区等空白区域**。这样既能通过渲染检测，又能保证WebShell代码存在。

![](img/40ce28f2f8175b588fe7033432512795_42.png)

![](img/40ce28f2f8175b588fe7033432512795_44.png)

**工具使用演示**：
1.  准备一个正常的图片文件（如 `test.jpg`）和一个一句话木马代码（如 `<?php @eval($_POST[‘cmd’]);?>`）。
2.  打开工具，将图片文件拖入。
3.  在工具中输入一句话木马代码。
4.  执行操作，工具会自动生成一个新的图片文件（如 `test_webshell.jpg`）。
5.  用记事本打开新文件，可以看到一句话木马被添加在文件末尾的注释区域。
6.  将生成的文件改名为 `shell.php` 进行上传测试。如果服务器存在解析漏洞（如Apache的 `test.jpg.php` 解析），可能直接连接成功。

![](img/40ce28f2f8175b588fe7033432512795_46.png)

## 关于二次渲染的说明

![](img/40ce28f2f8175b588fe7033432512795_48.png)

![](img/40ce28f2f8175b588fe7033432512795_50.png)

最极端的情况是服务器对上传的图片进行**二次渲染**（例如裁剪、缩放、重新压缩）。这会彻底重写图片文件，我们嵌入在注释区的WebShell代码会被清除。目前，针对二次渲染的可靠绕过方法非常稀少，实战中如果遇到，通常建议放弃此路径，寻找其他漏洞点。

![](img/40ce28f2f8175b588fe7033432512795_52.png)

![](img/40ce28f2f8175b588fe7033432512795_54.png)

## 课程总结

![](img/40ce28f2f8175b588fe7033432512795_56.png)

![](img/40ce28f2f8175b588fe7033432512795_58.png)

本节课我们一起学习了绕过服务端文件内容检测的几种方法：
1.  **文件幻数检测绕过**：在WebShell前添加图片格式的文件头。
2.  **文件信息检测绕过**：在添加文件头的基础上，补充图片数据以通过更严格的检查。
3.  **文件加载检测绕过**：使用专用工具将WebShell插入图片注释区，保证文件结构完整。

![](img/40ce28f2f8175b588fe7033432512795_60.png)

核心在于**构造一个既能通过图片内容验证，又包含可执行代码的混合文件**。同时，这些方法的成功与否高度依赖于目标服务器的具体检测逻辑和安全配置。下一节课，我们将进入应用层，探讨如何利用服务器的**解析漏洞**，让这些“图片马”最终被当作脚本执行。