![](img/a952810344cf13d815d5ad23ee3be8d4_1.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_2.png)

# i春秋零基础入门Android逆向 - P29：课时4 ELF文件变形与保护 🛡️

## 概述

![](img/a952810344cf13d815d5ad23ee3be8d4_4.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_5.png)

在本节课中，我们将学习ELF文件（特别是Android中的.so库文件）的变形与保护技术。我们将了解如何通过修改ELF文件的结构来阻碍静态分析工具（如IDA Pro）的分析，同时保证程序能够正常加载和执行。上一节我们详细介绍了ELF文件的结构，本节中我们来看看如何利用这些知识进行混淆和保护。

![](img/a952810344cf13d815d5ad23ee3be8d4_7.png)

## ELF文件混淆的基本原理

![](img/a952810344cf13d815d5ad23ee3be8d4_9.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_11.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_13.png)

ELF文件在存储时包含多个节（Section），但在加载执行时，链接器主要依据程序头（Program Header）和段（Segment）的信息。许多节数据（如`.text`、`.data`）实际上并不会被链接器用于加载。因此，我们可以向这些节中填充无用数据，或修改其元数据，来阻碍静态分析软件的分析。

![](img/a952810344cf13d815d5ad23ee3be8d4_15.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_16.png)

以下是混淆操作的核心思路：
*   **修改节头表（Section Header Table）**：清空或篡改节头中的偏移（`sh_offset`）、地址（`sh_addr`）和大小（`sh_size`）等信息。
*   **修改程序头表（Program Header Table）**：对动态节区（`.dynamic`）的标签（Tag）进行混淆。

![](img/a952810344cf13d815d5ad23ee3be8d4_18.png)

## 实验：对一个.so文件进行混淆

![](img/a952810344cf13d815d5ad23ee3be8d4_20.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_22.png)

我们以一个未加固的APK文件中的原生库（.so文件）作为测试目标。

![](img/a952810344cf13d815d5ad23ee3be8d4_23.png)

### 1. 原始文件分析

![](img/a952810344cf13d815d5ad23ee3be8d4_25.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_26.png)

首先，用IDA Pro打开原始的.so文件，观察其正常状态。

![](img/a952810344cf13d815d5ad23ee3be8d4_27.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_29.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_7.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_31.png)

可以看到，IDA能够正常识别出大量函数，右侧的节视图也显示了完整的节信息。

![](img/a952810344cf13d815d5ad23ee3be8d4_33.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_34.png)

### 2. 首次修改：清空节头数据

![](img/a952810344cf13d815d5ad23ee3be8d4_36.png)

我们首先尝试将节头表（Section Header Table）中的所有数据清空，验证程序是否仍能正常运行。

![](img/a952810344cf13d815d5ad23ee3be8d4_38.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_40.png)

以下是修改的核心步骤（通过脚本或十六进制编辑器实现）：
1.  定位ELF头中的`e_shoff`（节头表文件偏移）和`e_shentsize`（单个节头大小）字段。
2.  遍历节头表，将每个节头项的`sh_offset`（节在文件中的偏移）、`sh_addr`（节在内存中的虚拟地址）和`sh_size`（节大小）等关键字段置零。

![](img/a952810344cf13d815d5ad23ee3be8d4_42.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_43.png)

**关键代码/操作示意：**
```python
# 伪代码，示意将节头表关键字段清零
for section_header in elf.section_headers:
    section_header.sh_offset = 0
    section_header.sh_addr = 0
    section_header.sh_size = 0
```

![](img/a952810344cf13d815d5ad23ee3be8d4_45.png)

修改完成后，运行APK，程序依旧可以正常执行。再次用IDA打开修改后的.so文件：

![](img/a952810344cf13d815d5ad23ee3be8d4_47.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_22.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_49.png)

此时，IDA对代码的识别已出现大量异常，右侧节视图信息混乱，许多函数无法正常识别。但这只是一种简单的混淆。

![](img/a952810344cf13d815d5ad23ee3be8d4_51.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_53.png)

### 3. 进阶混淆：模仿360加固

![](img/a952810344cf13d815d5ad23ee3be8d4_55.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_57.png)

我们观察一个经过360加固的.so文件。其节头信息被做了如下处理：
*   节名被篡改。
*   节的偏移（`sh_offset`）和地址（`sh_addr`）被置零。
*   节的大小（`sh_size`）保持不变。
*   节的类型（`sh_type`）被修改为非法值。

![](img/a952810344cf13d815d5ad23ee3be8d4_59.png)

我们尝试模仿这种操作，对目标.so文件进行修改。

以下是操作步骤：
1.  找到节头表。
2.  修改特定节（如`.dynsym`、`.dynstr`、`.rel.plt`等）的`sh_offset`和`sh_addr`为0。
3.  有选择地修改某些节的`sh_type`属性。

![](img/a952810344cf13d815d5ad23ee3be8d4_61.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_63.png)

**修改后效果：**
![](img/a952810344cf13d815d5ad23ee3be8d4_59.png)

用IDA再次打开，可以看到左侧的函数窗口变为空白，右侧也无法识别出任何函数，所有内容都被识别为数据段。这达到了较强的混淆效果，其本质就是破坏了IDA赖以分析节信息的元数据。

![](img/a952810344cf13d815d5ad23ee3be8d4_65.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_67.png)

### 4. 其他混淆思路：动态节区混淆

![](img/a952810344cf13d815d5ad23ee3be8d4_69.png)

除了节头，程序头中的动态节区（`.dynamic`）也可以用于混淆。动态节区包含一个由标签（Tag）-值（Value）对组成的数组，链接器在加载时会遍历此数组。

![](img/a952810344cf13d815d5ad23ee3be8d4_70.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_72.png)

混淆方法是在合法的动态标签数组前，插入多个非法的或会导致溢出的标签-值对，只有最后一个标签才是有效数据。因为对于链接器而言，后出现的同类型标签会覆盖前面的值。

**核心逻辑：**
```
非法Tag1 -> 垃圾Value1
非法Tag2 -> 垃圾Value2
...
DT_NEEDED -> 合法库名 (最后一个有效Tag)
```
这样，静态分析工具在解析时可能因前面的非法数据而报错或解析失败，但链接器加载时能正确获取最后一个有效值。

![](img/a952810344cf13d815d5ad23ee3be8d4_74.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_76.png)

## 修复混淆的.so文件

![](img/a952810344cf13d815d5ad23ee3be8d4_78.png)

对于上述360加固类型的混淆（仅破坏节头），修复相对简单。因为程序执行不依赖节头信息。

![](img/a952810344cf13d815d5ad23ee3be8d4_80.png)

以下是简单的修复方法：
*   **方法一（推荐）**：直接将ELF头中指向节头表的偏移`e_shoff`和节头数量`e_shnum`置零。这相当于告诉分析工具“此文件没有节头表”。
*   **方法二**：手动或通过特征计算，恢复关键节（如`.text`， `.plt`）的正确文件偏移和虚拟地址，并填回节头表。

![](img/a952810344cf13d815d5ad23ee3be8d4_82.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_84.png)

使用方法一修复后，再用IDA打开：

![](img/a952810344cf13d815d5ad23ee3be8d4_88.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_86.png)

可以看到，大部分函数已被正常识别出来。虽然某些数据段的识别可能仍有误差，但已具备可分析性。

## 总结

![](img/a952810344cf13d815d5ad23ee3be8d4_88.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_89.png)

本节课中我们一起学习了ELF文件的变形与保护技术。
1.  **原理**：利用ELF文件中**节头信息（Section Header）非运行时必需**的特性，对其进行篡改或清除，从而干扰静态分析工具。
2.  **操作**：我们实践了清空节头、模仿360加固混淆（清零偏移/地址、修改类型）等方法，并验证了混淆后程序仍可正常运行。
3.  **修复**：对于此类混淆，最简单的修复方法是**将ELF头中的节头表偏移`e_shoff`置零**，使分析工具忽略损坏的节头信息，转而通过其他方式（如程序头）重建分析视图。
4.  **扩展**：更复杂的保护还会涉及对程序头、动态节区标签的混淆，但基本原理都是**增加非法或冗余数据来干扰分析器，同时保证链接器/加载器能按规则正确解析**。

![](img/a952810344cf13d815d5ad23ee3be8d4_91.png)

![](img/a952810344cf13d815d5ad23ee3be8d4_93.png)

理解这些基础的混淆与反混淆技术，是深入分析Android加固方案的重要一步。