# 课程 01：无需VPN？针对OPC UA协议的密码学攻击 🛡️🔓

![](img/332677915696b6d3ec75491beff1d7db_1.png)

![](img/332677915696b6d3ec75491beff1d7db_2.png)

![](img/332677915696b6d3ec75491beff1d7db_3.png)

![](img/332677915696b6d3ec75491beff1d7db_4.png)

![](img/332677915696b6d3ec75491beff1d7db_5.png)

在本节课中，我们将学习OPC UA协议的基础知识、其内置的安全特性，并深入探讨两种针对其加密机制的潜在攻击方法。我们将了解这些攻击的原理、实现方式以及防御措施。

---

## OPC UA协议概述

OPC UA是一种用于工业自动化的通用通信协议。它被广泛应用于各种行业和场景，用于实现工业控制系统、监控与数据采集系统、可编程逻辑控制器等设备间的通信。与许多该领域的其他协议不同，OPC UA不是专有协议，而是一个开放的标准协议，得到了多家供应商的支持，可以实现互操作性。它也不是基于半个世纪前的串行协议。

我个人发现它最有趣的一点是，它具备安全特性。得益于这些安全特性，如传输加密和身份验证，许多用户认为可以跨信任边界暴露此协议。这与许多其他操作技术协议不同，那些协议通常需要隔离在不同的网络段中。

特别是当你有像现场设备（例如，某个需要远程控制或监控的风力发电机）时，能够通过互联网建立连接会非常方便。由于OPC UA的安全和加密特性，它甚至被广泛用于各种无需建立VPN连接的场景，这被视为该协议的一大优势。

这促使我去研究这个加密协议的实际工作原理。

---

## 协议架构与加密层

OPC UA协议基于两个不同的层构建。

上一节我们介绍了OPC UA的基本概念，本节中我们来看看其核心架构。

**安全通道层** 负责建立传输加密以及客户端与服务器之间的设备身份验证。这通常用于自动化系统连接时。

**会话层（或应用层）** 负责用户身份验证和授权。这通常用于有人（例如使用人机界面）直接与系统交互的场景。你可以同时使用两种身份验证方法，也可以关闭加密，或者仅使用加密完整性保护而不进行实际加密。

![](img/332677915696b6d3ec75491beff1d7db_7.png)

![](img/332677915696b6d3ec75491beff1d7db_8.png)

![](img/332677915696b6d3ec75491beff1d7db_9.png)

当使用客户端证书进行身份验证时，信任模型通常基于证书。在许多实现中，当客户端首次连接到服务器时，连接会被拒绝，因为证书不受信任。然后，服务器端的管理员可以查看被拒绝的证书列表，并选择信任它们。这是一种相当实用的“首次使用即信任”解决方案。当然，也有基于公钥基础设施或完全预配置的不同设置。

![](img/332677915696b6d3ec75491beff1d7db_10.png)

![](img/332677915696b6d3ec75491beff1d7db_11.png)

![](img/332677915696b6d3ec75491beff1d7db_13.png)

---

## 安全通道握手流程

![](img/332677915696b6d3ec75491beff1d7db_15.png)

![](img/332677915696b6d3ec75491beff1d7db_16.png)

![](img/332677915696b6d3ec75491beff1d7db_17.png)

![](img/332677915696b6d3ec75491beff1d7db_18.png)

![](img/332677915696b6d3ec75491beff1d7db_19.png)

![](img/332677915696b6d3ec75491beff1d7db_20.png)

![](img/332677915696b6d3ec75491beff1d7db_21.png)

![](img/332677915696b6d3ec75491beff1d7db_22.png)

![](img/332677915696b6d3ec75491beff1d7db_23.png)

现在，让我们深入了解安全通道层的具体握手过程。

![](img/332677915696b6d3ec75491beff1d7db_25.png)

![](img/332677915696b6d3ec75491beff1d7db_26.png)

![](img/332677915696b6d3ec75491beff1d7db_27.png)

安全通道层以一个典型的加密握手开始。客户端预先知道服务器的证书（包含公钥）以及支持的加密套件。这些信息要么是预配置的，要么是通过发现协议获取的（这超出了本次讨论的范围）。

![](img/332677915696b6d3ec75491beff1d7db_29.png)

![](img/332677915696b6d3ec75491beff1d7db_30.png)

![](img/332677915696b6d3ec75491beff1d7db_32.png)

![](img/332677915696b6d3ec75491beff1d7db_33.png)

以下是握手步骤：
1.  客户端生成一个随机数，用自己的私钥签名，并用服务器的公钥加密。
2.  客户端将此消息发送给服务器。
3.  服务器也响应一个包含其自身随机数的签名和加密消息。
4.  双方将这两个随机数输入密钥派生函数，从而派生出用于后续通信的对称会话密钥。

![](img/332677915696b6d3ec75491beff1d7db_34.png)

![](img/332677915696b6d3ec75491beff1d7db_36.png)

![](img/332677915696b6d3ec75491beff1d7db_37.png)

![](img/332677915696b6d3ec75491beff1d7db_38.png)

该协议支持多种不同的“安全策略”，即在此过程中使用的底层密码套件集合。在实践中，目前实现最多的基本上都是RSA和AES的变体。

![](img/332677915696b6d3ec75491beff1d7db_39.png)

![](img/332677915696b6d3ec75491beff1d7db_41.png)

---

![](img/332677915696b6d3ec75491beff1d7db_43.png)

## 会话建立与身份验证

![](img/332677915696b6d3ec75491beff1d7db_44.png)

![](img/332677915696b6d3ec75491beff1d7db_45.png)

![](img/332677915696b6d3ec75491beff1d7db_46.png)

![](img/332677915696b6d3ec75491beff1d7db_47.png)

![](img/332677915696b6d3ec75491beff1d7db_48.png)

![](img/332677915696b6d3ec75491beff1d7db_49.png)

在完成第一个安全通道握手后，客户端和服务器将继续建立会话。即使不使用用户身份验证，每次连接也需要此步骤。

![](img/332677915696b6d3ec75491beff1d7db_51.png)

![](img/332677915696b6d3ec75491beff1d7db_52.png)

![](img/332677915696b6d3ec75491beff1d7db_53.png)

![](img/332677915696b6d3ec75491beff1d7db_54.png)

在此协议中，先前派生的密钥用于加密每条消息，并使用相当标准的AES-CBC和HMAC结构进行身份验证。

![](img/332677915696b6d3ec75491beff1d7db_56.png)

![](img/332677915696b6d3ec75491beff1d7db_57.png)

![](img/332677915696b6d3ec75491beff1d7db_59.png)

![](img/332677915696b6d3ec75491beff1d7db_60.png)

以下是会话建立步骤：
1.  客户端生成一个随机挑战值并发送给服务器。
2.  服务器通过签名此挑战来证明其身份，然后生成一个新的挑战要求客户端签名。
3.  客户端签名该挑战，身份验证完成。
4.  可选地，客户端还可以通过多种方式添加最终用户的身份验证信息。

如果所有这些都成功，双方就知道，使用此特定会话密钥的特定会话已经过身份验证。

![](img/332677915696b6d3ec75491beff1d7db_62.png)

![](img/332677915696b6d3ec75491beff1d7db_63.png)

![](img/332677915696b6d3ec75491beff1d7db_64.png)

![](img/332677915696b6d3ec75491beff1d7db_65.png)

从性能角度来看，值得注意的是，这两个步骤的组合并不是一个非常高效的协议，因为双方都需要执行三次昂贵的RSA解密或签名操作。而如果基于RSA进行相互身份验证和密钥交换，实际上只需要执行一次。当然，效率低下并不意味着协议不安全，拥有这些多层结构实际上可能使攻击变得更加困难。

---

## 发现协议设计缺陷

上一节我们介绍了会话建立的流程，本节中我们来看看其中存在的一个设计缺陷。

在协议的第二阶段（即会话握手）中，引起我注意的是客户端和服务器相互发送挑战的方式。它们通过获取该值，将其与对方站点的证书值连接，然后对其进行签名。但这种方法在两个方向上基本上完全相同。

它们没有包含任何上下文元数据来说明“这是一条从服务器发往客户端的消息”或“从客户端发往服务器的消息”。这有点问题，因为在OPC UA的许多用例中，一个系统可以同时充当客户端和服务器，并且它们通常使用完全相同的证书。因此，你可以使用相同的公钥来签署任一方向的消息，但这些消息的结构完全相同。

理论上，这开启了一种潜在的签名预言机攻击，你基本上可以交换这些类型的消息，并诱骗一个服务器签署它本不应该签署的内容。

---

## 攻击一：反射/中继攻击

基于上述缺陷，我构思的第一种理论攻击是中继攻击。

以下是攻击场景：
*   假设有两个相互信任的服务器：服务器A和服务器B。
*   攻击者连接到服务器A，并声称自己的身份是服务器B。它提供从服务器B发现的证书和一个挑战。
*   服务器A签署该挑战，然后提供自己的挑战要求攻击者签名。
*   攻击者无法自己签名（因为不知道私钥），于是建立到服务器B的连接。
*   攻击者将从服务器A获得的挑战复制过来，要求服务器B签署该挑战（此时攻击者假装是作为客户端的服务器A）。
*   服务器B提供签名值。
*   攻击者切断与服务器B的连接，将该值填入发送给服务器A的消息中，从而绕过身份验证步骤。

实际上，你甚至不需要两个服务器，因为在许多实现中，默认情况下服务器信任自己的证书。然后，你可以对同一个服务器执行基本相同的操作。攻击者尝试登录服务器A并假装是服务器A（这实际上是被允许的）。然后，他们建立到同一服务器的第二个连接，让它签署自己的挑战，切断第二个连接，继续第一个连接，从而绕过整个会话身份验证步骤。

![](img/332677915696b6d3ec75491beff1d7db_67.png)

![](img/332677915696b6d3ec75491beff1d7db_68.png)

![](img/332677915696b6d3ec75491beff1d7db_69.png)

![](img/332677915696b6d3ec75491beff1d7db_70.png)

![](img/332677915696b6d3ec75491beff1d7db_71.png)

![](img/332677915696b6d3ec75491beff1d7db_72.png)

![](img/332677915696b6d3ec75491beff1d7db_73.png)

---

![](img/332677915696b6d3ec75491beff1d7db_74.png)

![](img/332677915696b6d3ec75491beff1d7db_75.png)

![](img/332677915696b6d3ec75491beff1d7db_77.png)

![](img/332677915696b6d3ec75491beff1d7db_78.png)

## 攻击一的限制与绕过

![](img/332677915696b6d3ec75491beff1d7db_80.png)

![](img/332677915696b6d3ec75491beff1d7db_81.png)

![](img/332677915696b6d3ec75491beff1d7db_82.png)

但是，冗余的RSA操作在这里起到了作用。我们可能在技术上绕过了第二层的身份验证协议，但我们仍然有第一层——安全通道，我们需要用自己的私钥解密某些内容，并用私钥签署某些内容。而攻击者在这种情况下没有私钥，因此无法执行此操作，也就无法派生出正确的对称密钥，甚至无法生成可用于此协议的有效消息。

![](img/332677915696b6d3ec75491beff1d7db_83.png)

![](img/332677915696b6d3ec75491beff1d7db_84.png)

![](img/332677915696b6d3ec75491beff1d7db_85.png)

那么，我们如何绕过这一点呢？

事实证明，有一种相对简单的方法可以绕过它，那就是使用协议的变体。默认情况下，OPC UA是直接通过TCP使用的二进制协议。但有一个可选变体，通过服务器身份验证的HTTPS进行隧道传输。

因为HTTPS已经提供了传输加密，协议设计者认为可以跳过这个握手步骤，因为整个TLS层会处理它。然而，问题在于，这个握手步骤隐含地已经验证了客户端，因为客户端必须使用私钥进行操作。但当使用服务器身份验证的HTTPS时，服务器验证自身，但客户端不验证。

因此，当通过HTTPS使用OPC UA时，你完全依赖于这个会话层的身份验证。而这正是我们刚刚绕过的部分。我为这个协议变体实现了这个攻击，制作了一个工具，并且它完全奏效。你只需提供一个启用HTTPS的OPC服务器，该工具将通过执行反射攻击（或如果有两个服务器则执行中继攻击）立即绕过身份验证，服务器将泄露其所有秘密，基本上让你获得完全访问权限。

---

## 攻击二：利用脆弱的RSA填充方案

现在，如果仅仅因为实践中没有多少用户实际使用这个HTTPS协议变体，那么攻击的影响就相当有限。所以，更有趣的是攻击更常见的变体，即针对通过TCP的OPC UA。

我的方法是利用其中一个受支持的密码套件，该套件基于使用PKCS#1 v1.5填充方案的RSA。这个方案基本上在1998年就被Daniel Bleichenbacher明确攻破了。但由于某种原因，此后许多协议设计者没有注意到这一点，仍然继续使用这种特定的RSA填充方案。因此，看看我们是否能在OPC UA的背景下实际利用这些众所周知的漏洞可能是值得的。

唯一的问题是，这个方案（或至少使用此方案的密码套件）已被OPC基金会弃用，建议实现者仍然支持它，但默认将其关闭。那么，尝试攻击一个已弃用的功能有什么意义呢？首先，许多实现并没有真正遵循这个通知，仍然默认启用它。其次，可能有很多用户使用的是在此弃用之前设置的配置，而且可能没有多少供应商会发布破坏先前配置的补丁。因此，它们仍然会支持这个密码套件。此外，非常有趣的是，有些实现默认不提供此方法，但当它被显式禁用时，它们只会在已经尝试使用该协议解密消息后才检查它是否被禁用。所以，我尝试发送使用此脆弱方案加密的消息，服务器尝试解密它，然后决定：“哦，等等，我不应该使用这个，我要阻止连接。”但此时，它已经进行了解密，这已经为攻击创造了条件。同样有趣的是，即使你只有一个支持此协议的服务器，你也可以使用该攻击来针对其他可能从未使用过它、并且可能已将其关闭或使用更安全RSA填充方案的系统。

---

## Bleichenbacher攻击原理简介

上一节提到了利用脆弱的RSA填充，本节我们来简要了解其攻击原理。

Bleichenbacher对RSA加密的攻击，简而言之，RSA加密基本上就是对一个大整数进行模幂运算。RSA填充的全部意义在于将字节序列（你的消息）变成一个大整数。PKCS#1 v1.5方案的做法是添加一个`0x00`字节、一个`0x02`字节、一堆随机字节、一个`0x00`字节，然后是实际数据，以确保你得到一个非常大的数字，而不仅仅是像数字1这样的消息（如果对它进行幂运算，它会保持不变）。

服务器解密后，会检查这个填充并移除它以获得原始消息。如果你作为攻击者，能够看到服务器无法移除这个填充（服务器给出错误或某些指示填充失败的信息），这就会泄露一点关于你的密文所代表的消息的信息。因为如果填充失败，显然它不符合这种格式；如果它没有失败，它必须匹配这种格式，这意味着加密后的数字必须大于以`0x02`开头的数字，但小于以`0x03`开头的数字。

如果你有一个未知的、加密的RSA秘密值，你可以利用RSA的同态特性，基本上用已知值乘以密文，得到秘密值和你选择值的乘积结果。通过选择大量特定值，并观察每次结果是“有效”还是“无效”，每次填充有效时都会泄露一点信息。当你以巧妙的方式进行时，最终可以一点一点地解密整个消息，在大约一百万次查询后将其范围缩小，这就是为什么这种攻击有时也被称为“百万消息攻击”。

---

## 将攻击应用于OPC UA

那么，我们如何将其用于攻击OPC UA呢？我们需要绕过两个涉及RSA私钥的不同操作：对初始消息的签名，以及完成签名后，你仍然需要解密返回的消息以获取其中的随机数。

解密是直接的，但你也可以使用Bleichenbacher攻击来伪造签名，因为RSA签名基本上可以归结为对哈希值的RSA解密。你可以使用几乎相同的技术来伪造签名。

因此，你需要做的是：开始执行Bleichenbacher攻击，直到你在某个消息（包括你发送的某个随机数）上伪造了一个签名。发送此消息，得到一个加密的响应，然后再次执行攻击以解密该响应。

第一阶段，一旦你伪造了一个签名，你就可以重复使用该签名。所以你实际上只需要执行第一步一次。第二步有点棘手，因为在执行攻击时，你必须保持原始连接打开，因为一旦连接关闭，随机数就不再有效和有用。在实践中，你基本上只需在一个连接上不断发送TCP保活消息以保持其打开，然后使用不同的连接来执行Bleichenbacher攻击。

当然，要在实践中使其工作，你仍然需要一个填充预言机。你需要一种方法来区分有效填充和无效填充。对于某些实现，这非常容易，因为它们只是给出不同的错误消息。如果填充错误，你会看到某种错误代码或错误字符串；如果填充正确，则有所不同。然后你可以区分这两种情况，并基本上实现这种标准攻击，而不会遇到太多麻烦。

但不幸的是，我测试的大多数实现都显示完全相同的错误消息，无论填充检查失败还是填充通过但签名无效。因此，利用此攻击的另一种典型方法是利用基于时间的侧信道攻击，基本上尝试利用正确填充和不正确填充之间的时间差。

---

## 实施时间侧信道攻击

起初，这听起来非常困难且不切实际，至少需要确保没有太多网络抖动，进行大量额外测试，花费很长时间，并使用统计技术过滤误报。进行这样的时间攻击听起来非常困难。

但请记住，并非所有时间攻击都很难。如果你有包含`sleep`语句的传统SQL注入，那是一个非常容易的时间攻击，因为你可以影响时间差，使其变得非常大。在OPC UA协议中，你可以做类似的事情，因为它们进行RSA加密的方式有点奇怪。它有点像RSA运行在一种ECB模式下。如果消息太长，无法放入单个RSA块（在实践中总是如此，因为消息还包括相同大小的签名，所以通常是两个块的大小），它们只是拆分这些消息块并单独加密每个块。

这真的不是你应该使用RSA的方式。这是一种非常奇怪的结构，尽管它与在分组密码中使用ECB具有非常不同的属性，但你实际上可以将此机制与RSA一起使用来加密你的企鹅图片。然而，这确实会带来许多理论上的选择密文攻击。但我可以利用这个方案的什么属性呢？那就是，你可以获取Bleichenbacher攻击的一个猜测值，并将你用于攻击的密文重复100次。

然后，你将这条长消息发送给服务器。如果猜测的填充错误，服务器尝试解密第一条消息，看到填充错误，抛出异常，停止处理。但如果第一条消息的填充正确，它将进行解密第二个块（你重复的是同一个块，所以它也会正确），因此它将解密所有这100个块。RSA解密是一项非常昂贵的操作。只有在完成这100次解密后，它才会注意到消息是错误的，然后失败。这导致了相当大的时间差。你实际上可以稍微调整消息的长度，这在一定程度上取决于它们的消息限制。当然，如果你的消息更短，你可以更快地执行攻击。但在这个例子中，你可以看到，重复密文100次，时间差的数量级大约是几十秒。这是一个非常大的时间差。

为了利用这一点，我真的不需要任何花哨的统计方法，除了如果我看到某些东西花费的时间稍长，可能会重复几次以避免误报，但实际上计时真的非常容易。所以，我采用了标准的Bleichenbacher攻击，但不是查看错误消息之间的差异，而是进行一些相对简单的时间测量。如果处理时间短于某个阈值（实际上绝大多数情况都是如此，因为在Bleichenbacher攻击期间，绝大多数消息的填充都是无效的），那么我就认为填充无效。但如果处理时间明显长很多，我就认为填充有效，并将此结果返回给算法实现，说在这种情况下填充是正确的。

这听起来像是一个非常缓慢的攻击。但因为像99%你发送的消息实际上都是快速情况，只有那些相对罕见的、填充正确的情况才需要长时间，所以这个攻击实际上并不比使用错误预言机慢多少，这令人惊讶。

![](img/332677915696b6d3ec75491beff1d7db_87.png)

---

![](img/332677915696b6d3ec75491beff1d7db_88.png)

## 攻击工具与影响

我将所有这些集成到我的工具中，并添加了一个漂亮的小进度条，上面有一个旋转的条形图和不断增高的数字，你可以在工具工作时盯着它看。几秒钟后，数字慢慢上升，再上升一点。然后工具暂停了第一阶段，它已成功伪造了签名。所以它将此签名存储在一个文件中，这样如果第二阶段失败，你可以重复使用它。然后，它只是尝试发送带有伪造签名的消息，得到回复，保持连接打开，然后再次尝试执行攻击以解密从服务器接收回来的消息。

![](img/332677915696b6d3ec75491beff1d7db_90.png)

它成功了。我可以将其指向一个服务器，并再次绕过客户端身份验证步骤。在这个例子中，正如你从秒表上看到的，只花了15分钟。公平地说，这是一个相对较快的情况。这是一个用C语言编写的相当高效的实现，所以比其他实现快一些。我测试此攻击的其他实现可能需要大约30分钟，也许一小时，最坏情况是两小时。当然，这是在实验室设置中进行的，网络干扰不大，尽管我也尝试通过托管虚拟机来测试（仍在同一个国家）。总的来说，攻击实际上会奏效，有时只是比其他情况慢一点。对于攻击者来说，如果你的攻击需要15分钟到两小时，这其实没什么区别，只是意味着你需要在攻击期间喝杯咖啡或者出去吃个午饭。

从防御者的角度来看，我还发现，这种攻击发生在握手的第一个步骤，许多服务器实际上不会在此阶段记录任何加密失败。所以如果你去查看日志，情况并非总是如此，我有一个实现，但所有日志都充满了各种奇怪的错误，这可能会引起一些注意或填满日志。但在大多数情况下，攻击实际上是隐形的，你在另一端看不到任何相关信息。所以，如果你是攻击者，你可能不会介意为此花一点时间。

当然，这仍然取决于各个实现的特殊性。这些是协议缺陷，但它是否有效确实取决于一些细节和配置。

---

## 漏洞影响范围与披露

我测试了7种不同的OPC UA实现。其中两种完全不受影响，两种攻击都无效，但其余五种中有漏洞。在这五种中，有四种在其默认配置下容易受到其中一种或另一种攻击。因此，如果你使用启用客户端身份验证的默认安全配置，你将容易受到攻击。

所有这些都假设你的设置仅使用客户端-服务器证书身份验证机制。如果你有用户身份验证，如果你有密码，我的攻击将无法帮助你猜测密码。所以，如果你只使用密码身份验证，这些攻击不相关。但如果你使用基于证书的身份验证（对于自动化系统建立连接来说，这是一个合理的设置），那么这可能导致身份验证绕过。

我选择这7种实现是因为我可以在合理的时间内让实验室设置工作，并且它们不需要昂贵的硬件或软件许可证。但还有更多的实现。如果在这个样本中有5/7存在漏洞，你或许可以推断，许多其他实现也会容易受到同样的攻击。在披露之后，我看到来自多家供应商（特别是西门子的许多产品，如WinCC服务器）发布了针对这些漏洞的补丁通知，甚至给出了相对较高的CVSS分数。由此我推测，它们在常见配置中可能也存在漏洞。

我发现了一些协议缺陷。嗯，这有点取决于具体情况，这些协议缺陷在不同的实现中表现略有不同。当然，这听起来像是披露的噩梦，必须联系所有这些不同的供应商，而且还有我甚至没有测试过的其他供应商。但幸运的是，有OPC基金会，它负责管理标准。它的成员基本上涵盖了几乎所有协议实现者。所有这些供应商已经在这个基金会中聚集在一起。

他们实际上有一个非常好的系统，安全漏洞可以直接披露给基金会，而不必逐个联系像西门子这样的供应商。我向他们披露了漏洞。他们基本上在一小时内回复，并在同一天邀请我与OPC基金会成员会面。这是一个非常迅速的响应，与我习惯的情况有些不同。他们基本上完成了将所有漏洞协调给所有这些不同供应商的艰巨工作，让所有这些供应商首先就如何处理这些棘手的密钥问题达成一致，并在相对较短的时间内实施补丁，这真的令人印象深刻，我真的很佩服基金会所做的努力。

发布了一些CVE。可能有点令人困惑的是，一些供应商使用他们自己的