# Shade BIOSï¼š Unleashing the Full Stealth of UEFI Malware [t17YEHymwE4]

Helloï¼Œ my name is Kasuki Mato and this talk is about how to make UFMO less stealier and how to detect those stealth UFM overã€‚

ðŸ˜Šï¼ŒBrief introduction on myselfï¼Œ I am a researcher at FFR Securityã€‚

 which is a security vendor in Japanã€‚And my main research focus is on negative thingsã€‚

 especially EFI biosecurityã€‚And regarding G5 securityã€‚

 one thing I share a lot is that infecting bias is an overkillã€‚ I meanã€‚

 infecting internal layer is enoughã€‚And this is actually true for most casesã€‚

 for attackers aiming normal companiesï¼Œ but bio security is especially important in these two fieldsã€‚

The first is when the attack is related to the national securityï¼Œ and one of the reasons isã€‚

 of courseï¼Œ because these types of malware have to be as stealthy as possibleï¼Œ but other than thatã€‚

 this is because buys is a reasonable place to install backdoã€‚Unlike OS Hyvissis or CPUã€‚

 which a single company makes the most part of its componentï¼Œ B is implemented by many vendorsã€‚

 making it suitable to install backdoorsã€‚Alsoï¼Œ OSO hypervisors are not present during the manufacturing process anywayã€‚

 so putting it in the bias is the reasonable optionã€‚Moreoverã€‚

 if you look at leak documents such as Vo 7 or other documents from the Espion Know Agencyã€‚

 we can at least see that the UFI security is considered important in the context of national securityã€‚

Next is the cloud securityã€‚Bs has greater privilege than hypervisors in principleã€‚

 because it executes earlierã€‚So biased has the potential to compromise hyper devicesviss and affect every virtual machines on the cloud servicesã€‚

So Hyadvisors has strong rival believe with the Ba Mowareã€‚

 and you can see those in this existing researchã€‚And UFI threats are not just a theoryã€‚

 There are UFMOs in the wildã€‚There are about nine year fine boot kits existing in totalã€‚

 so the number is not that bigã€‚But thereforeï¼Œ what EF IO aware can do is also not much eluatedã€‚

One important characteristics these boot kitts have in common is that they ultimately perform malicious behaviors in usererland or colonelã€‚

So they are not pure about Mowareï¼Œ theyre just boot kitts that supports user lander kernel mobile behaviorã€‚

And we think this is a big challenge for the UFOA because this means that they are dependent to the OS double security after allã€‚

And I'll explain more about this in the next slideã€‚Other than boot kitsã€‚

 there are some leaked bus backdoors like JetT or vector EDKã€‚And some of them are pure by aspecã€‚

 meaning they perform malicsses activities only in the biastã€‚Howeverã€‚

 those backdo all share the same problem that they only support very specific targetsã€‚

Furureabout factors in the research fields are also the sameã€‚

 and these are all due to their device specific implementationã€‚So overallã€‚

 existing UFMO web suffers from OS dependence and hardware dependence or device dependenceã€‚

I'llplain more about this OS dependencyã€‚Existing UFI Bokit can disable any OSA security mechanismsã€‚

 and that is actually what they're doingã€‚So for exampleã€‚

 ES Specter Boot gets disabledables driver signature enforcementments and Cosmics strandand Boot gets Disables patchcardã€‚

Howeverï¼Œ there are still dependents to the Earth global security because they will be detected by antivirus's Konel's driver if they don't know what antivirus is running on the targetã€‚

Alsoï¼Œ they will be detected by other OS security mechanisms unless they disable all the OS security mechanismsã€‚

Moreoverï¼Œ existing bootkit utilizes a lot of pattern matching in hooks for the kernel image and bootload imageã€‚

 so the backdo have to be updated each time when the OS is updatedã€‚ðŸ˜Šï¼ŒThereforeã€‚

 existing UF boot kits still contain the risks of being detected by over level securityã€‚

But from the attacker's perspectiveï¼Œ the idea is do not care about theOS because we already took over the more previousous layer biasã€‚

But why does every existing Ufi Bogit uses the user Land kernel in the first placeã€‚

 why not implement everything in the bios codeï¼ŸðŸ˜Šï¼ŒThe key point of this matter is that the secrets or any data that attacker wants exists only after the OS has startedã€‚

 I meanï¼Œ nothing interesting exists during boot timeã€‚Howeverã€‚

 most of the bus environments are destroyed in one timeã€‚So for exampleã€‚

 EFI boot services such as allocate pagess are no longer available so the bioscar cannot use the memory managerã€‚

Alsoï¼Œ UFI protocols such as HTP protocols or disk IO protocols are all destroyedã€‚

 so there are no interfaces for accessing the deviceã€‚Thereforeã€‚

 from the biocode that's running after the OS has startedã€‚

 it is very difficult to communicate with the C2 server or read files and do so onã€‚ðŸ˜Šã€‚

And attackers can directly perform IOï¼Œ but this is hard because they essentially have to implement a full driver's taxã€‚

And alsoï¼Œ even if they manage to do thatï¼Œ the implementation will become very D specificã€‚

And thereforeï¼Œ it works only on the very specific deviceã€‚

And this is the reason why existing bus backs are all hardware dependent and supposed very specific targetã€‚

So for exampleï¼Œ if you look at the steady bound documentsã€‚

 it says it only works on Dell power and serviceã€‚And if you look at this I Che bootkitã€‚

 it only supports HP ion servers with specific versionsã€‚

The bonus factors in the registered fields are also the sameã€‚

There are a couple of SMM backdoors which is purely implemented within Bã€‚

 but if you look at those implementationï¼Œ it has to directly access the hardware registersã€‚ðŸ˜Šã€‚

And accessing the registers directly means that the attacker has to know what device the target has and find the specification for the device and readwrite those registers based on that specificationã€‚

Nowï¼Œ fortunatelyï¼Œ in this caseï¼Œ the device is USB host controller and USB has a standardized specificationã€‚

 so the dependency is not that strictã€‚But this doesn't work for other cables that doesn't use ESB or for other devices such as network interface cardsã€‚

So to summarize the point so farï¼Œ existing Bo MoA has this dilemma of hardware and OS dependencyã€‚

If the mobileware tries to perform everything within the codeã€‚

 then the implementation will become very device specific and will only work on the specific attack targetã€‚

ðŸ˜¡ï¼ŒAnd these are due to its lack of abstracted interfaces for accessing the deviceã€‚

And those interfaces exist in OS or user land in the runsoï¼Œ so Baltimoreware can use thisã€‚But thenã€‚

Thementation will becomeã€‚Dent to the OSã€‚And can be detectable by over double securityã€‚

So it is said that if attackers took over the biasï¼Œ they basically can do anythingã€‚

 but actually this dilemma is restricting what Bas Moa can doã€‚And moreoverã€‚

 platform security has been rapidly evolvingï¼Œ so we have to take them into considerationï¼Œ tooã€‚

Most of the existing Kobar Moware was implemented as SMM modulesï¼Œ system managementï¼Œ mode modulesã€‚

But these won't work anymore with the latest security mechanisms called SMM isolationã€‚ðŸ˜Šã€‚

SMM was referred as ring minus2 because it can access any physical memory or any IO during one time without interruptã€‚

So it has long been abusedã€‚But with this SMM isolation enabled taking Intel platform as an exampleã€‚

 all the non Intel SM modules are isolated by ring separation or p within SMM environmentsã€‚Thereforeã€‚

 if attackers built their own SMM back doors and once on the target PCï¼Œ it will run on SMM R 3ã€‚

And so when it tries to access to the OS memory regionã€‚

 since those pages are not mapped to the SMM page tableï¼Œ it will trigger a page forã€‚Alsoã€‚

 when it tries to access to the IOï¼Œ the security monitor running at SMM ring0 will check the policy and reject it if it doesn't match the policyã€‚

Thereforeï¼Œ existing SMM factors are no longer effective with this currenting trends of SMM and Dpririvileging unless they bypass this SMM isolationã€‚

And by the wayï¼Œ there are two types of UFA modules that can run during one timeã€‚

One is the previously mentioned SMM modulesï¼Œ and most of the existing research uses thisã€‚ðŸ˜Šï¼ŒHoweverã€‚

 there are one more types of UF modules that can run in runtimeã€‚

 and that is called runtime DX C modulesã€‚ðŸ˜Šï¼ŒThese modules are mapped to the high economical virtual azsã€‚

 just like the kernelel's driversã€‚And these functionalities are triggered when the OSs code calls the UFI runtime servicesã€‚

Nowï¼Œ comparing to the SMM modules with SMM isolation name name enabledã€‚

Runtime DxD modules can be seen as more privileged modules nowva date because it can access every OS memory and every IOã€‚

Howeverï¼Œ whichever the module isï¼Œ they also surface the dilemma of OSN hardware dependenceã€‚

So is that all you can do from biasï¼ŸðŸ˜Šï¼ŒFrom their Turkishku perspectiveã€‚

 we don't want to touch overs from them over because Os can detect the all behaviors by thatã€‚ðŸ˜¡ã€‚

But we want the OS functionalities such as memory management or device drivers during run timeã€‚ðŸ˜Šã€‚

And if there are no such functionalities like thatã€‚

 then the most straightforward idea is to implement the attacker exclusiveluible Westã€‚For the momentã€‚

But this is unrealistic because there are no OSs that can run in parallel with the other OSã€‚

 and moreoverï¼Œ it's troublesome and takes a lot of memoryã€‚After thinking for a whileã€‚

 we realized that UFI bioers can actually be seen as a small OS because it has its own memory management and device driversã€‚

And moreoverï¼Œ its sizes are smallï¼Œ so it doesn't waste memoryã€‚

So we came to an idea to retain vast memory even after the OS sps up and use itã€‚And thereforeã€‚

 we made shade bitesã€‚ðŸ˜¡ï¼ŒBy retaining bars in memoryã€‚

 it allows the biascode to use the UFI functionalities such as UFI boot servicesï¼Œ UFI protocolsã€‚

 or UFI driversï¼Œ even after the OSS startedã€‚ðŸ˜Šï¼ŒAnd by using shade barsã€‚

 attackers can achieve these three benefitsã€‚The first is they in implements Pur Bar Moã€‚

Shaade barss will disassociate UFMOA from the OS level securityã€‚And second isã€‚

 they can make them over device independenceï¼Œ meaning the attacker doesn't have to know what devices target is usingã€‚

And third is toã€‚They can make them allware easily because they don't need to implement the full drivers stacks or access IO directingã€‚

 rather they can use the interfaces of UFIã€‚ðŸ˜¡ï¼ŒSo in the next red and blue slidesã€‚

 I'll explain how the shade box worksã€‚ðŸ˜Šï¼ŒBut to pretty it shortã€‚

 it has these two major functionalitiesã€‚The first is to retain bus after OSputã€‚

 and the second is to make that retain code work properly in one timeã€‚ðŸ˜Šï¼ŒSo firstã€‚

 how to retain Bostonlast memoryã€‚Before explaining thisã€‚

 I would like to overview how UFI manages the memory mapã€‚ðŸ˜Šã€‚

The memory map is managed as a doubly linked list of memory map structureã€‚

And each structure has EFI memory type indicating what kind of data is stored in that memory regionã€‚

So for exampleï¼Œ this memory region from memory addresszures 0 x5000 to 0x6000 has the EFI memory type of EFI Bo services dataã€‚

So the data stored here are only available in boot time and can be discarded after it overspes upã€‚

And this memory map can be achieved by calling get memory Ma Bo serviceã€‚

 but we can only get the copy of the memory mapã€‚And this is mainly used by the OSloadsã€‚

 they call this gett memory map Bo service and determines where it can be used to place orã€‚ðŸ˜Šã€‚

So they recognize that EFI Bot Ci code and data are no longer necessaryã€‚

 so it will use these memory regionsã€‚But they will retain memory regions such as EFI run time services code or dataã€‚

So back to our objectiveï¼Œ in order to retain bars in memoryã€‚

 we can hook this S memory map Bo service and change EFI Bo services code and data to EFI runtime services code and dataã€‚

ðŸ˜Šï¼ŒThen the Oler will think these regions where EFI drivers or EFI particles are located cannot be destroyedã€‚

 and these status remains in memoryã€‚You may wonder if this takes too much memory regions away from the OSã€‚

But bias is such a small componentã€‚ So there aren't many E Iã€‚

Booth saves this code and data in memoryã€‚OS will instead use EFI load Chal data or EFI conventional memoryã€‚

 which most of the memory regions are in this typeã€‚So now we are able to retain bias in memoryã€‚

 but we cannot just execute the retained codeã€‚We need to deal with all these problems to let retain code work properly in one timeã€‚

ðŸ˜¡ï¼ŒWe'll go over all these five problems and solutions to it in the following slidesã€‚ðŸ˜Šã€‚

The first is the one time memory management problemã€‚

Memory allocator or Bers finds a new page from the EFI conventional memory from the Doub linked listã€‚

 which I mentioned earlierã€‚But the problem here is that it is the OS that's currently using the EFI conventional memoryã€‚

So B Allocator will allocate the new memory regions from the OS memory regionsã€‚

So as a solution for thisï¼Œ we can again hook the get memoryory map boost service and save some EFI conventional memory for bs to use in runtimeã€‚

ðŸ˜Šï¼ŒAnd I'll explain with this diagramã€‚There are lots of conventional memory inã€‚The memory mapã€‚

 so we will take some of the conventional memory from the yellow away from the OS by showing it as if I run time services dataã€‚

And rememberï¼Œ get memorym map returnss a copy of the memory mapã€‚

 so we aren't modifying the actual memory map hereã€‚ðŸ˜Šï¼ŒAnd in this wayã€‚

 yellow conventional memory will not be used by the OSs loaderã€‚

 but other conventional memory fonted pink are used by the OSã€‚Nextã€‚

 we want the buzz memory allocator to use only the yellow conventional memoryã€‚

 so we will unlink the pink conventional memory away from the actual memory mapã€‚ðŸ˜Šï¼ŒSo in this wayã€‚

 when Bas memory allocator searches for the free to use memoryã€‚ðŸ˜Šã€‚

Since only the yellow conventional memory which we saved is linkedã€‚

 Bas would never use the pink or memory regionsã€‚Oh sorryã€‚Next is memory virtualization problemã€‚

Retained modules think they are running on a physical addresszã€‚

 so they have global pointers that contain physical addresszuresã€‚

 or they even have hard coded physical azuresã€‚As since is difficult to adjust every of these references to the virtual addressã€‚

 the best way to deal with this is to change the paging to the ID mappingã€‚ðŸ˜Šã€‚

And I actually used partial I the mappingï¼Œ which I presented in my last year's blackout talkã€‚

 so I'll skip the details hereã€‚ðŸ˜Šï¼ŒThe third problem is to boot time only resourcesã€‚

Some of the member pointers of EFI system tables and EFI boot services are freed after overspookedã€‚

But the solution for this is really simpleã€‚ You just have to copy them during boot time and resolve it in the run timeã€‚

Nowï¼Œ another problem is UFfi variablesã€‚Newified variables are only accessible during one time if they have one time attributesã€‚

But the retained bias code will try to access non runtime GF variables because they think they're running on the booth timeã€‚

The solution for this is also straightforwardï¼Œ we just can hook the set variable boost at runtime service and create a copy for that variable with adding onetime match reviewsã€‚

ðŸ˜Šï¼ŒThe fourth problem is that the device settings are re initialitialized by the OS device driversã€‚ðŸ˜Šã€‚

And I would like to explain what this means by taking USB host controller as an exampleã€‚ðŸ˜Šã€‚

USB hostst controller has CRC register that holds the memory addressz on the command rankã€‚

And the device drivers will write to this command ring to let the hardware controller do somethingã€‚ðŸ˜Šã€‚

So when the driver initializes the controllerï¼Œ one thing the driver does is to prepare this commander and in memoryã€‚

And stores its addressures to the CRC registeredã€‚Now the problem isï¼Œ during boot timeã€‚

 you find drivers prepared their commandandering in memoryã€‚But after the OS has startedã€‚

 OS device drivers will prepare their own command ring and overwrite the CRC registers to point to their command ringã€‚

Howeverï¼Œ retain the UFI drivers thinks that the CR the register still points to their command ringã€‚

 so you cannot just use the retain to UFI particlesã€‚ðŸ˜Šã€‚

The solution for this problem is to re initial the slides from GFIs drivers and set these device registers to the appropriate value for the bs to use in runtimeã€‚

But remember that we don't want shadepas to contain device specific codeã€‚

 so we cannot just readwrite these registers directlyã€‚

So how can we re initialitialize the device without directly accessing the registersï¼Ÿ

The solution is to use disconnect controller Bo service and connect controller booth servicesã€‚

 taking advantage of the fact that yearF drivers follows the UF driver modelã€‚

So taking network interface Car as an exampleï¼Œ the hardware controller of Nick is abstracted into a specific controller handleã€‚

ðŸ˜Šï¼ŒAnd if you callï¼Œ connect controllert Bo service with this controller handle specifiedã€‚

Each start function in the driver binding particles in every GFI driversã€‚

Related to this controller handle is calledã€‚In this start functionã€‚

 it initializes the device by setting some registersã€‚And install the FBII protocolsã€‚Nowã€‚

 on the other handï¼Œ if you call this disconnect controller boost serviceã€‚

 every stop function is calledï¼Œ and all of these particles are uninstalled and the device is resetã€‚

So to hijack the device control from the OSã€‚ðŸ˜Šï¼ŒFirstã€‚

 we call disconnect controller boost service to reset the deviceã€‚

 meaning clear the registers of the hardwareã€‚ So this CRC register will not point to the OS command ringã€‚

And then we call Connect controllertroll Bo service to initialize the device for a biasersã€‚

So the CR theoryre will point to the biases command rateã€‚

So now the retained UFI drivers can access the device using UFI particlesã€‚

But after the mal behavior is doneï¼Œ we have to return the device control back to the OSã€‚ðŸ˜¡ã€‚

And this is pretty hard because we don't know where the OS command ring are or what values were set in the registersã€‚

 and we cannot just save the register value and restore it back because we don't want to contain the specific codeã€‚

Nowï¼Œ fortunatelyï¼Œ we realized that we don't need to return the device control back to yourOS explicitly because they sell a bitã€‚

ðŸ˜Šï¼ŒSo if shade filess use Nick and end its small behaviorã€‚

 there are several moments where internet connection is lostã€‚ðŸ˜Šã€‚

But it will recover in less than about three minutesã€‚ðŸ˜Šï¼ŒAnd this may not be an elegant solutionã€‚

 but since we have to make the code the device independentã€‚

 I think this is the best option and also we can say that this device control returning problem is the major challenge for ShaPaã€‚

The last problem is the exclusive controlã€‚Sadebus do a lots of harmful thingsã€‚

 such as changing the pageï¼Œ so we need to exclude the OS codeã€‚

And this means we need to disable introsã€‚And the most popular way to dis interrupt is to use CLI and SDI instructionsã€‚

But these are unreliable because there are already lots of CI and SDI instructions inside the retained B codeã€‚

And even if there is a single SDI instructions insideã€‚

 the interrupts will be enabled afterwards and overs TVã€‚So insteadã€‚

 we use CR A register or task priority registerã€‚Because UFI drivers rarely use thisã€‚

Now disabling interrupts were excludeded over codeï¼Œ but some wonderï¼Œ what about interrupt for biasï¼Ÿ

Nowï¼Œ convenientlyï¼Œ UFI B doesn't use interrupt except for timer interruptã€‚

U find drivers mainly use paingã€‚ðŸ˜¡ï¼ŒSo most of the UFI particles actually works without interruptsã€‚Nowã€‚

 timer interrupts are used for timer eventsï¼Œ so some of the G particles that use this will workã€‚

But we can manually signal each events and emulate interruptã€‚Thereforeã€‚

 we will not change the IDT of the OS and emulate timer interrupt insteadã€‚ðŸ˜¡ã€‚

Timeer events are managed as a doubly linked list of eye event structureã€‚And when you useã€‚

 for exampleï¼Œ request function of the HCTP protocolã€‚Some event structures are inserted to this listã€‚

And each I structure has trigger time numberï¼Œ and if the system time is greater than the trigger timeã€‚

The notify function of the event is executedã€‚And it is the timer interrupt handler that increments this system timeã€‚

Thereforeï¼Œ we can locate this linked list and triggers every event regardless of the trail timeã€‚ðŸ˜Šã€‚

And this is a pretty brutal wayï¼Œ but mostly events are already done by the time when return from the call functionã€‚

So this accidentally worthã€‚Okayï¼Œ so now the retained code should work properlyã€‚

You can take a look at this summer's class laterï¼Œ if you likeã€‚Nextã€‚

 I'll show how we become always independent by comparing existing bars more and the pure bars moreã€‚

Existing JFA Moa on the left performs malicsious's behaviors on user land or kernelelã€‚Soã€‚

 for exampleã€‚When they want to create a fileï¼Œ they will use this C fileile Windows API or NCreate fileile kernelnal APIã€‚

And the API will send a requests to the OS device driversï¼Œ and eventually it reaches the hardwareã€‚

Nowï¼Œ in this pastï¼Œ there are lots of risksï¼Œ risks of being detectedã€‚In the OSAPã€‚

 there is a logging function built inï¼Œ and between device driversã€‚

 there are filter drivers of anti productsï¼Œ for exampleã€‚And it is possible to disable theseã€‚

 but as I mentioned earlierï¼Œ it is hard to disable everything and the attack has to know what antiviruses are running on the target and what kernelel's driver does that antivirus useï¼Ÿ

ðŸ˜Šï¼ŒNowï¼Œ on the other handï¼Œ shade bars will use the retained UFI drivers instead of the OS device driversã€‚

So it is completely independent from OS detection and antiviruses detectionã€‚

How about device dependencyï¼ŸThe picture in the middle is the code for command and control communication using shade pathsã€‚

This code first calls Connect controllert Boo service to hijack the device control from the OSã€‚

And then uses HTP protocols to configure and make a request to the C2 serverã€‚And as you can seeã€‚

 there are no direct access to the IOï¼Œ no direct read writing registersã€‚

 it just uses the abstracted interfaces such as EFI Bo services or EFI protocolsã€‚Thatfulã€‚

 it works on a different machine with the same codeã€‚

I'm going to show you the demo of how shape path worksã€‚Okayã€‚

 left is the victim device infected with shade bias and right is C2 server this D on port 3033ã€‚

And I would like to use this kernel driverï¼Œ which will also connect to the C2 server regarding this as a kernel level code dropped from existing UF Bwareã€‚

And compare this with shade biasers if it gets detected by over level securityã€‚In this caseã€‚

 Mins defend their fireã€‚So firstï¼Œ I would like to execute this kernels driver normallyã€‚Okayã€‚

 and the C2 server received these messagesã€‚Now I'm going to try it againã€‚

But next time I will block this port 3ï¼Œ3ï¼Œ3ï¼Œ3ã€‚Using windowss to a fireableã€‚Okayã€‚

 and I'm going to load it againã€‚And execute it againã€‚And now this timeã€‚

 we didn't receive any messagesã€‚If we look at the Dbug messagesã€‚

 it's receiving empty status access toã€‚Okay so lastlyï¼Œ I will use shade biasã€‚

And I'm going to steal thisã€‚Processes dataã€‚But Im randomly impfeting nowã€‚Okayã€‚

 I'm going to trigger shade bias using this flying programã€‚

And shapebi doesn't need the client programï¼Œ but this is just for the demo to trigger it in the right timingã€‚

Can then now execute thisã€‚Heyï¼Œ I received the secret dataã€‚It matches this dataã€‚Okayã€‚

 so we can say that the OS double security doesn't affect shared biasã€‚ç¡®ã€‚Next isabel Liationã€‚

Shade bars actually requires one kernel featureï¼Œ and that is MM get Vi for physicals APIã€‚

And I'll skip the reasons because of the timeï¼Œ but this is not going to be the detection vector because even if the detection logic was built into the APIã€‚

 B can copy the whole function to the under place and disable the security logic and use that insteadã€‚

ðŸ˜Šï¼ŒAnd it is not aã€‚Large functionã€‚ So it is easy to do thatã€‚And alsoã€‚

 depending on what attackers want to achieveï¼Œ they have to use kernel or use the land featuresã€‚

Because for exampleï¼Œ if they want to read the process's memoryã€‚

 they need a page table of that processã€‚But since those page tables are managed by the OSã€‚

 they have to read some over structuresã€‚Howeverï¼Œ it is less likely that only reading the memory will trigger detectionã€‚

And the most suspicious part of the mobile behaviorã€‚

 such as sending that data to the command and control service or others are isolated by shade biasersã€‚

So lastlyï¼Œ how to detect shape pathsã€‚As I explained in the green slidesã€‚

 we cannot observe or block the low behaviors of shade busã€‚Howeverã€‚

 you can detect it by preventive inspectionã€‚Shaade bars is implemented by runtime Dexy driverã€‚

 and these are mapped to the kernel memoryï¼Œ so you can dump these modules and analyze the code statically to see if there is any suspicious codeã€‚

And there is an open source tool called craftrafttner made by Satohi Tnda that dumps runtime Dxy modules from memory so we can use thisã€‚

ðŸ˜Šï¼ŒAnother way to detect is to watch out for the side effects of shade pathã€‚

 such as the inaccessibility to the device until the OS device drivers selfã€‚ðŸ˜Šã€‚

Also shade bow is just one form of pure bow MoAï¼Œ so how can we protect ourselves from the potential pure bow moï¼Ÿ

If they were implemented as SMM modulesï¼Œ then just make use of SMM isolation because it is such as strong security featuresã€‚

And if they were implemented as runtime Dx C modulesï¼Œ then perform memory forensicsã€‚

 which I mentioned earlier because they reside in kernel memory after allã€‚

And this preventive inspection will be especially important for such systems acquired through government procurement to see if there is any factors insideã€‚

So here's the demo for detecting shade bowsã€‚This time I will use this on another device as a victim and this laptop as a CT serverã€‚

This device is also infected with the shade biasã€‚ So if I trigger the more behavior of the shade biasã€‚

The C2 server will receive the messageã€‚Now I'm going to detect this shade bias using an open source tool or craft dinnerã€‚

ðŸ˜Šï¼ŒSo I will install this moduleã€‚And executedã€‚Now what this tool does is it dumps one time taxi modules from the kernelal memoryã€‚

And those modules are these modulesã€‚Nowï¼Œ I hot coded this message from to the shape firesã€‚

 So I'm going to use strings command to see if it containsã€‚Shaade biasã€‚Okayã€‚

 so this is the shade bias moduleã€‚ And we can say that the craft dinner successfully dumped shade biassã€‚

ðŸ˜Šï¼ŒNow you can analyze these modules statically to see if it contains any suspicious behaviors as a preventive inspectionã€‚

This timeã€‚Finallyï¼Œ there are lots of future work for shade pausesã€‚

 and the implementation is far from perfectã€‚So if you're interested in this topicã€‚

 please do to the laterã€‚And finallyï¼Œ takeawaysã€‚Firstï¼Œ bias is said to be able to do everythingã€‚

 but there are actually some barriersã€‚There is a dilemma of OS and hardware dependenceã€‚And secondã€‚

 although there is this dilemmaï¼Œ it is possible to overcome this in achieve pure biomoerã€‚And thirdã€‚

 to prevent this pure about smallwareï¼Œ we need to utilize the latest security mechanisms such as SMMI Stã€‚

Andã€‚æŒ‰ç…§ã€‚Insspec the PC preventedlyã€‚Because the male behaviors are pure our smaller cannot not be observedã€‚

Here are some disclaimersã€‚And thank you for listeningã€‚

