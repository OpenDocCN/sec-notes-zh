# 课程 1: Azure 的最薄弱环节？API 连接如何泄露秘密 🔓

在本课程中，我们将学习 Azure 逻辑应用中的 API 连接如何成为安全漏洞的源头。我们将探讨一个由安全研究员发现的漏洞链，了解其原理、影响以及微软的修复方式。课程内容基于一次真实的安全研究，旨在帮助初学者理解云基础设施中可能存在的安全隐患。

## 概述

大家好，我是 Hocomb，一名在挪威一家二进制安全咨询公司工作的安全顾问和研究员。我们主要进行白盒应用渗透测试，这意味着我们在拥有客户源代码、用户权限、管理权限以及基础设施配置完全访问权的情况下测试其应用程序。

在一次客户测试中，我发现了一个 Azure 逻辑应用相关的漏洞。虽然该应用本身防护良好，但通过检查其 Azure 门户中的逻辑应用，我发现了 API 连接中潜藏的风险。

## API 连接的初步发现

上一节我们介绍了研究背景，本节中我们来看看 API 连接是什么。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_1.png)

通常，在逻辑应用中寻找漏洞时，我们会尝试寻找未掩码的密钥。逻辑应用本质上是一个响应特定输入（如 HTTP 请求）的 Web 应用。开发者有时会忘记掩码密钥，导致低权限用户可以读取并提升权限。

但在这次案例中，并未发现此类问题。这促使我进一步探索逻辑应用界面中一些特殊符号的含义。这些符号表明存在一个“API 连接”。

API 连接是 Azure 中一个可能不为人知的组件。每当创建一个需要外部连接的操作时，系统会自动创建 API 连接。即使删除了相关操作或逻辑应用，这些连接也可能不会被删除，久而久之就会堆积起来。

点击一个 API 连接（例如一个 Slack 连接器），界面本身信息有限。但有趣的是，通过 HTTP 请求查看其响应时，我们得到了包含关键信息的数据。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_1.png)

其中，第一个红色方框内的“测试链接”引起了我们的注意。这是一个指向 Azure 资源管理器的 URI。

## 深入分析“测试链接”

![](img/99dbf6bdc9f1e12309597a6ef6e186db_3.png)

上一节我们发现了可疑的测试链接，本节我们来分析它的结构和含义。

该 URI 格式如下：
```
https://management.azure.com/subscriptions/{subscription-id}/resourceGroups/{resource-group}/providers/Microsoft.Web/connections/{connection-name}/extensions/proxy/conversations.list
```

这是一个对 Azure 资源管理器的请求。Azure 资源管理器是管理 Azure 中所有资源的服务。URI 的构建方式遵循固定模式：包含订阅 ID、资源组、资源类型（此处为 `Microsoft.Web/connections`）、资源名称以及要执行的操作。

这个操作有几个有趣的点：
1.  路径中包含 `extensions/proxy`，表明它正在代理请求到某个后端。
2.  它以 `conversations.list` 结尾，熟悉 Slack API 的人会知道，这确实是 Slack 中用于列出频道的端点。
3.  最重要的是，这个 API 在 Azure 官方文档中并未记载。根据经验，未记录的 API 往往充满漏洞。

以读者权限调用此端点，会返回一个频道列表，这与直接调用 Slack API 的预期结果一致。但问题来了：是谁在发起这个调用？是我吗？我在该租户中有一个 Slack 用户。但测试发现并非如此。

当我们尝试另一个端点 `doNotDisturb.setSnooze`（设置免打扰状态）时，它返回“snooze enabled”。然而，检查客户的 Slack 后发现，我自己的状态并未改变。那么，是谁的状态被改变了？

我们尝试通过 `conversations.join` 加入频道来查看谁加入了，但收到了“访问被拒绝”的响应。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_3.png)

至此，我们可以得出一个初步结论：**任何对 API 连接的 GET 请求操作，都可以被拥有“读者”角色的用户调用**。接下来的核心问题是：我们可以执行哪些操作？以及，真正在执行操作的主体是谁？

## API 连接的工作原理

为了回答上述问题，我们需要理解 API 连接的工作原理。微软提供了一张非常清晰的架构图。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_5.png)

![](img/99dbf6bdc9f1e12309597a6ef6e186db_5.png)

架构流程如下：
1.  逻辑应用收到输入，并携带用户令牌、连接器 ID、操作 ID 和连接 ID，与 Azure API 管理服务通信。
2.  Azure API 管理服务有一份 Swagger 文档，定义了所有可执行的操作，因此访问范围受其限制。
3.  API 管理服务使用输入的*用户令牌*和*连接 ID*，查询一个“凭据和元数据存储”，以检索**连接令牌**。
4.  这个**连接令牌**就是最终调用后端服务（如 Slack）时使用的凭据。它是在最初设置 API 连接时配置的，可以是 OAuth 参数、API 密钥等任何形式的秘密。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_7.png)

然而，如果我们直接尝试调用这个全局的 API 管理主机端点，会被拒绝，因为我们的读者用户不在该连接的访问控制列表中。

但矛盾点在于：我们之前明明通过 Azure 资源管理器成功调用了 Slack 并得到了响应。这是如何发生的？

![](img/99dbf6bdc9f1e12309597a6ef6e186db_9.png)

## 漏洞的关键：ARM 的访问权限

答案在于连接 ACL 有另一个入口：**Azure 资源管理器本身拥有访问权限**。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_7.png)

这解释了为何通过 Azure 资源管理器发起请求时，我们能够调用 Slack。要理解微软为何这样设计，需要了解 Azure 的一些安全模型特性（这些可能不是官方声明，但实践中确实如此）：

![](img/99dbf6bdc9f1e12309597a6ef6e186db_11.png)

1.  **简单的安全模型**：在与 Azure 资源管理器 API 交互时，有一个基本规则——**拥有“读者”角色的身份可以执行所有 GET 请求**。如果尝试执行 POST 请求，则会立即因权限不足而被拒绝。
    *   代码示例：一个不存在的资源 GET 请求返回“未找到”，而 POST 请求则直接返回“授权失败”。
    ![](img/99dbf6bdc9f1e12309597a6ef6e186db_9.png)
2.  **ARM 统一处理认证授权**：ARM 在所有端点上进行身份验证和授权检查。通过检查后，ARM 会使用一个拥有该资源完全控制权的系统令牌去查询后端服务。
    *   公式表示：`用户请求 -> ARM（角色检查）-> 后端服务（使用高权限系统令牌）`

这种模型有时会出错，例如过去存在的漏洞：`GET /functions/admin/token` 端点。本应需要管理员权限，但由于 ARM 开发者直接复制了后端 API 而忘了添加权限检查，导致读者角色也能调用并获取到 Web 应用的管理员令牌，从而获得远程代码执行权限。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_11.png)

## 漏洞利用：敏感的 GET 请求

回到 API 连接的问题。我们现在知道：
1.  我们通过 API 连接建立时的令牌来查询后端服务。
2.  我们可以执行所有 GET 请求。

那么，关键就在于：**世界上是否存在一些后端服务，其 GET 请求本身是敏感的？** 答案是肯定的。

以下是几个例子：
*   **Azure SQL 数据库**：通过特定 GET 请求，可以读取数据库中的所有数据。
*   **Jira**：Jira 连接器需要知道 Jira 实例的地址。这个地址不是设置在连接中，而是通过一个特殊的 HTTP 头 `X-Atlassian-Host` 在每次请求中传递。通过构造 GET 请求获取此信息，攻击者就能获得 API 密钥，从而完全控制 Jira 实例。
*   **Azure Key Vault**：这是最严重的案例。Key Vault 用于存储最敏感的密钥、密码和证书。通过 API 连接的 GET 请求，**低权限的“读者”可以直接读取 Key Vault 中的所有秘密**。

我将通用案例和 Jira 的特殊案例分别报告给微软。一周后，他们修复了通用案例，并关闭了 Jira 的报告称无法复现。几周后，他们告知已知晓此漏洞数月。

他们的修复方式是：现在尝试调用 `extensions/proxy/{endpoint}` 会被阻止，只允许调用明确定义的“测试连接”URL（例如 Slack 的 `conversations.list`）。他们采用了白名单机制来限制路径。

## 发现更严重的漏洞：动态调用端点

通用漏洞被修复后，我们思考能否发现更严重的问题。回顾架构图，我们发现另一个有趣的未文档化端点：**`dynamicInvoke`**。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_13.png)

![](img/99dbf6bdc9f1e12309597a6ef6e186db_13.png)

这是一个 POST 请求。根据 Azure 安全模型，执行 POST 请求需要“所有者”或“贡献者”权限。这意味着它不能用于租户内的本地权限提升（因为如果你已经是所有者，权限本来就很高）。其请求体如下：

![](img/99dbf6bdc9f1e12309597a6ef6e186db_15.png)

```json
{
  "method": "GET",
  "path": "/conversations.list"
}
```

![](img/99dbf6bdc9f1e12309597a6ef6e186db_15.png)

以所有者身份调用，会返回与测试链接相同的结果。但核心问题是：**我们是否仍被限制在“测试连接”的范围内？** 幸运的是，答案是否定的。我们可以调用 Swagger 中定义的*任何*端点。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_17.png)

虽然这本身可能是一个漏洞（例如，贡献者角色就能读取 Key Vault 所有秘密，这通常需要特定角色），但严重性有限，因为攻击者已经需要是资源的所有者/贡献者。

然而，这个端点有一个危险特性：它允许在请求体（而非 URI）中指定路径参数。这在 Azure 中很罕见，因为一旦被利用，后果可能是灾难性的。

## 路径遍历与跨租户攻击

攻击者可以创建一个自定义连接器，并定义一个包含路径参数的端点，例如 `/extensions/path/{parameter}`。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_19.png)

攻击思路是进行路径遍历：在 `{parameter}` 中注入类似 `../../../{victim-connection-id}/secrets` 的路径。攻击流程如下：

![](img/99dbf6bdc9f1e12309597a6ef6e186db_20.png)

1.  攻击者在自己的租户中创建自定义连接器。
2.  攻击者构造请求，通过 `dynamicInvoke` 调用自己的连接器，并在路径参数中注入指向受害者租户中某个 API 连接（如 Key Vault 连接器）的路径。
3.  Azure 资源管理器进行角色检查（攻击者是自定义连接器的所有者，通过）。
4.  ARM 进行路径验证（路径在 Swagger 中定义，通过）。
5.  ARM 将拼接后的路径（包含攻击者的连接 ID 和遍历后的受害者路径）发送给 Azure API 管理服务。
6.  API 管理服务解析路径，错误地将其路由到受害者的连接，并使用受害者连接的令牌执行操作（如列出 Key Vault 秘密）。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_17.png)

![](img/99dbf6bdc9f1e12309597a6ef6e186db_22.png)

![](img/99dbf6bdc9f1e12309597a6ef6e186db_24.png)

![](img/99dbf6bdc9f1e12309597a6ef6e186db_25.png)

实际利用演示：
1.  受害者租户中有一个 Key Vault 和一个连接到它的 API 连接。
2.  攻击者在自己的租户中创建自定义连接器。
3.  攻击者调用 `dynamicInvoke`，路径参数为：`../../../{victim-connection-id}/secrets`
4.  成功列出受害者 Key Vault 中的所有秘密名称。
5.  进一步，可以获取特定秘密的值。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_19.png)
![](img/99dbf6bdc9f1e12309597a6ef6e186db_20.png)

![](img/99dbf6bdc9f1e12309597a6ef6e186db_27.png)

**这实现了一种完全未经认证的跨租户密钥/秘密泄露。**

我将此漏洞报告给微软，他们在约两天内修复了它，并最终奖励了 40,000 美元。修复方式是黑名单机制，阻止了包含 `../` 的路径遍历。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_29.png)

![](img/99dbf6bdc9f1e12309597a6ef6e12309597a6ef6e186db_22.png)

![](img/99dbf6bdc9f1e12309597a6ef6e186db_31.png)

![](img/99dbf6bdc9f1e12309597a6ef6e186db_32.png)

## 总结与启示

本节课中我们一起学习了 Azure API 连接中一系列安全漏洞的发现与利用过程。

**核心要点总结：**
1.  **初始漏洞**：低权限“读者”角色可通过 ARM 代理调用 API 连接的“测试”端点，从而以连接建立时的身份访问后端服务（如 SQL、Jira、Key Vault），导致敏感信息泄露。
2.  **深层漏洞**：“所有者/贡献者”可用的 `dynamicInvoke` 端点存在路径遍历缺陷，允许攻击者跨租户访问其他用户的 API 连接，造成严重的跨租户数据泄露。
3.  **根本原因**：Azure 安全模型（读者可执行所有 GET 请求）与 API 连接架构（ARM 拥有连接 ACL 访问权、后端服务存在敏感 GET 操作）的结合缺陷。
4.  **修复方式**：微软采用了白名单（限制可调用的测试路径）和黑名单（阻止路径遍历字符）的方式进行修补，但未发布安全公告或 CVE。

**重要启示：**
*   **理解架构是关键**：攻击云服务并非黑魔法。深入理解其安全模型和常见架构模式，能帮助你快速识别潜在漏洞。
*   **沉默的修复**：此类严重漏洞的修复可能是静默的，没有公告、没有 CVE。用户无法知晓自己是否曾受影响，或是否需要轮换凭据。这凸显了主动安全评估和监控的重要性。

![](img/99dbf6bdc9f1e12309597a6ef6e186db_34.png)

---

**Q&A 环节**

**问：** 当攻击者读取受害者密钥时，受害者的日志会如何记录？受害者能否察觉到异常？

**答：** 日志会显示 API 连接访问了 Key Vault。但这看起来是预期的行为，因为受害者的逻辑应用本身运行时也可能访问 Key Vault。关键在于，日志会记录是*哪个身份*执行了访问。在这个漏洞中，访问会显示为受害者自己的逻辑应用或 API 连接身份进行的，因此从日志上看，就像是一次合法的、由受害者自身资源发起的访问，很难直接区分恶意行为。