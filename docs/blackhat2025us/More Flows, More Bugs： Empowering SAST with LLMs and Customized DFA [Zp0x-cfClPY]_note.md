# 课程 01：利用大语言模型与定制化数据流分析增强静态应用安全测试 🔍

在本课程中，我们将学习如何结合大语言模型（LLMs）与定制化的数据流分析（DFA）技术，来增强静态应用安全测试（SAST）的能力，从而提高发现代码安全漏洞的效率和准确性。

## 什么是SAST？ 🛡️

SAST，即静态应用安全测试。使用SAST工具，我们可以在不运行应用程序的情况下分析源代码。例如，检测SQL注入漏洞。

从右侧的图片中，我们可以看到，SAST现已成为DevSecOps中自动化安全检查的重要组成部分。流行的工具包括CodeQL、Fortify等。

## 什么是CodeQL？ 💻

CodeQL现已成为GitHub旗下的一个产品。其查询和库在MIT许可证下是开源的，包括其数据流分析部分。但其核心引擎是专有的。

CodeQL的工作流程包含四个步骤：
1.  下载项目的源代码。
2.  使用CodeQL命令行工具创建数据库。
3.  编写QL查询语句。
4.  针对数据库运行查询，并最终展示是否存在漏洞。

在CodeQL的“荣誉墙”上，我们可以看到所有被CodeQL发现的漏洞。这不是一个完整的列表，但截至目前，它已发现了418个漏洞，并且这个数字仍在增长。此外，在GitHub上，我们可以为项目设置CodeQL扫描，可以定期执行，也可以在每次拉取请求时触发。

## 挑战：误报与漏报 ❌

那么，这是否意味着没有漏洞了呢？我们尝试使用CodeQL来检测近期的一些高风险漏洞，例如本表中列出的那些。我们发现存在大量的漏报。我们分析了根本原因，如最后一列所示，并发现了两个主要原因：
1.  内置污染传播规则中，对“源”（source）和“汇”（sink）函数的覆盖不完整。
2.  由于对某些语言特性支持不足，导致数据流中断。

对于第一个问题，我将介绍如何使用大语言模型（LLMs）来自动识别源和汇函数。

## 利用LLMs自动识别源与汇函数 🤖

我们注意到，当前的方法严重依赖人工工作。一种方法是手动定义，即开发者必须手动审查源代码以识别源和汇。另一种方式是通过社区贡献，例如CodeQL有默认规则。从图中我们可以看到，关键信息包括库、模块、函数名。但我们发现这两种方法都相当耗费人力。

那么，有没有办法自动化这个过程呢？

### 问题一：在哪里寻找源和汇？

我们发现，源和汇函数实际上是来自第三方框架的API函数。从左边的图片中，我们可以看到，`SSRF`的汇实际上是Resty框架中的一个API。这些API函数的实现代码可以在开源框架中找到。因此，我们可以通过扫描这些框架来检测源和汇。

### 问题二：LLMs如何提供帮助？

右边是我们方法的工作流程。它包含三个AI智能体：
1.  首先，我们使用“发现”智能体来识别框架中潜在的源和汇函数。
2.  接着，“判断”智能体应用专家规则来检查这些函数，并移除不符合专家经验的结果。
3.  最后，“验证”智能体编写查询来验证这些函数是否在真实项目中被使用。

### 文件级粗粒度检测

首先，我们在文件级别运行粗粒度检测。我们将源代码文件和一个提示词（prompt）输入给模型。在提示词中，我们会描述需要识别的函数的特征，这些特征与编程语言和漏洞类型相关。例如，对于SSRF漏洞，汇函数通常是那些发送HTTP请求的函数。此外，我们还可以对响应的格式和风格设置约束。你可以尝试不同的提示词以获得最佳结果，这只是一个参考。

对于LLM的结果，我们会移除置信度分数较低的结果，阈值可以根据你使用的提示词和模型进行调整。最终，我们将得到一个源和汇函数的列表。

### 函数级细粒度过滤

为了移除上一步产生的误报，我们继续进行函数级别的过滤。我们同时检查函数名和函数代码。例如，对于SSRF，汇是发送HTTP请求的函数；而对于SQL注入，汇是执行SQL语句的函数。我们注意到，大型语言模型在此阶段往往表现更好。同样，任何不符合标准的函数都将被移除。最终，我们收集了每个框架中存在的所有源和汇函数。

### 集成专家经验

除了让LLM直接扫描，我们还需要集成专家经验。这些经验来自社区的长期实践。例如：
*   函数应该是公开可访问的。
*   函数的返回值应该传播被污染的数据。
*   函数的返回值不应是布尔类型。

这样的专家规则还有很多。同样，它们可以根据不同的漏洞类型或框架类型进行添加或修订。我们将使用LLM来应用这些专家规则，检查函数名和函数体，并移除不匹配专家规则的函数。

### 验证实际使用情况

最后一步是确认我们识别出的源和汇是否确实在真实项目中被使用。
1.  首先，我们需要访问框架项目的主页，找到其依赖页面。这个页面列出了大多数使用该框架的开源项目。
2.  接下来，下载这些项目的源代码，按星标数从高到低排序。
3.  最后，运行像CodeQL这样的SAST工具，应用新的源/汇规则来扫描这些项目。根据扫描结果，验证新添加的源和汇是否被实际使用，任何未被使用的源或汇都将被移除。

## 增强数据流分析（DFA） 🧩

对于第二个问题，即数据流中断，我将介绍我们对数据流分析（DFA）的增强。

### 什么是CodeQL中的数据流分析？

在CodeQL和其他SAST工具中，数据流分析是核心。左边是CodeQL中数据流分析的一个例子。它通过扩展`DataFlow::Configuration`类，并在第10行实现`isSource`接口，在第16行实现`isSink`接口，然后在第27行调用`flowPath`来执行全局污点分析。

右边是分析结果。我们可以看到一系列编号的路径节点，这个列表代表了一条完整的数据流路径。每个路径节点包含两部分：节点（Node）和访问路径（Access Path）。

### DFA的工作流程

这个图表展示了DFA的工作流程。首先，CodeQL提供了配置用户接口，你可以调用`flowPath` API（如上一张幻灯片所示）。其中有两个关键概念：节点（Node）和访问路径（Access Path）。

节点通过正向流（forward flow）和反向流（reverse flow）计算得出。正向流是从源点开始的向前传播，而反向流则相反，是从汇点向后追踪。它们共同形成了一条从源到汇的完整路径。

访问路径的计算分为五个阶段，从阶段1到阶段5。每个阶段都会添加更多细节以产生最终结果。

### 节点计算：正向流示例

我们使用正向流来说明节点是如何计算的。右边是CodeQL源代码的示意图，它包含不同的步骤，如`jump`、`store`等，细节在表格中。
1.  **源步骤**：设置数据流的起点。
2.  **局部流步骤**：处理过程内（intra-procedural）分析。
3.  **跳转步骤**：提供从一个节点到另一个节点的自定义传播接口。有两个接口：通过`additionalFlowStep`的用户级接口和通过`additionalValueStep`的系统级接口。
4.  **存储和加载步骤**：`store`是将污点节点写入字段、数组、集合或映射内容中，而`load`是从中读取污点节点。这是访问路径的核心。
5.  **调用入、调用出和贯穿步骤**：处理过程间（inter-procedural）分析。`callIn`处理从实际参数到形式参数的传播。`callOut`和`goThrough`处理返回值的传播，区别在于返回值是从外部源还是参数传播而来。注意，这里的`postUpdateNode`代表作为函数调用结果而隐式更新的节点。

### 什么是访问路径？

访问路径由一个内容列表和一个类型组成。内容本质上是描述数据如何存储在对象内部的一种方式，细节在左边的表格中。对于一个字段类型，其内容就是字段名；对于其他类型，它更像是表格中所示的广义结果。

访问路径跟踪在存储和加载步骤期间，四种类型节点（字段、数组、集合和映射）的内容传播关系。这里的表格展示了访问路径的示例。例如，在这个角色中，内容是`name`，类型是`string`。

### 如何计算访问路径？

在右边这里，我们根据表格编写了一个示例代码。你可以看到在每个阶段，内部值的访问路径是如何变化的。在阶段1开始时，根本没有访问路径。在阶段2，访问路径变为布尔类型，表示是否存在内容传播操作。在最后阶段，我们发现完整的访问路径是一个内容列表和一个类型。

## 应对DFA的挑战：以Java为例 ⚔️

在概述了DFA之后，我们现在介绍它面临的一些挑战，以Java为例。

静态分析工具（包括CodeQL）面临着诸如跨线程问题、反射和值传递等挑战。

### 挑战一：跨线程分析

这是一个跨线程分析的例子。静态`main`方法的参数是源点，而`println`方法的参数是汇点。左边是代码，右边是静态分析的中间结果。

正如我们在默认分析中看到的，我们无法找到从源到汇的路径。它在第14行`RunnableDemo`的构造函数调用处中断了。

#### 解决方案：利用跳转步骤

我们如何连接它？回想一下之前介绍的跳转步骤，我们可以使用跳转步骤，从`RunnableDemo`调用跳转到`run`方法的实例参数，即`this`参数。打上补丁后，我们得到了完整的路径。

总结一下，当污点通过`Runnable`实例的构造函数传播时，我们的方法是从构造函数调用跳转到`run`方法。这是使用`additionalValueStep`接口的实现，我们在此完成了跳转步骤。

但如果污点不是通过构造函数传递的呢？例如，通过函数调用中的赋值语句（如第8行所示），我们如何处理这种情况？

我们的解决方案是：如果污点在`start`接口被调用之前就已存在（如第17行所示），我们获取`start`方法的调用者，并跳转到`run`方法的实例参数。所以是从这里跳到这里。在这种情况下，从第18行跳转到第10行。打上补丁后，我们可以得到完整的路径。

如果污点出现在`start`接口之后呢？在这种情况下（第23行），我们的方法是找到一个满足三个条件的节点：
1.  该节点是一个`postUpdateNode`。
2.  该节点是一个`Runnable`实例。
3.  该节点有一个存储操作。

我们从该节点跳转到`run`方法的实例参数。所以在这种情况下，从第8行跳转到第10行。打上补丁后，你可以看到完整的流被检测到了。

### 挑战二：Java反射

接下来，我们介绍第二个挑战：Java反射。以这段代码中的`invoke`方法为例（第13行），我们面临两个困难：
1.  我们如何确定`invoke`实际对应的是哪个方法？即，第13行的方法是什么？
2.  我们如何修复过程间调用（如`callIn`和`callThrough`）的传播关系？从红线我们可以看到，参数传播逻辑与正常的调用过程不同。

#### 解决方案一：确定反射方法

对于挑战一，有两种解决方案。一种方法是跟踪方法实例，如图所示。另一种是根据`invoke`方法中参数的数量和类型来确定方法。我们已经实现了这两种方法，并注意这种跟踪需要全局数据流分析。

#### 解决方案二：在CodeQL数据流中整合反射分析

第二个挑战，如何让反射分析在CodeQL的数据流中工作？我们之前提到，`additionalValueStep`可以定义边来连接两个节点。但这里有个问题：你不能在`additionalValueStep`内部使用数据流接口，因为这样做会导致非单调递归问题。基本上，你需要在`additionalValueStep`中使用数据流接口，但数据流接口又依赖于`additionalValueStep`，如图所示。

如何解决这个问题？我们可以创建一份数据流分析实现的副本，让我们的反射分析依赖于这个副本，如图所示。然后我们修补原始的数据流以避免任何依赖问题。

为了支持`invoke`方法，我们修复了`callIn`和`callThrough`的参数传播逻辑。例如，对于`callIn`，`augment`传播到参数，`object`传播到参数`this`。

这里是一个反射的例子。首先，数据流在第13行的`invoke`方法处中断。通过添加反射分析（如步骤1-4所示），我们可以将污点从这里的`source`传播到这里的`object`。因此我们得到了完整的路径。

### 挑战三：Java中的值传递

接下来，介绍Java中的值传递问题。首先，什么是编程语言中的值传递？参数通常通过值传递或引用传递。在Java中，实际参数传递给方法的方式是值传递，而不是引用传递。因此，如果参数是基本类型，传递的是基本类型实际值的副本，并且会创建一个副本。如果是引用类型，传递的是实际参数所引用对象在堆中地址值的副本。就像基本类型一样，会创建一个副本。

那么问题是什么？右边是一个副本存储在字段中的案例。但问题是存在许多副本，例如这个例子中的`Person p`和`d.a`。所以核心问题是，当一个副本中的值被修改时，所有副本都需要更新。

在这种情况下，它是`DemoField`实例构造函数中的参数`Person p`，副本用这里的蓝线表示。

#### 解决方案：处理值传递副本

以下是我们的解决方案：
1.  首先，我们必须定位非基本类型的字段。在这个例子中，它对应于字段`a`。
2.  对于这个字段，找到存储操作，识别出非`postUpdateNode`和`postUpdateNode`。在这个例子中，它对应于第7行和第11行。第7行是非`postUpdateNode`，而第11行是`postUpdateNode`。
3.  对于非`postUpdateNode`的存储操作，使用全局数据流来定位参数和实际参数。在这个例子中，如红色虚线所示，我们定位到了`DemoField`构造函数中的参数`p`。
4.  对于`postUpdateNode`的另一个存储操作，我们添加一个从该节点到该节点的映射。这就是我们之前介绍的跳转步骤。

我们必须使用全局数据流，因为我们可能会遇到过程间调用、存储和加载操作等场景。

## 研究成果与案例 🏆

接下来，我将介绍我们的研究成果。

### 识别结果

我们在大约18个Go框架中发现了约190个源和汇函数。我们还扫描了超过5000个项目，发现检测到的数据流增加了15%以上。

### 案例一：发现新的SQL注入漏洞

我们使用这个CVE来展示一个新的汇如何导致漏洞检测。这是Apache Traffic Control项目中Traffic Ops组件的一个SQL注入漏洞。这个项目启用了CodeQL扫描，这意味着它对CodeQL来说是一个漏报。

以下是该漏洞的数据流：
1.  第一步是从用户输入中读取参数，这里是用户的评论。
2.  然后处理和验证请求参数，如这个`info.go`文件所示。
3.  最后，当将用户评论插入数据库时，调用了`QueryRowx`函数。

但当我们检查CodeQL的检测规则时，我们注意到`QueryRowx`函数没有被包含在汇模型中。我们扫描了`sqlx`框架，并发现了这个汇，如图所示。因此，我们检测到了这个漏洞。

### 案例二：增强检测历史CVE

通过我们的增强，我们可以检测到以前无法检测到的历史CVE。在这个案例中，添加源函数使得能够检测到三个CVE，影响了几个开源项目。

### 案例三：验证跨线程和反射增强

这个CVE证明了跨线程补丁和缺失汇规则的有效性，因此我们可以复现这个CVE。而这个CVE则证明了反射增强的有效性。

此外，我们还发现了许多新的漏洞，下面是一些案例。

## 总结与要点 📚

在本课程中，我们一起学习了如何利用大语言模型自动识别安全分析中的源与汇函数，并对静态分析工具（以CodeQL为例）的数据流分析机制进行了定制化增强，以应对跨线程、反射、值传递等复杂场景。

我们的主要收获如下：
1.  代码的语义分析特别适合LLM辅助分析，二者的结合是一个有前景的研究方向。
2.  CodeQL的数据流分析机制具有高度代表性，是学习数据流分析的一个良好起点。
3.  CodeQL的数据分析并非完美，可以被研究、修改和改进。

希望本教程能帮助你理解如何利用现代技术增强传统的安全测试方法。