# 课程 1：解密 Signal：理解端到端加密的真实隐私保障 🔐

在本节课中，我们将深入探讨 Signal 应用的安全审查过程。我们将学习 Signal 的工作原理、它所承诺的隐私保障，以及在审查过程中发现的一些漏洞。课程将分为三个主要部分：安全审查方法介绍、Signal 的设计与加密原理解析，以及具体的实现细节与漏洞分析。

## 第一部分：安全审查方法论 🧐

上一节我们介绍了课程的整体结构，本节中我们来看看进行安全审查时采用的方法论。

我的安全审查通常从四个层面思考一个应用：
1.  **设计**：系统应该做什么，规格说明书是如何定义的。
2.  **意图**：工程师如何理解设计，以及他们打算如何实现。
3.  **实现**：工程师实际编写的、用于表达其意图的代码。
4.  **执行**：代码在运行时的行为及其边界情况。

在每个层面都可能存在不同的安全漏洞，并且发现这些漏洞需要不同的技能和技术。

此外，我将漏洞大致分为四类：
*   **语言特定漏洞**：例如，审查 C/C++ 代码时可能发现内存损坏问题。
*   **应用程序特定漏洞**：例如 SQL 注入。
*   **逻辑漏洞**：业务逻辑或流程中的缺陷。
*   **产品特定漏洞**：与特定功能实现相关的漏洞。

在本次 Signal 的审查中，我们将涉及上述多个类别。

## 第二部分：Signal 架构与加密原理 🏗️

上一节我们介绍了审查的框架，本节中我们来看看 Signal 的整体架构和核心加密机制是如何工作的。

我们可以用一个类似物理邮件的类比来理解 Signal。发送方（Alice）写好信，装入信封，投递到邮箱。邮递公司（Signal 服务器）拾取信封，将其路由到收件人（Bob）的邮箱。收件人收取并阅读信件。

在未加密的情况下，信封是透明的，服务器可以阅读内容。Signal 的目标就是让这些信封变得不透明（加密）。

### 密钥协商与加密

为了实现用户间的加密通信，双方需要协商一个共享密钥。这通常通过迪菲-赫尔曼密钥交换协议实现。

**迪菲-赫尔曼密钥交换的简化类比**：
1.  Alice 和 Bob 公开约定一种公共颜料（公共参数）。
2.  双方各自选择一种秘密颜色（私钥）。
3.  双方将自己的秘密颜色与公共颜料混合，得到混合颜色（公钥），并通过公开网络交换。
4.  双方收到对方的混合颜色后，再混入自己的秘密颜色。最终，双方得到相同的最终颜色（共享密钥）。从混合颜色反推出原始秘密颜色在计算上是不可行的。

Signal 使用椭圆曲线迪菲-赫尔曼算法。用于建立会话的临时密钥称为“预密钥”。这些密钥由一把称为“身份密钥”的长期密钥签名，身份密钥在账户生命周期内基本不变，且几乎从不离开设备。

一旦 Alice 和 Bob 通过迪菲-赫尔曼交换获得了共享密钥，他们就可以开始加密消息了。

### 前向保密与后向保密

然而，这里存在一个攻击面：如果服务器保存了所有加密消息的副本，而攻击者后来窃取了用户设备上的密钥，他就能解密所有过去的对话。这破坏了“后向保密性”。

解决方案是为每条消息使用唯一的密钥。Signal 通过“链密钥”和“消息密钥”来实现：
1.  从迪菲-赫尔曼共享密钥派生出一个“链密钥”。
2.  将链密钥输入密钥派生函数，输出一个“消息密钥”和一个新的“链密钥”。
3.  使用**消息密钥**加密本条消息，加密后立即丢弃该消息密钥。
4.  新的**链密钥**用于派生下一条消息的密钥。

这个过程可以形象地看作一个“棘轮”：每发送一条消息，棘轮就向前转动一格，无法倒退。这解决了后向保密性问题。

但还有“前向保密性”问题：如果攻击者当前窃取了设备上的棘轮状态，他就能解密所有未来的消息。Signal 通过“双棘轮协议”解决：在对话方向改变时（例如从 Alice 发送变为 Bob 回复），双方会协商一个新的迪菲-赫尔曼共享密钥，从而创建全新的棘轮，旧棘轮被废弃。这样，即使当前密钥泄露，未来的通信也能得到保护。

### 元数据保护：密封发送者

除了消息内容，通信的元数据（如谁在和谁通信）也可能泄露隐私。Signal 的“密封发送者”功能旨在隐藏发送者身份。

其原理是：发送者将包含接收者信息和加密消息的整个数据包，再用一层仅接收者能解密的密钥加密。这样，Signal 服务器只能看到一个需要投递给 Bob 的加密包裹，而不知道包裹来自 Alice。

## 第三部分：实现细节与发现的漏洞 🐛

上一节我们探讨了 Signal 的设计原理，本节中我们将深入代码实现，并查看在审查中发现的具体问题。

### 漏洞一：明文信封处理不当

Signal 协议允许一种特殊的“明文”信封类型，仅用于一种情况：当接收方无法解密消息时，向发送方发送“重试请求”。该明文信封应只包含一个“解密错误”消息。

然而，审查发现客户端对此验证不严：

*   **iOS 客户端**：完全未验证明文信封的内容，导致恶意服务器可以向任何对话注入任意类型的消息（如文本消息、编辑消息）。
    *   **修复**：添加检查，确保明文信封有且仅有“解密错误”内容。
*   **Android 客户端**：验证了明文信封必须包含“解密错误”消息，但遗漏了对“数据消息”的检查。因此，恶意服务器可以发送一个同时包含“解密错误”和“数据消息”的明文信封，Android 客户端会处理其中的数据消息。
    *   **修复**：添加检查，确保明文信封不包含数据消息。
*   **桌面客户端**：验证逻辑与 Android 类似，但由于代码执行顺序（先处理“解密错误”，处理完后函数返回），实际上阻止了后续恶意内容的执行，因此是安全的。

**漏洞影响**：恶意服务器可利用此漏洞，在用户不知情的情况下，向任何 Signal 对话中注入消息。

### 漏洞二：同步消息缺少身份验证

Signal 支持多设备链接。为了同步状态（如已发送消息、已读回执），设备间会通过一种特殊的“同步消息”进行通信，这些消息使用相同的端到端加密协议。

关键的安全要求是：设备必须验证同步消息确实来自**用户自己的其他设备**，而不是其他任何人。

审查发现：
*   **Android 客户端**：在处理同步消息时，缺少对发送者身份的验证。这意味着攻击者 Mallory 可以向 Bob 的 Android 设备发送加密的同步消息，Bob 的设备会信以为真并执行相应操作（例如，更改 Bob 的已读回执设置，甚至在他的对话中注入消息）。
*   **iOS 和桌面客户端**：正确验证了同步消息的发送者身份。

**漏洞影响**：攻击者可以向 Android 用户发送恶意同步消息，零点击（无需用户交互）修改其应用状态或注入消息。该漏洞在发现当天即被修复，并且由于 Signal 强制客户端在3个月后必须更新，目前应已无受影响的客户端。

![](img/986ffde8b3c4f2a26ea08f2de2f5f0b1_1.png)

![](img/986ffde8b3c4f2a26ea08f2de2f5f0b1_3.png)

![](img/986ffde8b3c4f2a26ea08f2de2f5f0b1_4.png)

## 总结 📝

![](img/986ffde8b3c4f2a26ea08f2de2f5f0b1_6.png)

本节课中，我们一起学习了 Signal 端到端加密消息应用的安全审查之旅。

我们首先了解了从设计、意图、实现到执行的多层安全审查方法。接着，深入探讨了 Signal 的核心架构，包括如何使用迪菲-赫尔曼协议建立安全会话，以及通过双棘轮机制实现前向和后向保密性。我们还了解了 Signal 通过“密封发送者”功能来保护元数据隐私的努力。

最后，我们剖析了在代码实现中发现的两个关键漏洞：明文信封滥用导致的服务器端消息注入，以及同步消息缺少身份验证导致的客户端状态篡改。这些漏洞属于逻辑和产品特定类别，这也符合成熟高质量应用中漏洞类型的演变趋势。

![](img/986ffde8b3c4f2a26ea08f2de2f5f0b1_8.png)

总体而言，Signal 的设计展现了强大的隐私保护理念，其开源特性也促进了安全审查和快速修复。本次审查揭示了即使在一个设计精良的系统中，实现细节上的疏忽也可能引入风险，强调了安全编码和严格验证的重要性。