# 课程 1：回到未来：基于连接的OAuth架构的攻击与防护 [__NtTfL0oPw]

在本课程中，我们将学习一种新兴的、基于连接的OAuth架构。这种架构被广泛应用于AI代理和集成平台，旨在简化第三方开发者的OAuth集成工作。然而，我们将看到，这种新架构也带来了新的安全挑战，使得一些经典的Web攻击（如会话固定、开放重定向和混淆代理）得以重现，可能导致严重的账户接管和数据泄露。

## 背景：AI代理与集成平台生态

在生成式AI兴起之前，用户已经可以使用由亚马逊、谷歌、微软等大型提供商构建的集成平台来控制外部应用程序或工具，以完成任务或编排更复杂的流程。

如今，随着我们进入AI代理时代，除了少数大型集成平台，还将出现大量由第三方开发者开发的AI代理。许多公司正忙于构建所谓的“AI代理平台”，以帮助第三方开发者开发这些AI代理。

在这种背景下，用户可以将控制和编排任务委托给大型集成平台以及第三方AI代理，以自动化日益复杂的任务。但我们必须确保只有经过授权的代理或集成平台才能代表用户访问和控制这些工具。这就需要委托授权机制。

在业界，OAuth是委托授权的标准。因此，无论是集成平台还是第三方代理，都需要依赖OAuth来实现授权。然而，众所周知，OAuth并不简单。特别是在将这些新用例应用于构建安全系统时，并不像看起来那么容易。

事实上，在去年的Black Hat USA 2024上，我们已经分享了我们的发现：当OAuth被应用于集成平台时，出现了许多新的相关漏洞。我们发现了三种基于虚假账户或账户错误链接的新型攻击，可能导致一键账户接管或隐私泄露。在我们研究的25个平台中，有24个被发现至少存在一种新型漏洞。这些受影响的平台横跨不同应用领域，包括智能家居、物联网、虚拟语音助手、工作流自动化以及支持低代码/无代码的服务。许多易受攻击的平台拥有超过1亿的活跃用户。这实际上表明，即使是大公司，要正确实施OAuth也并不容易。

随着AI代理的激增，我们将看到更多由第三方开发者开发的代理，问题可能会变得更糟。毕竟，第三方开发者可能不像大型集成平台提供商那样资源丰富或拥有OAuth方面的技术专长。

为了将第三方开发者从OAuth的复杂性中解放出来，业界出现了一种向“OAuth即服务”架构的范式转变。在这种方法下，我们可以将OAuth令牌管理的复杂性从大量第三方代理卸载到一个由AI代理平台运营的安全令牌管理器上。

在业界，我们已经看到了例子。例如，微软现在至少提供两种安全令牌管理器，分别名为Bot Framework令牌服务和凭证管理器，用于支持AI代理平台和集成平台。其他地方也有其他公司和初创公司提供类似的OAuth即服务架构，以方便第三方开发者更容易地构建他们的代理。典型的服务包括软件开发工具包、开发门户以及由公司运营的令牌管理器。通常，这些服务还包括支持流行工具的预构建软件模块。有些平台还在其平台下拥有自己的第一方代理应用程序。

这种OAuth即服务架构也与流行的模型上下文协议相关。毕竟，MCP最初是由Anthropic提出的，旨在支持在大型语言模型中使用。在原始的MCP架构中，由Claude Desktop等托管的MCP密钥库负责存储和管理所有工具的OAuth复杂性。但现在，在MCP社区中已经有一个新的提议，建议将令牌管理从MCP客户端卸载到由单个MCP服务器实现的令牌管理器。从这个意义上说，这种OAuth即服务架构无处不在。

听起来，OAuth即服务似乎很好。我们可以集中处理一些复杂性，并将其交给更有资源的构建者来实现。一切听起来都不错，但实际上并非如此。因为新的OAuth即服务架构也带来了自身的安全挑战。

具体来说，在这种架构出现之前，集成平台只需要扮演OAuth客户端的角色并在标准框架下实现OAuth。开发者基本上可以遵循OAuth标准来构建安全系统以管理OAuth授权。然而，在新的OAuth即服务架构下，标准框架中OAuth客户端的功能被拆分到了两个实体之间：第三方AI代理和安全令牌管理器。问题在于，如何拆分这些功能超出了OAuth标准的范围。因此，不同的AI代理平台需要推出自己的专有设计。不出所料，我们发现它们犯了错误，实际上引入了新的、关键的OAuth相关漏洞。

事实上，我们将与大家分享和解释的是我们的新发现。我们发现，一些被OAuth标准仔细处理的经典Web攻击，现在在这种OAuth即服务架构下重新显现。特别是，这些经典Web攻击包括会话固定、开放重定向以及不同类型的混淆代理。在我们的研究中，我们调查了七家不同的AI代理平台供应商，发现了许多漏洞实例，涉及跨用户攻击、跨代理攻击和跨工具攻击。所有这些都可能导致受害者的账户被接管。

## 技术细节：OAuth基础与基于连接的架构

现在，让我们深入了解技术细节。首先，从一些基本的OAuth术语开始。

传统上，如果你构建一个需要从工具（如Dropbox）获取令牌的代理，你需要设置一个OAuth客户端来管理令牌，而工具方则运行一个授权服务器来颁发这些令牌。你的代理（OAuth客户端）会将令牌发送回Dropbox的资源服务器以进行API调用。

但在这种新的OAuth即服务范式中，OAuth的角色保持不变。但由于OAuth客户端角色在代理和令牌管理器之间被拆分，关键问题在于：这两个实体如何协商？它们如何协调？

这里有两种潜在的解决方案。第一种解决方案是，我们只是将OAuth流程并排链接起来。我们在令牌管理器与工具之间重复OAuth模式，并让代理和令牌管理器之间也进行OAuth通信。这种方法的好处是，代理现在只需要与令牌管理器建立OAuth关系。但其局限性也很明显：代理仍然需要实现OAuth客户端并安全地管理令牌。人们称这种模式为“代理OAuth”。

另一种解决方案是，人们尝试发明一些基于OAuth连接概念的新东西，这是一些OAuth服务提供商引入的专有附加组件。其高层次思想是：令牌管理器不返回令牌（这是代理需要保密的密钥），而是简单地返回每个令牌的ID，即连接ID。这种架构的关键好处是，OAuth逻辑完全从代理端抽象出来，令牌管理器将为代理完全处理令牌的整个生命周期。我们称这种架构为基于连接的OAuth架构，这也将是我们讨论的重点。实际上，我们到目前为止提到的所有供应商示例都采用了这第二种方法。

更正式地说，连接被定义为一个用于管理OAuth令牌的预配置句柄。至少，它将包含一个三元组的信息：工具、代理和用户。这是因为这些是满足基本用例（代理代表任何用户调用工具如Dropbox）所必需的信息。这个三元组作为元数据在连接中被跟踪，并由一个连接ID（如数据库主键）管理。连接内部就是这个被管理的OAuth令牌。

在我们深入探讨OAuth如何与这个连接概念协同工作之前，让我们先退一步，弄清楚在没有连接的情况下，OAuth流程应该如何工作。

在幕后，它是这样进行的：首先，最终用户通常会通过Web浏览器参与OAuth。当用户点击连接按钮开始OAuth时，实现OAuth客户端的代理后端会发出一个OAuth授权URL并将其传回浏览器。这简称为OAuth URL。遵循OAuth URL，浏览器将访问Dropbox.com/authorize，这是Dropbox的授权服务器。最终用户需要登录Dropbox并提供其同意，点击授权按钮。但这种显式授权并不总是必需的。例如，如果你之前已经登录并授权过，那么下次遇到同一个工具时，同意很可能会自动完成。请记住这个设置，因为它将是许多强大隐蔽攻击的基石。在这个授权步骤之后，Dropbox将获取一个授权码，并通过浏览器重定向将其传递到由代理后端设置的回调地址。在这个过程中，还会涉及另一个名为`state`的OAuth参数，用于跟踪会话状态。然后是代码交换阶段，授权码将被交换为访问令牌，该令牌存储在代理后端。这样就完成了OAuth流程。因为每个代理都可以有自己的最终用户，所以浏览器中的用户会话将用于将令牌绑定到特定用户的身份。

现在，让我们转向新的基于连接的OAuth架构。在基于连接的OAuth中，有三个阶段：OAuth前、OAuth中和OAuth后。在OAuth前阶段，代理首先请求新连接，并将三元组（工具、代理、用户）的信息传递给令牌管理器。令牌管理器将生成一个新连接，但由于OAuth尚未完成，它将是一个空连接。这个新的连接ID和OAuth URL将在响应中返回。遵循OAuth URL，将建立OAuth流程，最终，一个访问令牌将占据连接中的这个空位。在OAuth后阶段，代理将使用此连接进行授权的API调用。

将连接概念融入OAuth后，整个流程如下所示：这是传统的OAuth流程（步骤1到5）。现在，我们将连接部分置于OAuth流程中。我们得到的就是基于连接的OAuth在正常协调下的工作方式。

从代理的角度来看，每当它收到最终用户开始OAuth的请求时，它只需查询令牌管理器以生成OAuth URL，然后将URL传回给用户，并等待用户完成OAuth流程。

从令牌管理器的角度来看，连接概念在OAuth流程中体现为授权会话，以便即使在用户的浏览器中也能跟踪连接。通常，这个授权会话由OAuth中的`state`参数维护。

从最终用户的角度来看，用户体验与传统OAuth没有区别。

但事实证明，这种正常的协调在设计上也是不安全的。为什么会这样？现在，我们从第一种攻击开始。

## 攻击一：会话固定

作为代理的最终用户，我期望我的授权不会流向由同一代理服务的另一个最终用户。但在现实中，这种期望会被一种称为会话固定的攻击所打破。

会话固定是Web安全中的一种经典攻击，攻击者可以将其自己的会话ID固定给受害者，并迫使受害者在该会话ID下进行身份验证。这样，攻击者就可以接管受害者的账户。在基于连接的OAuth中，回想一下，连接在OAuth期间体现为授权会话。所以我们实际上已经有了会话的概念。但固定部分呢？

当攻击者发起OAuth时，会返回一个OAuth URL，这标志着攻击者的连接和会话。现在攻击者要做的是：简单地将这个OAuth URL分享给受害者。例如，Dropbox.com/authorize 带有一些OAuth参数，然后让受害者自动完成剩余的OAuth流程。因为这里的授权会话属于攻击者，所以受害者的OAuth令牌最终会链接到攻击者的连接。结果，攻击者可以接管受害者的工具账户（如Dropbox访问权限）。这就是会话固定攻击的工作原理。

我们发现有五家供应商容易受到这种攻击。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_1.png)

在会话固定攻击中，是攻击者发起OAuth，但却是受害者实际完成OAuth。因此，为了防御这种漏洞，高层次的想法是：我们需要验证发起OAuth的用户与完成OAuth的用户是同一人。更具体地说，就是强制要求尝试生成此OAuth URL并进行后续OAuth流程的始终是同一个人。

但要实际实现这个高级防御思想，仍然有点棘手。因为，我们再次面临令牌管理器和代理后端之间的拆分。我们所知的原始重定向无法确定哪个用户实际完成了OAuth，因为它会重定向到这个令牌管理器。令牌管理器被设计为仅处理OAuth。它对所有其他代理特定逻辑（例如用户会话）是不可知的。

所以，这里的修复思路是：令牌管理器需要额外重定向回代理后端。然后代理后端可以从用户会话中提取用户ID以进行验证。我们称这种防御为“后重定向”模式。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_3.png)

这里我们提供了两种实现相同防御思路的替代方案。现在先跳过最终细节，但欢迎稍后回顾。

这里的关键要点是：正如你所见，即使在这个旨在完全解耦OAuth的基于连接的OAuth架构中，出于安全目的，代理后端仍然需要承担一些OAuth责任。

总结一下，我们在基于连接的OAuth中看到了会话固定的可能性。实际上，如果下游工具授权是通过简单地分发OAuth URL启用的，那么在MCP中也可以观察到类似的模式。如果你不验证用户身份的一致性，会话固定攻击也同样适用。

## 攻击二：开放重定向

开放重定向是另一种经典的Web攻击，其中网站的重定向功能会接受用户控制的输入，攻击者可以利用它将最终用户重定向到不受信任的位置。

在基于连接的OAuth中，当令牌管理器试图缓解会话固定攻击时，可能会出现开放重定向漏洞。它试图缓解之前的攻击。

回想一下，会话固定防御的实现要求令牌管理器向代理后端发出第二次重定向。但令牌管理器如何知道应该重定向到代理后端的哪个确切端点？一种常见的方法是从浏览器传递此信息。这可能会打开开放重定向的可能性，因为现在我们有了一个用户控制的输入。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_5.png)

攻击者会这样做：它会发起OAuth。但对于会话固定防御部分，它会指定一个攻击者控制的位置作为后重定向URL，而不是任何预定义的值。然后，像会话固定攻击一样，攻击者会简单地将OAuth链接分享给受害者，受害者将完成OAuth流程。现在，由于会话固定防御，这个令牌管理器将重定向到攻击者控制的位置。这就是OAuth凭证可能泄露给攻击者的方式。

对于开放重定向，我们在微软发现了两个攻击实例。事实证明，微软只使用通配符检查了后重定向URL。因此，我们可以将后重定向指向一个在微软域上存在跨站脚本漏洞或postMessage漏洞的地方，这都将允许攻击者最终窃取受害者的OAuth凭证。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_7.png)

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_8.png)

现在，让我们看看如何利用这个开放重定向与跨站脚本来窃取Microsoft Power Automate和Power Apps中的Outlook电子邮件。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_10.png)

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_11.png)

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_13.png)

首先，我们幸运地在`ideas.powerapps.com`上发现了一个跨站脚本漏洞。这是Power Apps社区论坛的域名。它与OAuth后重定向URL共享相同的根域，但子域不同。攻击者可以将恶意脚本作为帖子评论注入。但在这里，我们不会直接窃取这个问答网站的cookie，因为影响较小。相反，我们会将任何URL参数转发到攻击者的站点。

然后，我们将它与OAuth漏洞结合起来。在OAuth期间，我们启动一个新连接。攻击者会将此后重定向URL设置为那个跨站脚本页面的URL。由于微软的令牌管理器只进行通配符匹配，这个新的、被操纵的后重定向URL也会被接受。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_15.png)

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_16.png)

现在攻击者要做的是：复制那个OAuth URL，然后撰写一封钓鱼邮件，发送给受害者。然后，受害者会被诱骗点击。受害者将自动跳转到被操纵的后重定向位置，这将触发恶意JavaScript，将受害者的授权码泄露给攻击者。这就是受害者的授权码可能泄露的方式。之后，攻击者可以用这个被盗的代码兑换访问令牌，并导致这个带有受害者令牌的被盗连接。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_18.png)

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_20.png)

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_22.png)

接下来，攻击者将使用这个被盗的连接与Outlook电子邮件工具，从受害者的邮箱中泄露电子邮件。我们可以看到电子邮件被泄露。现在，任务完成。

作为防御，它要求令牌管理器严格验证后重定向是否被允许，或者甚至不将此后重定向URL暴露给前端，而是将其预配置在后端，这样就不会有用户控制的输入用于重定向。

反思一下OAuth中的开放重定向攻击，在OAuth中实际上已经存在一个常见的开放重定向来源，即从Dropbox到令牌管理器或OAuth客户端的第一次重定向。但在这里，我们想强调这第二次从令牌管理器到代理后端的后重定向。在实现这种会话固定防御时，可能会进一步暴露开放重定向漏洞。

## 攻击三：混淆代理

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_24.png)

接下来，让我们转向一种新的攻击类别：混淆代理。在传统的Web安全中，混淆代理是一种非常广泛的攻击类型，其中特权实体会被攻击者混淆，并有意地转发请求。在这个服务中，我们确定了两种混淆场景。如果原本打算授权给一个代理的授权，却被授予并仅授予了另一个代理，会怎样？同时，如果我对一个工具的授权被令牌管理器转发给了另一个工具，又会怎样？

让我们首先关注不同代理之间的混淆。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_26.png)

从这个服务的商业模式角度思考：它能帮助代理开发者减轻OAuth负担越多越好。除了管理OAuth令牌，我还能提供什么？

这就引出了OAuth中预注册的概念。传统上，在用户实际运行OAuth流程之前，代理开发者需要首先与工具方沟通，例如与Dropbox沟通，请求一对唯一的ID和密钥。这个由工具方颁发的客户端ID用于在OAuth流程中识别代理。

但你知道吗？作为一种服务，我们在这里看到的是，一些提供商会与许多常见工具（如Dropbox、Outlook、GitHub或Google Calendar）进行OAuth注册，而代理开发者则不需要这样做。现在，不是每个代理都注册运行自己的客户端ID，而是多个代理共享由令牌管理器提供的相同客户端ID。

但这种设计存在一个关键缺陷，可能被升级为一种攻击，我们称之为“客户端ID混淆”。假设我作为一个最终用户，首先在一个我信任的代理中授权了Dropbox。但在幕后，我实际上是将访问权限和同意授予了令牌管理器上的那个Dropbox客户端ID。

后来，当我遇到一个也想要Dropbox访问权限的恶意代理时，尽管我本意上想保持警惕，但在幕后，我仍然在授权同一个令牌管理器的客户端ID，而我已经授予了同意。因此，Dropbox访问权限将自动授予这个恶意代理。

作为防御，我们要求令牌管理器最好不要为代理提供共享的客户端ID，而是让每个代理自己注册客户端。

## 攻击四：跨工具混淆

最后的攻击形式是不同工具之间的混淆。去年在黑帽大会上，我们展示了集成平台中的一个攻击向量，称为“跨应用OAuth账户接管”。其高层次思想是：在集成平台中，一个混淆代理可能会将受害者对良性工具（如Dropbox）的授权代码泄露给恶意工具。这种攻击要求平台本身有一个开放的市场，以便攻击者可以渗透一个恶意工具。

但现在，有了OAuth即服务支持的多个第三方代理，攻击者总是可以使用一个携带恶意工具的恶意代理来针对受害者代理中的良性工具。因此，现在恶意工具的存在不再依赖于受害者代理或平台的开放市场。

我们在业界发现了六个易受攻击的实例，它们容易受到这种跨代理版本的代码攻击。

![](img/ff4c832cf8c7dc238ff8ee5a0bfd725e_28.png)

作为这种代码攻击的案例研究，我们在Microsoft Copilot Studio中发现了一个严重的漏洞。在Copilot Studio中，每个代理被称为一个“copilot”。有趣的是，微软已经扩展了这个令牌管理器以支持用户身份验证。换句话说，你可以使用这个令牌管理器进行更细粒度的访问控制，以配置谁可以访问你的代理。

因此，这种跨代理代码攻击会变成：我可以使用一个恶意copilot并配置一个恶意身份提供商，来登录互联网上任意经过良好身份验证的copilot。

要发起此攻击，首先，攻击者会尝试登录受害者的Copilot碰碰运气。不幸的是，他会被阻止，因为受害者的Copilot只配置为在受害者自己的租户或组织内使用。所以攻击者是外部人员，自然无法登录。

但攻击者会这样做：他会在他的恶意copilot中设置这些恶意的授权服务器端点，这些端点将针对受害者copilot中的受害者工具或身份提供商。这与跨代理代码攻击的设置相符。

现在，攻击者将获取一个新的OAuth URL，使用他的恶意copilot与他的恶意身份提供商进行OAuth。他会将他的URL发送给受害者并诱使他点击。一旦受害者点击，他将被自动重定向，并将其copilot的OAuth凭证泄露给攻击者。然后，利用这个被盗的OAuth凭证，攻击者可以获得一个访问令牌，从而以受害者的身份登录到受害者的copilot中。

本质上，受害者只需点击一次超链接，没有任何特殊权限的攻击者就可以发起跨代理、跨工具的账户接管。在微软的背景下，这就是用于在受害者租