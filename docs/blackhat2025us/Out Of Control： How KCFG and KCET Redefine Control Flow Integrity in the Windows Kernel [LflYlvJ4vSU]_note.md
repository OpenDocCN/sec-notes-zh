# 课程 01：失控：KCFG与KCET如何重新定义Windows内核控制流完整性 🛡️

在本节课中，我们将学习Windows内核中的控制流完整性缓解措施。我们将探讨它们的重要性、工作原理，并重点分析这些措施在内核模式下的实现，与其在用户模式下的实现有何不同。

---

## 概述

控制流完整性旨在解决现代漏洞利用的一个核心前提：攻击者需要能够改变程序的合法控制流。我们将首先了解CFI要解决的问题，然后深入探讨Windows用户模式下的经典实现——控制流防护，以及其硬件增强版本——控制流强制技术。最后，我们将聚焦于这些技术在内核模式下的实现，即内核CFG和内核CET，并分析它们如何利用基于虚拟化的安全技术来应对更高权限的攻击者。

---

## CFI旨在解决什么问题？🎯

在深入CFI本身之前，有必要先看看CFI旨在解决什么问题。

当今大多数试图执行未签名代码的漏洞利用通常需要两样东西。

首先，需要有能力诱使目标程序执行一条它本不会执行的代码路径。

其次，利用同样的能力，将数据加载到目标程序中，并让操作系统或应用程序将这些数据当作代码来执行。

因此，CFI试图解决漏洞利用的第一个原则，即验证并缓解任何试图改变目标程序合法控制流的尝试。

---

## 用户模式CFI：控制流防护 🛡️

Windows中典型的例子是控制流防护，它自Windows 8.1起在用户模式中引入，这是微软实现的前向边缘CFI缓解措施，用于防护间接调用和跳转。

CFG的工作方式是在编译时，所有已知的间接调用目标都存储在一个位图中。这个位图是只读的，并且是每个进程独有的。每当发生间接调用或跳转时，我们首先查询位图，以获取关于即将调用的目标地址的更多信息。

就我们的目的而言，CFG位图的状态实际上就是“允许”或“不允许”。其具体表现形式略有不同，因为位图经过了一些内存管理器优化以压缩大小，并且根据编译器生成调用目标边界的方式，我们实际上需要两位来表示。但如前所述，就我们的理解而言，它就是允许或不允许。

以下是CFG出现前后的对比示意图。

在CFG出现之前，假设有一个漏洞利用，例如针对C++或浏览器。对象有一个虚函数表，其中包含一系列函数。拥有读写权限的攻击者可以定位这个虚函数表，覆盖其中的一个条目，然后诱使应用程序调用该函数。显然，在这种情况下，我们不会调用合法的目标，而是会跳转到ROP gadget或栈转移指令，从而偏离了正常的控制流。

在CFG出现之后，漏洞利用的步骤基本不变。但在调用任意目标之前，我们会先检查CFG：使用目标地址作为索引查询位图，获取相关的位状态，然后判断是否应该真正执行这个调用，还是应该终止进程。

由此可见，CFG确实对漏洞利用产生了影响。但攻击者总是选择阻力最小的路径。与其费心绕过CFG的实现，不如寻找其他不受CFG保护的控制流转移方式。

---

## 用户模式CFI的挑战：返回地址与CET 🔄

一个显而易见的突破口就是栈上的返回地址。栈上有一系列返回地址，函数执行完毕后会依次弹出。最终，某个返回地址被取出，导致执行流偏离到内存中的其他位置。

微软显然从一开始就知道这个问题，甚至在开发CFG时就提出了一个基于软件的解决方案，称为返回流防护。但由于其内部红队的发现，该方案被弃用了。因为该缓解措施的“真相源”几乎可以被确定性地泄露。微软做出了正确的决定，他们认识到无法在软件层面完美解决这个问题，因此决定等待基于硬件的缓解措施成熟。

英特尔的实现称为控制流强制技术，特别是其中的影子栈功能。Windows也支持AMD的等效功能。自Windows 10 1903起，用户模式CET已可用。

CET是一种硬件缓解措施，因此需要更新的处理器。这些处理器引入了一个新的架构寄存器——影子栈指针。SSP不能作为内存操作的源或目的操作数被编码。特别是对于用户模式CET，有一条特殊的指令`WRUSS`只能在处理器运行于当前特权级0时执行。因此，对于用户模式攻击者而言，影子栈是完全不可变的。

每当发生调用时，除了更新指令指针和将返回地址压入常规栈，我们现在还会将返回地址压入这个不可变的影子栈。每当发生返回时，我们同时从影子栈和常规栈弹出返回地址并进行比较。如果两者不匹配，CPU会触发一个特殊的中断。

---

## 从用户模式到内核模式的挑战 ⚠️

显然，这些缓解措施极大地阻碍了漏洞利用。但你可能已经注意到一些问题。

那就是，这两者都依赖于一个给定的“真相源”。例如，用户模式CET和用户模式CFG都受到用户-内核安全边界的保护。如果你想写入影子栈，要么需要某种方式请求内核使其可写，要么需要能够在处理器运行于内核模式时执行那个特殊操作码。位图也是如此，你需要某种方式使其可写，这通常通过系统调用实现。

但是，如果你首先就有能力执行代码来做这些事，那么这些缓解措施对你来说就形同虚设。我们依赖用户-内核安全边界。

问题在于，如果你试图针对内核模式攻击者实现这些缓解措施，但缓解措施本身与你要防御的攻击者处于相同的特权边界内，那么你的缓解措施显然不会有好结果。

---

## 基于虚拟化的安全：更高的边界 🏰

幸运的是，Windows实际上有一个更高的安全边界，那就是Windows Hyper-V 管理程序。

微软在“基于虚拟化的安全”这一总称下实现了一系列功能，这为CFG和CET等机制的“真相源”提供了保障。

VBS的工作原理是利用第二层地址转换。虚拟机位于物理内存的隔离区域中。VM1和VM2访问它们认为是物理地址1000的内存，但实际机器上只有一个物理地址1000。因此，虚拟机在自身上下文中访问内存，并通过一个次级机制执行最终级别的转换，将虚拟地址映射到真实的系统物理内存。

利用这一点，我们可以将操作系统划分为两个“虚拟信任等级”。VTL 0是我们的正常世界，即典型的内核页表，也就是我们熟知的Windows。现在我们还有安全世界，即VTL 1。它被称为安全世界，并非因为它天生安全，而是因为它被允许对VTL 0的安全策略施加影响。

我们将要分析的一个例子是内核数据保护。这是VBS下较新的缓解措施，它有效地保证了VTL 0（即正常Windows运行的地方）中的某个内存区域始终保持只读，无论攻击者是否拥有内核模式的读写权限。

再次假设有一个内核漏洞利用。我们在用户模式下运行，并泄露了KDP保护内存区域的关联内存。我们定位其关联的页表项并将其标记为可写。现在我们去执行写操作。但这个写操作发生在VTL 0中，VTL 0就像一个虚拟机。因此，该内存访问被委托给管理程序，由管理程序执行额外的转换级别。

KDP所做的是为VTL 0设置一个只读的EPT条目，表明该页面实际上是只读的。这些权限通过只有管理程序才能访问的扩展页表条目来体现。因此，在这种情况下，即使内核模式攻击者将常规内核管理的PTE标记为可写，扩展页表条目作为最终的真相源，仍然规定其为只读。这实际上等同于向只读内存区域写入，会导致EPT违规，机器将崩溃。

由此可见，我们确实有办法保证VTL 0（传统内核）中内存的完整性。但事情并非简单地将用户模式的实现照搬到内核模式并加上一些管理程序功能那么简单。

---

## 内核模式CFG的实现 🧩

工程师们必须考虑很多事情。一个例子是VM退出。当处理器在客户机上下文中运行时，客户机调用管理程序的服务，这有点像系统调用。然后处理器切换到VMM模式或管理程序模式运行。这会产生上下文切换，处理器必须更新其状态等。这绝非免费操作。因此，仅仅请求管理程序服务就可能引发VM退出，这是我们必须牢记的。

基于此，现在让我们来看看这些缓解措施在内核模式下的实现。

首先，内核模式CFG出现在Windows 10 Redstone 2中。用户模式CFG作为可选更新出现在Windows 8.1中，而内核模式的实现则花了更长时间。

KCFG仅在启用了基于虚拟化的安全的另一项功能——管理程序保护的代码完整性时才会完全启用。HVCI的工作方式与KDP类似，它试图保证VTL 0中内存的完整性，但它关注的是被指定为代码的页面变成数据页面，或者数据页面变成代码页面。这是未签名代码执行的两个先决条件。

以下是KCFG的工作流程。

NT内核仍然负责指定内核模式CFG位图的存放位置。只有一个内核模式CFG位图。每个进程都有自己的CFG位图，但内核模式地址空间是共享的，因此有一个2TB的内存区域是所有镜像共享的内核模式CFG位图。

NT内核在初始化时负责确定其位置，并通过一种称为安全系统调用的机制通知安全内核。因为常规内核和安全内核是物理内存的隔离区域，它们彼此不知道对方的布局。

这个安全系统调用通过超级调用接口进行。因此，在初始化时，安全内核通过一个NT地址范围结构来跟踪与位图关联的内存区域。NR结构允许安全内核标记：“我知道这个内存区域很重要，它位于常规内核中，我需要管理它。”

通常，每个内核模式镜像加载都会创建一个NR结构，其中包含该镜像所有可执行代码的内存范围。但我们也有不直接与内核模式镜像绑定的特殊项，例如CFG位图或影子栈。这些是安全内核需要知道的内存区域，它们被称为静态NR。

在安全内核接收到位图位置信息后，后续的每个镜像加载都会发生以下步骤。

每个支持CFG编译的内核模式镜像加载时，都会从位图范围进行新的分配。显然，我们无法一次性提交2TB内存，这会耗尽提交限制，且大多数系统不支持。因此，一个优化措施是：先保留2TB地址空间，然后随着镜像的后续加载按需分配。

然后，该分配在VTL 0的EPT中被标记为只读。因此，即使攻击者在VTL 0中拥有内核模式读写权限，他们可以将页表项标记为可写，但由于管理程序负责设置只读的EPT条目，所以它实际上并不可写。

此外，新分配中的相关位状态会被更新，以标记需要跟踪的间接调用目标。

在此屏幕截图中，我使用源点JTAG调试器调试安全内核，可以看到一个超级调用正在发生，其掩码为GPA可读，从而设置了只读的EPT条目。

---

## KCFG的局限性与绕过 🕳️

我们不仅需要关心位图本身。例如，考虑用户模式下的`GetProcAddress`调用。你提供一个字符串，导出的函数地址会返回给你。然后你可能会调用那个内存地址。由于这是通过函数指针进行的间接调用，而间接调用受CFG检查，但通过`GetProcAddress`解析出的调用目标在编译时是未知的，因此它不是一个有效的调用目标。

这里的要点是，内核模式下等效的`GetProcAddress`是`MmGetSystemRoutineAddress`。如果你调用这个函数，调用目标会自动在位图中被标记为有效，这很有趣。

到目前为止，我还没有过多讨论漏洞利用，但CFG的一个已知弱点是它是一种粗粒度的CFI缓解措施。这意味着CFG并不验证你调用的目标是否是开发者预期的目标。它只是获取调用目标的地址，在位图中查找，如果有效，就跳转执行。

由于整个CFG位图被所有内核模式镜像共享，没有什么能阻止我们，例如，在`win32k`的间接调用中，用一个来自`NT`或`NTFS`等其他地方的有效调用目标覆盖原有的调用目标。因此，你显然仍然可以调用其他函数。

微软从一开始就知道这个问题，并最终提出了扩展控制流防护的解决方案。XFG在编译时创建函数原型的哈希，包括参数数量、参数类型、返回值和返回类型。这些信息在理论上对于给定函数应该是唯一的，并被放置在每个调用目标的上方。当间接调用发生时，我们获取调用点的XFG哈希，并与预期的哈希进行比较，如果不匹配，则发生CFG违规。

不幸的是，尽管这将“有效调用目标”的范围缩小到了“开发者预期的目标”，但XFG已被弃用，不再使用。

那么，内核CFG的现状如何？没有XFG，它就像普通的CFG一样工作。由于Windows中引入了一项称为热修补的新功能，其机制略有不同。这意味着不再通过间接调用来调用分发函数，而是被修复为一个新的分发函数，并通过直接调用进行。这里还有更多细节，但值得指出。

---

## KCFG的其他方面与绕过技巧 🧠

另一个有趣的注意事项是，内核CFG充当了软件SMEP的角色。过去，内核模式攻击者会分配一些用户模式内存，使用内核中的读写权限破坏一个函数指针，使其指向该用户模式内存，然后诱使内核调用那个被破坏的函数指针，从而将执行重定向到用户模式。这里唯一的问题是处理器仍然在内核上下文中运行，因此用户模式内存是以内核权限执行的。

KCFG，即使HVCI被禁用，也几乎是一个空操作，但有一个例外：对地址进行位测试，如果它是用户模式地址，即使HVCI未启用，我们仍然会使机器崩溃。

攻击者知道的另一件事是，导入地址表在CFG的文档中被明确指出不受保护。

在这种情况下，我们再次进行内核模式漏洞利用。我们在用户模式下运行，拥有内核模式读写权限。我们定位与`driver.sys`关联的导入表。在这种情况下，我们破坏PTE将其标记为可写。你可能会想，HVCI应该会起作用。你怎么能破坏这些页表呢？再次强调，HVCI关注的是代码变成数据或数据变成代码。导入表是一个数据内存区域，它只是变成了可写。因此，HVCI不关心这个。我们用ROP gadget破坏导入条目，然后诱使内核调用这个导入。因此，我们调用`ExAllocatePool2`，它会进行内存读取以获取它认为是`ExAllocatePool2`的地址，但实际上是ROP gadget。因此，即使启用了CFG，我们也调用了ROP gadget。

---

## 与Retpoline的交互 🔗

实际上，你可以将内核CFG与一个不太知名、不直接相关的缓解措施Retpoline结合起来。Retpoline旨在缓解一种称为Spectre v2的CPU分支预测漏洞。较新的CPU可以防御此漏洞，因此Retpoline现在已不太使用或讨论。

但就我们的目的而言，Retpoline所做的一件事是，它修补或修复了所有对导入表的间接调用，使它们变成直接调用，并指向一个特殊的Retpoline分发函数。但在99%的情况下，一个称为导入优化的附加功能实际上会导致它直接调用导入表。

在此屏幕截图中，我们可以看到，来自`NTFS`的调用是调用`NtZwClose`，但它不是通过间接调用进行的，而是通过相对调用进行的。即使较新的CPU不使用Retpoline，所有Windows镜像仍然为Retpoline支持而编译。因此，你得到了导入被修复为直接调用的好处。

我喜欢指出的一个有趣之处是它的实现方式。有一个称为动态值重定位表的功能。早在Windows 10 1607时，像PFN数据库、PTE数据库这样的分页结构的静态地址最终被随机化了。实现这一目标的方式是通过这个特殊功能，它得到了安全和编译器团队的支持，允许你将一个静态值重定位到其他值，从而实现随机化。Retpoline使用了DVRT的扩展，允许所有这些修复发生，我认为这非常有趣。

这对我们来说意味着我们不再需要从导入表读取。因此，在这种情况下，我为本次会议演讲编写了一个驱动程序。它通过导入表对`ExAllocatePool2`进行了一次调用。

但在调试器中，在R10寄存器中，我已经用一个任意的读写权限将该条目破坏为`0x41414141`。如果没有Retpoline支持，我们就会简单地调用`0x41414141`，因为这就是导入条目中的内容，然后我们会崩溃。但在这种情况下，你可以注意到没有崩溃，并且返回值中有一个有效的池块。这是因为，我们不需要对导入表进行内存读取。因此，无论攻击者是否破坏它，镜像加载时导入表中的内容都保持不变。指出这一点的意义在于，内核CFG的一个已知局限性实际上受到了Retpoline的保护。

---

## 转向内核CET：保护返回地址 🛡️

显然，攻击者可以做诸如覆盖返回地址之类的事情。在这种情况下，我有一个线程。该线程处于挂起状态，这意味着有一个异步过程调用排队告诉该线程：什么也不做。

然后，我使用内核模式读写权限破坏栈上的一个返回地址，用一个简单的ROP gadget替换它。当这个线程恢复时，栈将展开，我的ROP gadget显然会被执行。

这首先由一种称为“内核锻造”的技术概述。因此，我们显然仍然可以覆盖栈上的返回地址。

这正是内核模式CET的用武之地。现在返回地址受到了保护。

内核CET与内核模式CFG略有不同，它不是二元的。CFG是二元的，要么开启要么关闭。你需要编译支持。但对于CET，有一种称为审计模式的东西，你可以有效地将机器置于审计模式。当发生控制流保护故障时，中断处理程序不会直接蓝屏死机，而是会修复影子栈或其他需要的东西。最重要的是，它会发出一个Windows事件跟踪事件，你可以获取更多关于此次CET违规原因的信息。

如前所述，我们仍然需要HVCI。

---

## 内核CET的实现细节 ⚙️

与所有内核模式影子栈关联的内存区域仍然由NT管理。有些情况下我们需要内核模式影子栈，例如中断服务例程或DPC。但最典型的例子是线程创建。每当你创建一个线程，你就有一个关联的栈。那么，如果你有一个关联的栈，你现在就有一个关联的内核模式影子栈。

常见的例子是：线程被创建，新栈被创建，然后我们需要创建影子栈。我们通过安全系统调用接口内联调用安全内核，通知安全内核：“我们希望这个新的影子栈分配在这里，请将其标记为只读。”但此外，还有一个特殊的位，我们稍后会讨论，称为超级影子栈位，它是英特尔超级影子栈控制功能的一部分。

如前所述，每个线程创建都需要一个影子栈。如果每个线程创建都需要一个影子栈，那就意味着每个线程创建现在都会导致对安全内核的调用，而安全内核会做什么？它会进行超级调用并引发VM退出。如果我们不必这样做，我们并不想每次都这样做。

因此，NT管理着两个缓存。请放心，此缓存中的所有成员都至少走过一次慢路径。因此，它们在VTL 0的EPT中都是只读的。

我们有两种缓存：每处理器缓存和每NUMA节点缓存。NUMA节点实际上是关联到一定内存范围的处理器分组。

发生的情况是，如果条件合适，我们将不再需要的旧影子栈发送到这些缓存之一。这样做的原因是线程通常有一个理想处理器或理想NUMA节点。分配通常会被缓存在它们被发出或执行的处理器上。这里的想法是，如果我们可以将这些影子栈缓存在一个处理器或NUMA节点上，我们可能获得性能提升，因为当我们需要获取一个新的影子栈时，该内存可能已经缓存在给定的处理器上。

因此，我们有两个缓存