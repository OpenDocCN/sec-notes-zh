# 课程 1：逆向工程 macOS XProtect Remediator 🛡️

在本节课中，我们将深入探讨 macOS 安全组件 XProtect Remediator 的内部工作原理。我们将学习其检测逻辑、针对的恶意软件家族，并分析其使用的技术和潜在问题。本课程旨在为安全研究人员（无论是蓝队还是红队）提供关于 XPR 的深入技术理解。

## 概述

XProtect Remediator 是 macOS 恶意软件防御的第三层。它在前两层防御（如 Gatekeeper 和传统 XProtect）失效后启动，旨在检测并清除已在系统上活跃运行的恶意软件。本节课将解析其架构、扫描模块以及用于描述检测逻辑的领域特定语言。

## XProtect Remediator 简介

根据苹果的平台安全文档，XProtect Remediator 是 macOS 恶意软件防御的第三层。第一层和第二层包括苹果的应用审核、公证和传统的 XProtect。这两层旨在防止恶意软件被执行或分发。但 XPR 在恶意软件已执行后介入。它的工作是检测或清除在系统上活跃运行的恶意软件。

XPR 在 macOS Monterey 中引入，取代了 MRT。此后，MRT 停止接收更新。XPR 通常每月应用一到两次更新。截至目前，XPR 包含超过 20 个扫描模块，据信每个模块针对特定的恶意软件家族。

例如，名为 `XProtectRemediator.AR` 的二进制文件是一个扫描器，用于清除知名的广告软件。还有其他扫描器，如 `XProtectRemediator.BlueCargo`、`Bluetop`、`Bunco` 等。

## 为什么需要修复机制？

某些样本可以绕过第一层和第二层防御。例如，在两年前报告的 3CX 供应链攻击中，那个被木马化的 3CX 应用通过了苹果的公证，意味着它通过了 Gatekeeper 检查并成功启动。

此外，一些恶意软件使用社会工程学手段诱使用户禁用 Gatekeeper。在这两种情况下，恶意软件都能绕过前两层防御。因此，苹果需要一种方法来检测或清除在系统上活跃运行的恶意软件。

## 研究动机

首先，从攻击性安全的角度看，XPR 是一个有吸引力的目标，因为它拥有强大的权限。例如，其中的漏洞可能导致 TCC 绕过。事实上，Gary Kman 曾在 Twitter 上发布过一个漏洞利用，演示了如何通过其中一个 XProtect 扫描器从低权限获取完全磁盘访问权限。

此外，XProtect 扫描器同时以 root 和用户权限运行，这意味着 XProtect 中的漏洞可能潜在地导致用户到 root 的权限提升。

从防御性安全的角度看，XPR 也是一个有趣的反向工程目标。由于苹果倾向于使用自己的命名方案来指代恶意软件，XPR 针对的几个恶意软件家族仍然未知。像 Howard Oakley 和 Phil Stokes 这样的研究已经识别出其中一些，但由于缺乏深入的反向工程，仍有几个家族未知。

此外，XPR 的检测逻辑也不够清晰。它似乎只是简单地扫描文件并使用 YARA 规则进行匹配。但仅此而已吗？这仍然是一个悬而未决的问题。

## 主要研究目标

主要的研究目标是位于 `/System/Library/CoreServices/XProtect.app` 的这个应用程序包。

在这个包的 `Contents/MacOS` 目录中，有 23 个不同的扫描模块。它们的大小都在 2 MB 左右。还有一个名为 `XProtect` 的二进制文件（不要与传统的 XProtect 混淆）。还有一个 XPC 服务，名为 `XProtectRemediatorService`。

一个需要注意的点是，这些 XPR 衍生二进制文件是用 Swift 编写的。与其他用 Swift 编写的二进制文件一样，它们包含特定于 Swift 二进制文件的独特区段名称，如 `__swift5_entry`、`__swift5_typeref` 等。

## 相关工作

Howard Oakley 发表了许多关于 XPR 的博客文章。Alden Shimizu 发现 XPR 包含用于 YARA 规则和文件路径的加密字符串。Facebook 也编制了 XPR 相关恶意软件名称的列表。

但据我所知，我还没有看到任何关于 XPR 的详细或深入的反向工程结果。

## 逆向工程方法

接下来，我们来看看我是如何进行逆向工程的。

我使用 Binary Ninja 对超过 20 个扫描器二进制文件进行了逆向工程。当然，这些二进制文件是去符号化的。但令人惊讶的是，一些符号仍然可以恢复。

这是因为我使用 `bindiff` 进行了二进制差异分析，并发现 XProtect 扫描器的函数与 XProtect 有效载荷摘要有重叠。这意味着我们可以将该摘要导出的符号导入到 XProtect 扫描器中。

尽管如此，逆向工程 Swift 二进制文件仍然具有挑战性，因为它们是去符号化的 Swift 二进制文件。Swift 二进制文件通常包含类型相关的符号，例如类型方法访问器和协议见证表。这些符号对逆向工程非常有帮助，因为它们告诉我们正在实例化哪些类型的对象。但在这种情况下，这些符号也被去除了，因此几乎没有结构信息可供使用。

但幸运的是，即使二进制文件被去符号化，我们仍然可以访问其中的大量类型信息。这是因为 Swift 支持反射。用于反射的元数据可以通过 Swift 特定的区段（如 `__swift5_protos` 和 `__swift5_types`）访问。通过提取这些元数据，我们可以恢复类型信息。我们可以使用 blacktop 创建的 `ipsw` 工具中的 `swift demangle` 命令来提取这些类型信息。但提取的类型信息不能直接导入到反汇编器中。

因此，我开发了一个名为 `binja-swift-demangler` 的新 Binary Ninja 插件程序，并已发布在 GitHub 上。这个程序基于 `ipsw` 的 Swift 功能，它将类型元数据访问器、协议见证表符号和交叉引用方法注释到反汇编列表中。它还支持其他有助于 Swift 逆向工程的功能，如 Swift 字符串分析。

以下是一个快速示例：在没有这个插件的情况下，很难判断这个函数在做什么，引用了哪些类型的数据。但在运行插件后，该函数被重命名为适当的类型元数据访问器，为我们提供了更多的洞察力。

这是另一个例子：在运行插件之前，没有可用的类型相关信息，因此很难判断正在实例化哪些类型的对象。但在运行插件后，大量的类型元数据被注释出来，为我们提供了更多的上下文信息。

我还开发了动态分析工具来辅助逆向工程。Swift 二进制文件包含许多间接分支，例如通过虚函数表和协议见证表进行的调用。使用 LLDB 手动解析这些分支目标可能很繁琐。我的 LLDB 脚本捕获这些分支目标并将其导出为 JSON 文件。导出的数据可以通过 Binary Ninja 的同步插件导入。

以下是一个示例：捕获的间接分支目标索引可以像这样导入到 Binary Ninja 中。这个程序还会在可能的情况下注释协议见证表和函数符号。例如，如果一个函数是通过协议见证表调用的，这个程序会注释出与该调用关联的具体类型和协议。因此，它为逆向工程提供了大量有用的信息。

我还创建了一些自定义的 LLDB 命令。标准的 LLDB 表达式命令不能正确处理复杂的 Swift 对象，如存在性容器。因此，我构建了一些增强命令，用于转储更多的 Swift 对象。使用这些静态和动态分析工具，我能够更深入地研究 XProtect 扫描器。

## 检测逻辑概述

接下来，让我们进入逆向工程结果。首先，我将概述检测是如何工作的。

检测过程概述如下：位于 `/System/Library/CoreServices/XProtect.app/Contents/MacOS/XProtect` 的二进制文件同时注册为启动代理和启动守护进程。它的执行由 `Duet Activity Scheduler` 调度，这是一个基于系统活动和可用资源运行的后台任务调度器。

当 XProtect 进程运行时，它会向 `XProtectRemediatorService` 发送一个 XPC 请求，然后该服务会依次启动所有 XProtect 扫描器。

每个扫描器都包含自己的检测逻辑，这些逻辑使用检测构建器和所谓的 XProtect 插件 API 来实现。在检测文件时，扫描器还会收集文件的来源属性。这使它们能够识别每个被检测文件最初来自何处。最后，检测到的文件信息被报告回苹果。

## 扫描器初始化过程

每个 XProtect 扫描器都有一个名为 `__swift5_typeref` 的函数，该函数在其入口点之前运行。它的任务是解密敏感字符串，例如文件路径、YARA 规则和正则表达式。这些敏感字符串使用简单的异或密码进行加密。

解密这些字符串很重要，因为它能揭示每个 XProtect 扫描器的大量工作方式。Alden Shimizu 最初解密了这些字符串，他还为此提供了一个很好的 Binary Ninja 脚本。但有些字符串未能成功解密。他承认输出并不完美。因此，我开发了一个自定义的 LLDB 脚本来解密所有这些字符串。

以下是一些解密结果：我们可以看到诸如哈希值、文件路径、文本消息和 YARA 规则之类的字符串。

在 `__swift5_typeref` 函数完成后，扫描器移动到其入口点。在这个阶段，扫描器创建其插件图的一个实例。例如，在 `AR` 扫描器的情况下，它创建 `ARPlugin` 的一个实例。大多数 XProtect 扫描器只定义一个插件图。

然后，扫描器创建 `XPPluginHelpers` 的一个实例，并将其作为参数传递给插件的 `main` 函数。

那么，`XPPluginHelpers` 是什么？它提供对各种系统信息的访问。它的功能很大程度上可以从其属性名称推断出来。例如，它提供对启动服务、网络设置、钥匙串和进程内存内容的访问。

让我们仔细看看 `XPPluginHelpers` 中一个有趣的属性，它被称为 `alertDelegate` 属性。这个属性包含使用 `NSAlert` 向用户显示对话框的方法。我对这个属性的存在感到惊讶，因为当前的 XPR 在检测文件时是静默进行的，不会通知用户。

在我的研究过程中，我还没有观察到 XPR 使用这个属性。但这个属性的存在表明，苹果可能在未来的更新中引入通知功能。

现在，执行最终会进入插件的 `main` 函数。这个函数创建 `XPRemediator` 类的一个实例，使用 `OSSignpost` 测量其性能数据，移除环境变量（这是针对漏洞利用的固定措施），验证 `XProtectRemediatorService` 的权限，并最终启用快速老化。

让我简要解释一下什么是快速老化，因为它似乎并不广为人知。这个功能在进程级别上抑制文件的访问时间更新。可以通过 `sysctl` 查看。XPR 似乎启用了这个功能，可能是为了提高性能或保存取证工件。在检测完成后，此功能被禁用。

## 检测逻辑实现

接下来，让我们看看 XPR 如何实现其检测逻辑。在这里，我将介绍一组称为检测构建器的领域特定语言，它有助于以简洁的方式描述检测逻辑。但在深入细节之前，我想先谈谈我对苹果为何决定引入自己的 DSL 的看法。为什么首先需要它？

检测逻辑有时可能很复杂。当它们变得复杂时，代码往往会变得非常冗长。例如，假设我们只想在满足以下所有条件时删除一个文件：目标文件位于 `~/Library/Application Support` 目录中；其文件大小为 2 MB 或更小；其格式为 Mach-O 且未经过公证；它匹配特定的 YARA 规则；并且如果扫描器以 root 身份运行，还应扫描一个额外的目录。

为了实现这个逻辑，我们可能会编写类似这样的代码：首先，枚举 `~/Library/Application Support` 目录下的文件。然后过滤出大小为 2 MB 或更小的文件。接着将它们缩小到仅包含 Mach-O 文件。然后检查哪些文件未经过公证，找到与 YARA 规则匹配的文件。如果我们还想在扫描器以 root 身份运行时扫描额外的目录，我们需要用额外的条件复制这个循环。

这种方法可行，但在可读性和可维护性方面并不理想。如果你想添加另一个条件，你必须插入另一个 `if` 语句，使代码更加臃肿。

那么，我们如何才能更简洁地描述这个逻辑，同时保持其可维护性呢？我们的答案是使用 Swift 结果构建器。

那么，Swift 结果构建器到底是什么？它们是在 Swift 5.4 中引入的，旨在使编写领域特定语言更容易。如果你曾经使用过 SwiftUI，那么你已经使用过它们了。它们被用来描述用户界面。但它们不仅仅用于 UI。更一般地说，它们可以用来创建 DSL，用于组合多个元素并构建单个结果，例如 JSON、HTML 等结构化数据。在 XPR 中，苹果使用结果构建器将多个条件组合成最终的检测决策。

让我们看一个使用 Swift 结果构建器生成 HTML 的简单示例。如果你尝试用普通的 Swift 动态生成 HTML，你最终会得到非常冗长的代码，需要为每个元素声明中间变量，手动嵌套它们等等。在这个例子中，我们只想在 `useChapterTitles` 变量设置为 `true` 时添加一个特定的 `h1` 元素。为了描述这一点，我们声明了一个 `div` 变量，根据 `useChapterTitles` 变量的值，它可能包含一个 `header`。它包含了很多不必要的数据。仅仅看代码，很难判断最终生成的 HTML 结构会是什么样子。

现在，这是同一个例子，但这次是使用结果构建器提供的 DSL 实现的。它可读性高得多。你不需要声明不必要的中间变量。此外，生成的 HTML 的结构清晰地反映在 Swift 代码中。这两个代码块直接对应于两个 `div` 元素，甚至条件和哪些元素被添加都易于理解。例如，我们可以很容易地理解，只有当 `useChapterTitles` 变量设置为 `true` 时，才会添加这个 HTML 元素。这几乎就像编写你自己的模板引擎，但你是在使用 Swift 语言特性的 DSL 内部完成的。

那么，如果我们将这个想法应用到检测逻辑中会怎样？回想一下之前的例子，通过使用结果构建器提供的 DSL，我们可以更清晰地表达这个逻辑。这是相同逻辑的样子。你可以清楚地看到正在检查的文件函数：目标文件必须在 `~/Library/Application Support` 目录下；文件大小必须为 2 MB 或更小；文件格式必须是 Mach-O；必须未经过公证；并且必须匹配那个特定的 YARA 规则。当扫描器以 root 身份运行时，还会扫描额外的目录。它简洁、可读且易于维护，对吧？

这正是苹果所做的。XPR 附带了一组称为检测构建器的 DSL。它定义了几个构建器，每个构建器都提供了一个 DSL 来组合检测条件。例如，如果你想描述与文件相关的检测逻辑，可以使用 `FileRemediationBuilder` 提供的 DSL。其他 DSL 也可用，例如 `ProcessRemediationBuilder`、`ServiceRemediationBuilder` 和 `SoftwareUpdateExtensionRemediationBuilder`。

检测数据并非被所有 XProtect 扫描器使用。正如你在这里看到的，它被一部分扫描器使用，例如 `AR`、`BlueCargo`、`Copper` 等。其余的扫描器依赖于一个称为 XProtect 插件 API 的低级 API 来实现其功能。

我已经根据我的逆向工程记录了检测构建器 DSL 的规范，并将其发布在 GitHub 上。如果你对 DSL 如何工作以及有哪些类型的条件可用等细节感兴趣，请随时查看。

现在，让我展示几个实际例子来说明这个 DSL 是如何在实践中使用的。

首先，让我们看看 `XPR.AR`。这是一个使用 `FileRemediationBuilder` 的简单例子。正如你在幻灯片上看到的，只有当路径是 `/tmp/acre` 且文件大小为 68 字节或更大，并且匹配 `acre` YARA 规则时，才会删除文件。是的，很容易理解。

接下来，让我们看看使用 `ProcessRemediationBuilder` 的 `XPR.Alureon`。它只在进程未经过公证且其后台文件满足两个条件时才修复正在运行的进程：首先，文件路径必须包含某些字符串，如 `~/Library/Application Support` 或 `/tmp`；其次，文件必须匹配 `Alureon` YARA 规则。有趣的是，后台文件的条件可以使用 `FileRemediationBuilder` 来描述。

为了验证我的逆向工程结果，我实现了一个开源版本的检测构建器。它是 XPR.AR 行为的最小化实现。这个项目可以帮助你理解 Swift 结果构建器是如何被用来实现检测构建器的。

## 各扫描器检测逻辑详解

好了，现在让我们更仔细地看看每个扫描器的检测逻辑。让我们从 `XPR.LaunchAgent` 开始，它与 `XPR.RustBucket` 同时引入。`XPR.RustBucket` 旨在清除使用 3CX 供应链攻击的有效载荷。至于 `XPR.LaunchAgent`，其解密后的字符串只是两个哈希值。但这些有什么用呢？

这里的检测逻辑是使用检测数据描述的。正如我们所见，这两个哈希值是 CD 哈希。它被设计用来查找具有这些特定 CD 哈希的进程。第一个 CD 哈希是 `a0b...`。这是使用 3CX 供应链攻击的第二个阶段有效载荷，通常被称为 `UpgradeAgent`。这个样本由 Patrick Wardle 在两年前的 Black Hat USA 上展示过。第二个 CD 哈希仍然未知，但它很可能是 `UpgradeAgent` 的一个变体。据我所知，只有 `UpgradeAgent` 的一个版本被公开记录，我在之前的演讲中解释过。那个版本功能有限，它只向 C2 服务器发送系统信息，不执行任何进一步的操作。因此，Patrick Wardle 提出可能存在其他功能更强大的变体。这个未知的 CD 哈希可能支持他的假设，即可能存在其他功能更强大的 `UpgradeAgent` 版本。

接下来是 `XPR.BlueCargo`。其解密后的字符串似乎与修复无关，比如 `right click`、`click open`。那么这些有什么用呢？事实证明，它与我在本演讲开头提到的恶意软件有关。在开头，我简要提到了使用社会工程学手段禁用 Gatekeeper 的恶意软件。该磁盘映像的背景图像包含诸如 `right click` 和 `click open` 之类的字符串。这正是 `XPR.BlueCargo` 检测的内容：磁盘映像背景图像中的字符串。

`XPR.BlueCargo` 枚举系统上的多个磁盘映像，然后获取它们的背景图像，并使用 OCR 检索其中的文本字符串。之后，它搜索与 Gatekeeper 绕过相关的字符串，如 `Option click` 和 `right click, click open`。如果找到此类字符串，它会将包括磁盘映像信息在内的信息报告给苹果。

那么，`XPR.BlueCargo` 检测的是哪个恶意软件家族？老实说，我认为它并非针对任何特定的家族。事实上，`XPR.BlueCargo` 可以检测多个恶意软件家族使用的磁盘映像，例如 `Empire` 和 `Cobalt Strike`。因此，苹果可能打算将 `BlueCargo` 扩展为一种威胁狩猎扫描器，以帮助识别新出现的威胁。

有趣的是，`XPR.BlueCargo` 曾经有一个机制来检测没有后台文件的进程。正如这里所说明的，这个机制是使用检测构建器像这样实现的。这个机制已经被移除