![](img/53064134ada47a48c47d4cd9e93a838f_1.png)

# 课程 01: HTTP/1.1 必须消亡！反序列化攻击的终局 🎯

在本节课中，我们将探讨 HTTP/1.1 协议中一个根本性的安全缺陷——请求反序列化攻击。我们将了解为何这种攻击持续存在，探索新的攻击技术，并讨论如何从根本上解决这个问题。

---

![](img/53064134ada47a48c47d4cd9e93a838f_3.png)

## 协议的根本缺陷 🔍

上一节我们介绍了课程主题，本节中我们来看看 HTTP/1.1 协议的核心问题。

这一切始于 2019 年，当时我意识到 HTTP/1.1 存在一个致命缺陷：**各个 HTTP 请求之间的隔离性从根本上被破坏了**。

没有一个单一可靠的方法来确定一个请求在哪里结束，下一个请求在哪里开始。这意味着攻击者只要发现前端和后端之间存在最微小的解析差异，就能混淆请求的实际内容，从而引发反序列化攻击。这种攻击通常能让攻击者完全控制网站。

由于 HTTP/1.1 是一个古老、宽容、基于文本的协议，拥有成千上万种独特的实现，找到解析差异点并不困难。当时的感觉是，几乎可以攻击任何你想攻击的网站。例如，我曾展示过如何利用它两次持久性地攻破 PayPal 的登录页面。

我们知道解决方案是：**在前端和后端服务器之间的上游连接中使用 HTTP/2**，这几乎可以消除整个攻击类别。

---

![](img/53064134ada47a48c47d4cd9e93a838f_5.png)

## 六年后的现状：补丁与漏洞的错位 ⏳

上一节我们了解了问题的根源，本节中我们来看看六年后的现状。

那么，六年过去了，有什么变化？我们并没有开始为后端连接使用 HTTP/2。我们开始在客户端和前端之间使用 HTTP/2，但随后大多只是将这些请求降级为 HTTP/1.1 来与后端通信，这实际上使情况变得更糟。

![](img/53064134ada47a48c47d4cd9e93a838f_7.png)

然后，因为一些系统确实遭到了攻击，我们决定采用被称为**正则表达式**的终极安全措施来加固。

结果是一团糟。这是一个经典的反序列化检测探针。你发送两个请求，如果目标存在漏洞，那么第一个请求会毒化到后端的连接，意味着第二个请求的前缀会被加上橙色文本所示的内容。

如今，如果你在一个现代目标上尝试这个探针，它很可能会失败，即使目标实际上存在漏洞，因为它会被多个寻找 `Transfer-Encoding` 头的正则表达式拦截。

![](img/53064134ada47a48c47d4cd9e93a838f_9.png)

或者它会失败，因为那个检测小工具可能在该目标上不起作用，而我们没有使用很多不同的检测小工具。或者它会因为该策略涉及的众多竞态条件之一而失败。是的，还有一种基于超时的替代方法没有竞态条件问题，但它被正则表达式拦截得更严重。

![](img/53064134ada47a48c47d4cd9e93a838f_11.png)

总而言之，在过去的六年里，业界修补了检测方法，修补了扫描工具，但**实际的漏洞在很大程度上并没有被修复**。

![](img/53064134ada47a48c47d4cd9e93a838f_13.png)

---

## 反序列化攻击的终局：表面安全下的危机 🎲

上一节我们看到漏洞依然存在，本节中我们来看看这创造的“终局”局面。

![](img/53064134ada47a48c47d4cd9e93a838f_15.png)

这创造了反序列化攻击的“终局”，乍一看一切似乎都很安全，但如果你对方法做最微小的改变，事情就会迅速变得有趣。

让我们看一个例子。几个月前，我收到 Vans 的邮件，说他发现了一个令人困惑的漏洞，想听听我的看法。

![](img/53064134ada47a48c47d4cd9e93a838f_17.png)

他尝试的攻击很普通。你发送这样的请求，它被降级为 HTTP/1.1，毒化了到后端的连接。因此，下一个访问该漏洞网站的用户会被重定向到我们的网站。由于缓存，这个重定向会被保存，所以我们可以重定向 JavaScript 文件，保存它，并持久地控制网站上的任何页面。

它运行得非常好，除了一件小事：**被劫持的用户实际上并没有试图访问目标网站**。

攻击实际上危害了随机的第三方网站，包括银行等。这有点奇怪。

显然，服务器设置不是这样的。它一定更复杂。

![](img/53064134ada47a48c47d4cd9e93a838f_19.png)

在分析了目标基础设施后，我认为，这一定是 Cloudflare 前端和 Heroku 的前端反向代理之间的反序列化，所以我们一定是在利用 Heroku 上托管的随机网站。

![](img/53064134ada47a48c47d4cd9e93a838f_21.png)

然而，这个分析完全错误，因为同样地，那太简单了。

当我尝试复现攻击时意识到了这一点，我想，等等，他在这里犯了个错误。请求被 Cloudflare 的缓存拦截了，这意味着攻击甚至从未到达 Heroku。

所以我通过添加一个缓存破坏参数纠正了他的错误。然后攻击就停止了。

![](img/53064134ada47a48c47d4cd9e93a838f_23.png)

这意味着什么？这意味着 Heroku 与此无关。有一段时间，如果你正确测试任何 Cloudflare 网站，你什么也发现不了。但如果你忘了指定缓存破坏参数，那么你就会在 Cloudflare 自己的基础设施内引发反序列化，使你能够持久地危害几乎每一个使用 Cloudflare 的网站。

这就是反序列化攻击的终局。看起来一切安全，但你犯一个错误，结果就攻破了 2400 万个网站。

---

![](img/53064134ada47a48c47d4cd9e93a838f_25.png)

## 为何此类漏洞持续存在？复杂性与根本原因 🧩

上一节我们看到了一个惊人的案例，本节中我们来探讨这类漏洞为何持续存在。

![](img/53064134ada47a48c47d4cd9e93a838f_27.png)

这样的漏洞是如何发生的？部分原因是所涉及系统的过度复杂性。例如，在这个案例中，Cloudflare 通过 HTTP/2 接收请求，然后将其转换为 HTTP/1.1 供内部使用，接着又转换回 HTTP/2 用于上游连接。

但根本问题来自基础。

![](img/53064134ada47a48c47d4cd9e93a838f_29.png)

有一种观念认为 HTTP/1.1 是一种像 TCP 一样的简单架构级事物，可以依赖。我们认为它是安全的，因为我们知道简单的东西往往更安全。

但实际上，一旦你尝试代理 HTTP，它就不再简单，变得非常复杂。为了说明这一点，以下是我个人曾经相信的关于 HTTP/1.1 的五个谎言。

本节中的每一个谎言都将被用于一次漏洞利用。

当结合时，最后三个谎言意味着你的代理需要状态，只是为了从后端读取正确数量的字节。你甚至需要在到达正文之前，就为读取头部块进行特殊处理。整个响应可能在客户端请求接收完之前就已经到达。

这就是 HTTP/1.1。它是 Web 的基础。它由暴露数百万网站的地雷构成，而我们花了六年时间证明我们无法修复它。

![](img/53064134ada47a48c47d4cd9e93a838f_31.png)

它需要消亡。

---

## 如何终结它？推广 HTTP/2/3 🚀

上一节我们明确了问题的严重性，本节中我们来看看解决方案。

![](img/53064134ada47a48c47d4cd9e93a838f_33.png)

那么，我们如何终结它？我们需要共同向世界展示，上游的 HTTP/1.1 是不安全的，更多的反序列化攻击总会到来。在本节的剩余部分，我将展示如何做到这一点。

首先，我将介绍一个新的工具包来处理反序列化攻击的终局。然后，我将分享两个全新的攻击类别，暴露数百万更多的网站。接着，我将重点看看我们如何摆脱这种困境。最后，我将总结并在后面回答一些问题。

在本节中，我将大致按时间顺序跟随研究历程。所以在开始时，我们将获得知识，但不会有太多漏洞赏金之类的东西。但随着这些知识将我们带到超越现有技术水平的地方，事情将迅速变得有利可图得多。

本节中提到的所有赏金已在所有相关人员之间平均分配，我所得部分的 100% 已由 PortSwigger 加倍并捐赠给当地慈善机构，所有命名目标中的漏洞均已解决。

![](img/53064134ada47a48c47d4cd9e93a838f_35.png)

---

## 赢得终局：新工具与检测方法 🛠️

上一节我们概述了行动路线，本节中我们来看看赢得终局的具体方法。

要在反序列化攻击的终局中获胜，基本上，规则 0 是不要使用 `Transfer-Encoding`。但要取得任何进展，我们需要一种可靠的方法来检测解析差异，且不会被正则表达式拦截。

![](img/53064134ada47a48c47d4cd9e93a838f_37.png)

早在 2021 年 BlackHat Europe 的一次演讲中，Daniel Thatcher 给了我们一个方法。我对他的演讲中的概念感到非常兴奋，以至于我从头开始实现了一个自己更强大的版本。我很高兴今天在 **HTTP Request Smuggler 版本 3** 中发布它。这是一个开源的 Burp Suite 扩展，完全兼容专业版、企业版和免费的社区版。

![](img/53064134ada47a48c47d4cd9e93a838f_39.png)

简而言之，这个工具使用广泛的技术来分析和分类目标前端和后端如何解析请求，并找到差异。

例如，在这个目标上，通过查看响应状态码，我们可以看到，如果我们使用空格来掩盖 `Host` 头，会得到一个独特的结果，这与我们完全省略 `Host` 头得到的结果不同。从这一点，加上显示的其他响应，我们可以推断出我们找到了一个解析差异。

我称之为“可见隐藏差异”，因为被掩盖的头部对前端可见，但对后端隐藏。通常，你可以通过隐藏 `Content-Length` 头，将这些差异转化为经典的 CL.0 反序列化攻击。

但关键的是，如果在构建该漏洞利用时遇到任何问题，你可以调整并处理它们，因为你已经找到了根本缺陷。例如，在另一个目标上，他们拒绝带有正文的 GET 请求，但我能够通过切换方法为 `OPTIONS` 来轻松处理这个问题。

正是这种克服障碍的灵活性使这种方法如此有价值。

此外，通过结合广泛的不同头部、排列和策略，它可以实现非常好的覆盖率。例如，这里我们仍然使用 `Host` 头作为检测小工具，并用前导空格隐藏它。但这次，我们发送一个带有错误格式值的重复 `Host` 头。利用这一点，我们在一个银行使用的 Web VPN 上发现了反序列化。

![](img/53064134ada47a48c47d4cd9e93a838f_41.png)

这种策略甚至让你可以预测漏洞。例如，HTTP RFC 允许单独接受 `\r` 作为行终止符，而工具发现这个特定的服务器不遵守这一点。这意味着如果你将该服务器放在某些代理后面，攻击者可能引发关于正文起始位置的争议，并导致反序列化。当然，那个特定目标不是你会放在代理后面的那种东西。

但我们能够将漏洞追溯到底层 HTTP 库，它被许多不同的系统使用。不幸的是，我不能说出它的名字，因为补丁尚未发布。

该工具还标记了大量在 Amazon 应用负载均衡器后面运行 Microsoft IIS 的服务器。

现在，如果你看这里的服务器标识，你会发现解析差异的发生方向相反：是前端看不到头部，后端能看到，使其成为“隐藏可见差异”。此外，这些目标受到 AWS 的 HTTP 反序列化防护器的保护。当我看到这个时，我想，好吧，这东西有点棘手，我先把它放一边，以后再说。

![](img/53064134ada47a48c47d4cd9e93a838f_43.png)

当它在我架子上积灰时，Thomas Stacy 独立发现了同样的问题，并绕过了反序列化防护器，实现了一个 H2.TE 反序列化。干得好，Thomas。AWS 现在已经修补了那个问题，但他们只修补了反序列化防护器的绕过。底层的解析差异仍然存在。所以你仍然可以利用这个来伪造你的 IP 地址，有时绕过访问控制。如果你想修补它，可以通过更改负载均衡器上的几个设置来实现。

![](img/53064134ada47a48c47d4cd9e93a838f_45.png)

当我看到这个时，我联系了 AWS 说，等等，你们明明有修复这个的设置，为什么不默认修补它？

他们的回应是，他们的客户有一些古老的 HTTP 客户端无法更改，并且依赖于发送格式错误的 HTTP 请求。这就是他们无法修复的原因。所以基本上，如果你使用云代理，你就是将别人的技术债务导入到你自己的安全状况中。

这个发现是事情开始变得非常有趣的地方。现在，我很遗憾不能说出这个目标的名字，因为我将在接下来的 10 分钟里谈论它。所以让我们称它为“目标 X”。这只是另一个隐藏可见的反序列化。但使用 `Transfer-Encoding` 的明显漏洞利用不起作用，这要归功于 Web 应用防火墙之类的东西。所以它迫使我问：我们如何在这个目标上引发反序列化？如果我们向一个存在隐藏可见差异的目标走私一个 `Content-Length` 会发生什么？我想那将是 CL.0 反序列化，这是被广泛认为不可能的事情。

---

## 突破“不可能”：零内容长度反序列化攻击 ⚡

上一节我们遇到了一个看似无法利用的漏洞，本节中我们来看看如何突破这个限制。

这是因为当前端看不到 `Content-Length` 头时，它只将头部转发给后端，然后后端在等待正文到达时超时。换句话说，一旦你尝试攻击，就会得到服务器端连接死锁，这对于使网站瘫痪很好，但对于反序列化攻击就没那么有用了。

![](img/53064134ada47a48c47d4cd9e93a838f_47.png)

我偶然发现了这个问题的解决方案。去年，在研究定时攻击时，每当我尝试计算由 Nginx 提供的静态文件加载所需时间，我会得到一个负的响应时间，因为 Nginx 在我完成发送请求之前就响应了我的请求。

这是一个巨大的麻烦，我必须做一个复杂的变通方法才能使定时技术工作，但它表明有时服务器确实会在请求完成之前响应，这将让我们摆脱这个死锁。

![](img/53064134ada47a48c47d4cd9e93a838f_49.png)

![](img/53064134ada47a48c47d4cd9e93a838f_50.png)

不幸的是，这个目标运行的是 IIS 而不是 Nginx。那么，如何让 IIS 在不关闭连接的情况下提前响应你的请求呢？

文档是个好东西。这是一个很好的例子来说明为什么。在 Windows 上，如果你对文件或文件夹使用某些名称，平台会认为你指的是串行控制台或设备驱动程序并崩溃。那么，如果我们在运行 Windows 的服务器上访问那个路径会发生什么？你会遇到一个特殊的代码路径，使服务器提前响应而不等待正文，从而摆脱连接死锁。

![](img/53064134ada47a48c47d4cd9e93a838f_52.png)

这意味着当下一个请求到达服务器时，后端最终会从开头切掉一些数据，你可能会得到一个 400 错误请求响应。

看到这个发生，我立刻情绪激动，原因有二。首先，我知道那个 `/con` 怪癖已经超过 10 年了，但这是我第一次真正找到它的有效用途，使它可能是我做过的最慢的漏洞利用。其次，在过去的六年里，在进行反序列化研究时，我看到了太多无法解释的 400 错误请求响应，我实际上把它们都作为“我的 400 发现”报告了。当我看到这个时，我意识到所有这些发现很可能都是可利用的。

所以，如果你想进行 CL.0 反序列化，首先需要的是在目标服务器上找到一个提前响应的小工具，一种让它提前响应的方法。一旦你做到了，就该开始着手漏洞利用了。

![](img/53064134ada47a48c47d4cd9e93a838f_54.png)

如果你在第二个请求的头部块内嵌套第二个请求行，并调整第一个请求的 `Content-Length`，你可以切掉它之前的所有内容，并“解锁”它，如图所示。这很好，因为它让我们超越了 400 错误请求响应，但这还不是一个现实的攻击。我们不能假设受害者自己的请求中恰好有一个用于攻击他们自己的有效载荷。

我们需要的是将我们的有效载荷添加到他们的请求中的方法，而不是仅仅丢弃部分内容。

![](img/53064134ada47a48c47d4cd9e93a838f_56.png)

---

![](img/53064134ada47a48c47d4cd9e93a838f_58.png)

## 双重反序列化：构建现实攻击链 🔗

上一节我们找到了提前响应的方法，本节中我们来看看如何构建一个现实的攻击链。

我们可以通过双重反序列化来实现这一点。事情在这里变得有点复杂。

这是一个两阶段攻击，其中第一个请求引发 CL.0 反序列化，然后武器化第二个请求（也来自攻击者）以引发 CL.0 反序列化，接着利用第三个请求（来自受害者）。

最清晰的概念性方法是让第一阶段的有效载荷切掉第二阶段有效载荷的头部，如图所示。然而，虽然这在理论上可行，但在现实中，它基本上总是失败，因为前端服务器倾向于在将请求转发到后端之前注入额外的头部，这使你的长度计算不正确并破坏攻击。

![](img/53064134ada47a48c47d4cd9e93a838f_60.png)

我写了一个脚本来暴力破解注入头部的长度，但这仍然不理想，因为这些头部通常包含可变值，如你的 IP 地址，这意味着你的攻击可能在你把它交给别人复现时就停止工作。这不理想。

幸运的是，有更好的方法。

它们倾向于在头部块的末尾注入头部。所以如果我们的有效载荷在那之前开始，我们的攻击虽然现在看起来有点丑陋和混乱，但会更可靠。在这个特定的例子中，我将该技术与输入反射链接起来，以揭示注入头部的值。

因此，通过将其与经典的 HEAD 技术（将两个响应合并为一个）结合，我能够向随机在线用户提供恶意 JavaScript 并劫持他们的账户。

这个过程涉及某种竞态条件，所以只有当你每秒发送至少几百个请求时才有效。但除此之外，它相当直接。

事情变得有点复杂，但好消息是我们刚刚发布了一个 Web 安全学院实验，所以你可以免费在一个实时系统上自己练习整个攻击链。

![](img/53064134ada47a48c47d4cd9e93a838f_62.png)

使用该技术，我们能够利用相当数量的目标，尽管我们实际上被其他事情分心了，所以我们在影响方面有点敷衍，将它们全部报告为拒绝服务问题，没有得到多少报酬，但我们仍然获得了不错的回报。

这里值得注意的是，大多数这些目标之所以存在漏洞，是因为它们有 Web 应用防火墙，而防火墙正是引入反序列化漏洞的东西。

在这一点上，我想，太好了，我们完成了。反序列化威胁终于被完全描绘出来了，未来的任何问题或新技术都将是奇怪的利基问题，而不是大的类别突破。

这是我每年都会犯的错误。下一个发现让我最终意识到真相，那就是：**更多的反序列化攻击总会到来**。

早在 2022 年，我尝试用 `Expect` 头引发反序列化漏洞利用。事实证明，我看得远远不够仔细。

![](img/53064134ada47a48c47d4cd9e93a838f_64.png)

`Expect` 头很特别的第一个线索是它立刻破坏了我的 HTTP 客户端 Turbo Intruder。修复这个问题给代码的敏感部分引入了大量复杂性。当某物给服务器或客户端带来复杂性时，你知道对于代理来说总是会更糟。

`Expect` 应该将发送请求分解为一个两部分的过程，以便客户端可以提前退出，从而节省带宽。这个头就是这么古老。它所做的，是在服务器和代理代码中一个以前不需要状态的区域引入了状态，因此引发了一大堆边缘情况，基本上让一切以一系列壮观的方式崩溃。

---

## Expect 头：被忽视的攻击面 💥

上一节我们提到了 Expect 头，本节中我们深入探索这个被忽视的攻击面。

![](img/53064134ada47a48c47d4cd9e93a838f_66.png)

这是一个温和的例子。在这个网站上，HEAD 请求（一个特例）工作正常，`Expect` 也工作正常，但如果你将两者结合，服务器会忘记它是一个 HEAD 请求，意味着它们试图从后端读取太多字节，导致服务器端死锁。

这是你可以预测的那种缺陷。但你也会发现不那么可预测的缺陷，例如在多个不同的服务器上，发送 `Expect` 头只会让它们泄漏内存，包括密钥。

![](img/53064134ada47a48c47d4cd9e93a838f_68.png)

不幸的是，当我去报告那个时，我发现他们最近关闭了他们的漏洞赏金计划。

因为 `Expect` 头触发两个响应头部块，它经常破坏移除敏感响应头部的尝试，以向最终用户隐藏它们。所以它做的是，你发送 `Expect`，就会暴露一大堆额外的内部头部，比如这些在每个使用 Netlify CDN 的目标上都可用的头部。

![](img/53064134ada47a48c47d4cd9e93a838f_70.png)

当我向 Netlify 报告时，我得到了一个有点出乎意料的回应，他们说这是一个功能，但还是为此付了钱。我们很快就会再次看到 Netlify。

大约在这个时候，我收到一个全职漏洞赏金猎人小团队的消息。他们也注意到 `Expect` 头正在让有趣的事情发生。

![](img/53064134ada47a48c47d4cd9e93a838f_72.png)

通常，研究碰撞不是好消息。事实上，我们有一些非常好的研究样本，计划提交给 Black Hat USA，但由于研究碰撞，我们基本上不得不取消。

但我已经听说过这些好人，因为他们在 T.0 请求走私方面的研究。我想，既然他们知道自己在做什么，并且已经知道这个技术，我们为什么不合作呢？有了他们的帮助，我可能会得到更多案例研究；有了我的帮助，他们应该能赚更多钱。

所以我们合作了，并立即发现，仅仅发送一个普通的 `Expect` 头就会在许多目标上引发 CL.0 反序列化。

![](img/53064134ada47a48c47d4cd9e93a838f_74.png)

我认为这是由于一个错误造成的：当前端服务器从后端收到响应时，它忘记了自己还没有从客户端收到正文。我选择这个特定的例子是因为它是一个很好的互动，T-Mobile 给了我们 12000 美元的赏金，即使这只影响了一个预生产服务器。所以我将来肯定会对他们进行彻底的测试。

![](img/53064134ada47a48c47d4cd9e93a838f_76.png)

![](img/53064134ada47a48c47d4cd9e93a838f_78.png)

我发现了许多这个问题的案例，但这个特别有趣，原因有二。首先，它只有在你混淆 `Expect` 头值时才有效。其次，这个域名保存着发送给 GitLab 漏洞赏金计划的漏洞报告的附件。有趣的东西。

所以在这个目标上，我们选择了进行响应