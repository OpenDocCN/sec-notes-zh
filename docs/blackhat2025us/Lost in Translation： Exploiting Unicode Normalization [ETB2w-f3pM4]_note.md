# 课程：利用Unicode规范化绕过安全检测 [ETB2w-f3pM4] 🔐

在本节课中，我们将学习Unicode规范化如何被攻击者利用来绕过Web应用的安全检测。我们将通过“传话游戏”的类比，理解数据在多层处理流程中如何被意外改变，从而引发安全漏洞。课程将涵盖解码错误、混淆字符、大小写转换和组合字符等核心概念，并提供实用的工具和案例研究。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_1.png)

---

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_3.png)

## 概述：Web传话游戏 📞

上一节我们介绍了课程的整体目标。本节中，我们来看看问题的核心类比。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_5.png)

想象一个“传话游戏”：一个人说一句话，经过多人传递后，最终的话可能变得面目全非。Web应用的数据处理流程与此类似。

一个Web请求从客户端发出，会经过多个中间系统（如CDN、WAF、应用服务器等），每个系统都可能对数据进行处理或安全检查。问题在于，**安全检查之后**，数据可能被后续处理逻辑（如解码、规范化、转换）意外改变，从而将一个原本无害的输入变成有效的攻击载荷。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_7.png)

这种**处理顺序问题**是许多安全漏洞的根源，对应通用缺陷枚举CWE-180。

---

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_9.png)

## 第一部分：解码错误 🔍

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_11.png)

上一节我们了解了处理流程错位的问题。本节中我们来看看第一类具体问题：解码错误。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_13.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_15.png)

当系统在处理Unicode（多字节）和ASCII（单字节）字符之间的转换时，如果缺乏“多字节感知”，就会产生解码错误，可能导致数据被误解。

### 多字节感知与CWE-172

Unicode字符长度可变（多字节），而ASCII是单字节。系统在转换时如果错误处理字节长度，就会产生乱码（Mojibake）。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_17.png)

**核心概念**：一个多字节Unicode字符（如`<`）的UTF-8编码是 `%C2%BC`。如果一个解码器不是多字节感知的，它可能会将 `%C2` 和 `%BC` 当作两个独立的单字节ASCII字符解码，产生乱码，而不是原字符。

以下是使用Burp Suite Decoder插件的对比：
*   **无多字节感知**：输入 `%C2%BC` 可能输出三个无关的Unicode字符（乱码）。
*   **有多字节感知（如Decoder Improved插件）**：正确解码并显示 `<` 字符。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_19.png)

### 过长编码与KPEC-80

过长编码是指用多于必要的字节数来表示一个字符（例如，用两个字节表示原本只需一个字节的ASCII字符‘A’）。早期UTF-8允许这样做，但现在被视为无效。问题在于，应用程序会如何响应这种编码？是阻止、正确规范化，还是产生乱码？

**历史案例**：2001年的Nimda蠕虫就利用了过长编码（将 `../` 编码）来绕过一些简单的目录遍历检测过滤器。

**现代工具利用**：SQLMap等工具的篡改脚本会使用过长编码来混淆空格等字符，尝试绕过安全检测。

例如，一个正则表达式 `select\s+from` 用于检测SQL注入。如果攻击者使用过长编码的“空格”（非单字节），而安全检查前未正确解码，则检测会失败。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_21.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_22.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_24.png)

### 字节截断

当系统为字符串分配固定长度的缓冲区（如单字节），但遇到多字节字符时，可能只存储第一个（或最后一个）字节，丢弃其余部分，这就是字节截断。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_26.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_27.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_29.png)

**案例研究**：攻击者向Microsoft端点提交UTF-8编码的“回车换行符”（`%E2%80%A8%E2%80%A9`）。安全检查将其视为中文字符而放行。但后端处理时，如果使用单字节缓冲区并以小端序存储，则可能只存储了`%A8`和`%A9`这两个最低有效字节，它们恰好对应ASCII的回车（CR）和换行（LF）符，从而成功注入了HTTP头。

**测试工具**：
*   **CyberChef**：使用“Encode text”配方并选择“ASCII 7-bit”可以模拟服务器端的字节截断。
*   **Shazzar**：输入一个十六进制值，可以找出哪些Unicode字符截断后会变成该值。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_31.png)

---

## 第二部分：混淆字符（视觉欺骗） 👁️

上一节我们探讨了因解码产生的漏洞。本节中我们来看看另一类问题：视觉上相似的字符。

这不是指钓鱼攻击中的域名欺骗，而是指Web应用层将输入的Unicode字符“最佳匹配”或“规范化”为视觉相似的ASCII字符。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_33.png)

### 规范化形式与最佳匹配映射

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_35.png)

当应用收到非ASCII字符（如希腊字母Alpha `Α`）但只接受ASCII时，它可能会将其“映射”为看起来相似的ASCII字符（如字母`A`）。这种映射可能由Unicode规范化形式（如NFKD）或特定代码页（如Windows-1252）完成。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_37.png)

**案例研究：.NET Nuke漏洞**
1.  攻击者上传文件，文件名包含**全角**的斜杠和点（看起来像`\`和`.`，但实际是Unicode字符）。
2.  应用使用正则表达式检查文件名，寻找ASCII的点字符以阻止路径遍历。由于文件名是Unicode字符，检测通过。
3.  随后，应用使用代码页1252进行“最佳匹配映射”，将全角字符转换回标准的ASCII反斜杠和点。
4.  此时，文件名变成了有效的UNC路径（如`\\oaasify.burpcollaborator.net\...`），导致应用向攻击者控制的服务器发起出站连接，可能泄露凭证。

**测试工具**：
*   **Unicode实用工具**：在Unicode官网可以输入一个ASCII字符，查询所有能规范化回该字符的Unicode变体。
*   **ActiveScan++更新**：包含“可疑输入转换”检查。它在输入中插入特殊的Unicode字符（如开尔文符号`K`），如果响应中该字符被转换为ASCII的`K`，则表明存在规范化操作，值得深入调查。

---

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_39.png)

## 第三部分：大小写转换 🔠

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_41.png)

上一节我们了解了字符的视觉映射。本节中我们来看看大小写转换可能带来的问题。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_43.png)

应用可能对输入进行大小写转换（如转为大写）以实现标准化。但某些Unicode字符在进行大小写转换时，会变成完全不同的、在浏览器中可执行的字符。

**案例**：攻击者输入包含`ı`（拉丁文无点小写I）的字符串。安全检查寻找`<script>`标签，由于字符不同，检测通过。
随后，应用对输入执行`uppercase()`操作。在特定语言环境下，`ı`的大写形式是`I`。于是，原本无害的`<scrıpt>`在转换后变成了可被浏览器执行的`<script>`标签。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_45.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_47.png)

**核心要点**：任何进行大小写转换的地方都可能存在此类映射风险。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_49.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_51.png)

**测试工具**：
*   **Python演示**：`payload = “<scrıpt>”.encode(‘utf-8’).decode(‘utf-8’).upper()` 会输出`<SCRIPT>`。
*   **ReCollapse工具更新**：新增了标志位，可以生成在大小写转换后能映射到目标字符的不同Unicode字符变体，用于测试。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_53.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_54.png)

---

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_56.png)

## 第四部分：组合字符（组合变音符号） ✨

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_58.png)

上一节我们讨论了字符转换的风险。最后，我们来看看最精妙的一类：组合字符。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_60.png)

Unicode可以将一个带音调的字符（如`á`）分解（规范化形式NFD）为两个码点：基础字符（`a`）加上一个组合变音符号（` ́`）。这种特性可能被用于欺骗数据库或修改上下文。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_62.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_63.png)

### 案例研究1：零点击账户接管

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_65.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_66.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_67.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_69.png)

在密码重置流程中：
1.  攻击者使用邮箱 `attacker@gmail.com`（注意`a`是带双重重音的Unicode字符）请求重置受害者的密码 `victim@gmail.com`。
2.  数据库使用“口音不敏感”的排序规则（如 `utf8mb4_0900_ai_ci`）。它认为 `attacker@gmail.com` 等价于 `attacker@gmail.com`。
3.  数据库确认用户存在，生成重置令牌。
4.  **关键**：令牌被发送到**攻击者提供的**邮箱（`attacker@gmail.com`），而不是数据库里存储的受害者的标准邮箱。攻击者从而接管了受害者账户。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_70.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_72.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_73.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_75.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_76.png)

### 案例研究2：通过组合字符实现XSS

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_78.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_79.png)

在一个XSS实验室中，用户输入被放在 `<textarea>` 标签之后：`<textarea>用户输入</textarea>`。
攻击目标是让“用户输入”与前面的 `>` 符号结合，改变HTML上下文。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_81.png)

**利用过程**：
1.  攻击者输入一个组合字符“长竖线叠加符”（`̸`）。
2.  后端处理时，这个组合字符与前面的 `>` 符号进行组合。
3.  组合后的结果变成了“不大于”符号（`≯`）。
4.  这破坏了 `<textarea>` 的闭合，使得攻击者可以在其后注入JavaScript代码（如 `onfocus=alert(1) autofocus`），从而执行XSS攻击。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_83.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_84.png)

**工具更新**：ActiveScan++也增加了对此类组合字符的检测，寻找输入是否能与上下文字符组合成新字符的迹象。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_86.png)

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_88.png)

---

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_90.png)

## 总结与要点 ✅

本节课中我们一起学习了Unicode规范化如何被利用来绕过Web安全检测。

**核心要点总结**：
1.  **首要问题（CWE-180）**：**安全检查在数据转换之后进行**是根本原因。必须确保安全逻辑在处理链上的正确顺序。
2.  **验证解码流程**：确保URL解码、字符集转换在任何安全过滤**之前**正确完成，且系统具备多字节感知能力。
3.  **了解规范化行为**：查明应用程序使用了哪种Unicode规范化形式或代码页，并评估将Unicode转换为ASCII的“最佳匹配”行为是否带来风险。
4.  **注意内置转换**：警惕那些可能隐式进行大小写转换、口音折叠或字符组合的第三方库、数据库排序规则和框架功能。
5.  **利用更新工具**：使用Burp Suite ActiveScan++、ReCollapse等工具的更新版本，可以帮助自动化探测这些复杂的Unicode处理问题。

![](img/8ed1dc8bacc61f39b2090cdcd6e32f17_92.png)

对于防御者和漏洞猎人而言，理解这些模式有助于发现和修复此类深层次的Unicode相关问题。