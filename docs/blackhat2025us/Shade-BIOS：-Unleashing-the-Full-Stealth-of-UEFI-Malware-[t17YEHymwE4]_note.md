# 课程：释放UEFI恶意软件的完全隐身能力 [t17YEHymwE4] 🔓

## 概述

在本节课中，我们将探讨如何使UEFI恶意软件（UFMO）更加隐蔽，以及如何检测这些隐身的UEFI威胁。我们将深入分析现有UEFI恶意软件的局限性，并介绍一种名为“Shade BIOS”的新技术，它能够克服这些限制，实现更纯粹、更隐蔽的固件级攻击。

---

## 引言

我是Kasuki Mato，来自日本安全厂商FFR Security的研究员。我的主要研究方向是固件安全，特别是EFI/BIOS安全。在G5安全领域，一个普遍的观点是：感染固件是“杀鸡用牛刀”，通常感染内核层就足够了。这对于以普通公司为目标的攻击者来说确实如此，但固件安全在以下两个领域尤为重要。

---

## 固件安全的重要性

### 1. 国家安全相关攻击 🛡️

这类恶意软件必须尽可能隐蔽。此外，BIOS是安装后门的合理位置。与主要由单一公司制造的操作系统、虚拟机管理程序或CPU不同，BIOS由许多供应商实现，这使其成为安装后门的合适目标。操作系统和虚拟机管理程序在制造过程中并不存在，因此将后门置于BIOS中是合理的选择。从Vault 7等泄露文件可以看出，UEFI安全在国家安全背景下被认为非常重要。

### 2. 云安全 ☁️

原则上，BIOS比虚拟机管理程序拥有更高的权限，因为它执行得更早。因此，BIOS有潜力破坏虚拟机管理程序，并影响云服务上的所有虚拟机。现有研究表明，虚拟机管理程序与BIOS恶意软件之间存在激烈的对抗。

---

## 现有UEFI威胁的现状

UEFI威胁并非理论，现实中存在UEFI恶意软件。目前总共存在大约九个已知的引导套件，数量不算多。因此，EFI恶意软件能做的事情也未被充分评估。

这些引导套件有一个共同的重要特征：它们最终在用户态或内核态执行恶意行为。它们并非纯粹的BIOS恶意软件，只是支持用户态/内核态恶意行为的引导套件。我们认为这对UEFI恶意软件来说是一个重大挑战，因为这意味着它们最终仍然依赖于操作系统的安全机制。

除了引导套件，还有一些泄露的BIOS后门，如JetT或Vector EDK。其中一些是纯粹的BIOS恶意软件，意味着它们仅在BIOS中执行恶意活动。然而，这些后门都存在相同的问题：它们只支持非常特定的目标。研究领域的未来因素也是如此，这都是由于其设备特定的实现方式。

**总结来说，现有的UEFI恶意软件普遍受到操作系统依赖性和硬件/设备依赖性的困扰。**

---

## 操作系统依赖性问题

现有的UEFI引导套件可以禁用任何操作系统安全机制，它们实际上也是这么做的。例如，ES Specter Boot禁用驱动程序签名强制，Cosmic Strand Boot禁用补丁防护。

然而，它们仍然依赖于地球全局安全，因为如果不知道目标上运行的是什么杀毒软件，它们会被杀毒软件的内核驱动程序检测到。此外，除非它们禁用所有操作系统安全机制，否则它们会被其他操作系统安全机制检测到。而且，现有的引导套件在内核镜像和引导加载程序镜像的钩子中大量使用模式匹配，因此每次操作系统更新时，后门都必须更新。

**因此，现有的UEFI引导套件仍然存在被上层安全机制检测到的风险。**

从攻击者的角度来看，既然我们已经控制了更底层的BIOS，就不应该再关心操作系统。但为什么每个现有的UEFI引导套件首先都要使用用户态/内核态呢？为什么不把所有功能都实现在BIOS代码中？

---

## 硬件依赖性问题

这个问题的关键在于，攻击者想要的秘密或任何数据，只有在操作系统启动后才存在。也就是说，在引导阶段没有任何有趣的东西。然而，大多数BIOS环境在操作系统启动时就被销毁了。例如，EFI引导服务（如分配页面）不再可用，因此BIOS代码无法使用内存管理器。此外，UEFI协议（如HTTP协议或磁盘I/O协议）都被销毁，因此没有访问设备的接口。

因此，从操作系统启动后运行的BIOS代码中，很难与C2服务器通信或读取文件等。攻击者可以直接执行I/O操作，但这很困难，因为它们本质上必须实现完整的驱动程序栈。而且，即使它们设法做到了，实现也会变得非常设备特定，因此只能在非常特定的设备上工作。

这就是为什么现有的BIOS后门都是硬件依赖的，并且只支持非常特定的目标。例如，Steady Bound文档说明它只适用于Dell PowerEdge服务器。iChe引导套件只支持特定版本的HP iLO服务器。研究领域的BIOS恶意软件也是如此。

有一些纯粹在BIOS内实现的SMM后门，但如果你查看这些实现，它们必须直接访问硬件寄存器。直接访问寄存器意味着攻击者必须知道目标设备是什么，找到该设备的规格，并根据该规格读写这些寄存器。幸运的是，在这种情况下，设备是USB主机控制器，而USB有标准化规范，因此依赖性不那么严格。但这对于不使用USB的其他设备（如网络接口卡）无效。

---

## 现有BIOS恶意软件的困境总结

到目前为止，现有的BIOS恶意软件面临硬件和操作系统依赖性的困境。如果恶意软件试图在BIOS代码中执行所有操作，那么实现将变得非常设备特定，并且只能在特定的攻击目标上工作。这是由于缺乏访问设备的抽象接口。这些接口存在于操作系统或用户态运行时中，因此恶意软件可以使用它们。但这样一来，实现就会变得依赖于操作系统，并且可以被上层安全机制检测到。

**因此，虽然据说攻击者控制了BIOS就可以为所欲为，但实际上这个困境限制了BIOS恶意软件能做的事情。**

此外，平台安全正在迅速发展，我们也必须考虑它们。大多数现有的BIOS恶意软件是作为SMM模块实现的。但随着称为SMM隔离的最新安全机制，这些将不再有效。SMM曾被称为环-2，因为它可以在操作系统运行时访问任何物理内存或任何I/O而不被中断，因此长期被滥用。但启用SMM隔离后，以Intel平台为例，所有非Intel SMM模块都通过环分离或SMM环境内的页表隔离。因此，如果攻击者构建了自己的SMM后门并植入目标PC，它将在SMM环3运行。当它尝试访问操作系统内存区域时，由于这些页面未映射到SMM页表，将触发页错误。当它尝试访问I/O时，在SMM环0运行的安全监视器将检查策略，如果不匹配则拒绝访问。

**因此，除非绕过SMM隔离，否则现有的SMM恶意软件在当前SMM和权限分离的趋势下不再有效。**

顺便说一下，有两种类型的UEFI模块可以在操作系统运行时运行。一种是前面提到的SMM模块，大多数现有研究使用这种。然而，还有另一种类型的UEFI模块可以在运行时运行，称为运行时DXE驱动程序。这些模块像内核驱动程序一样映射到高虚拟地址空间。当操作系统代码调用UEFI运行时服务时，会触发这些功能。

与启用SMM隔离的SMM模块相比，运行时DXE驱动程序现在可以被视为权限更高的模块，因为它可以访问所有操作系统内存和所有I/O。然而，无论哪种模块，它们也都面临着操作系统和硬件依赖性的困境。

---

## Shade BIOS的构想

那么，从BIOS能做的就这些了吗？从攻击者的角度来看，我们不想触及操作系统，因为操作系统可以检测到所有行为。但我们又需要操作系统在运行时的功能，如内存管理或设备驱动程序。如果没有这样的功能，最直接的想法是为攻击者实现一个独占的虚拟机。但这不现实，因为没有操作系统可以与其他操作系统并行运行，而且这很麻烦且占用大量内存。

经过思考，我们意识到UEFI BIOS实际上可以被视为一个小型操作系统，因为它有自己的内存管理和设备驱动程序。而且，它的体积很小，所以不浪费内存。于是我们想到一个主意：即使在操作系统启动后，也保留BIOS在内存中并使用它。因此，我们创造了Shade BIOS。

**通过将BIOS保留在内存中，它允许BIOS代码即使在操作系统启动后也能使用UEFI功能，如UEFI引导服务、UEFI协议或UEFI驱动程序。**

通过使用Shade BIOS，攻击者可以获得以下三个好处：
1.  **实现纯粹的BIOS恶意软件**：Shade BIOS将使UEFI恶意软件与操作系统级安全脱钩。
2.  **使恶意软件设备独立**：意味着攻击者不必知道目标使用什么设备。
3.  **使恶意软件易于开发**：因为它们不需要实现完整的驱动程序栈或直接访问I/O，而是可以使用UEFI的接口。

---

## Shade BIOS的工作原理

在接下来的部分，我将解释Shade BIOS的工作原理。简而言之，它有两个主要功能：第一是在操作系统启动后保留BIOS；第二是让保留的代码在运行时正常工作。

### 1. 如何将BIOS保留在内存中

在解释之前，我想概述一下UEFI如何管理内存映射。内存映射被管理为一个内存映射结构的双向链表。每个结构都有一个EFI内存类型，指示该内存区域存储什么类型的数据。例如，从内存地址0x5000到0x6000的内存区域的EFI内存类型为EFI引导服务数据。存储在这里的数据仅在引导时可用，操作系统启动后可以丢弃。

可以通过调用`GetMemoryMap`引导服务来获取内存映射，但我们只能获得内存映射的副本。这主要由操作系统加载程序使用，它们调用这个`GetMemoryMap`引导服务，并确定可以在哪里放置操作系统。它们认为EFI引导服务代码和数据不再必要，因此将使用这些内存区域。但它们会保留EFI运行时服务代码或数据等内存区域。

回到我们的目标，为了将BIOS保留在内存中，我们可以挂钩这个`GetMemoryMap`引导服务，并将EFI引导服务代码和数据的类型更改为EFI运行时服务代码和数据。然后，操作系统加载程序会认为这些存放EFI驱动程序或EFI协议的区域不能被销毁，这些状态将保留在内存中。你可能会想，这是否会占用太多操作系统可用的内存区域。但BIOS是一个非常小的组件，所以内存中没有很多EFI引导服务代码和数据。操作系统将转而使用EFI加载器数据或EFI常规内存，大多数内存区域都属于这种类型。

### 2. 解决运行时问题

现在我们已经能够将BIOS保留在内存中，但我们不能直接执行保留的代码。我们需要处理以下五个问题，才能让保留的代码在运行时正常工作。

#### 问题一：运行时内存管理问题

内存分配器或BIOS从前面提到的双向链表中找到EFI常规内存的新页面。但这里的问题是，当前使用EFI常规内存的是操作系统。因此，BIOS分配器将从操作系统内存区域分配新的内存区域。

**解决方案**：我们可以再次挂钩`GetMemoryMap`引导服务，并为BIOS在运行时使用保存一些EFI常规内存。内存映射中有很多常规内存，我们将通过将其显示为EFI运行时服务数据，从操作系统中拿走一些黄色的常规内存。请记住，`GetMemoryMap`返回内存映射的副本，因此我们并没有修改实际的内存映射。这样，黄色的常规内存将不会被操作系统加载程序使用，但其他粉色的常规内存将被操作系统使用。接下来，我们希望BIOS内存分配器只使用黄色的常规内存，因此我们将粉色的常规内存从实际的内存映射中取消链接。这样，当BIOS内存分配器搜索空闲内存时，由于只有我们保存的黄色常规内存被链接，BIOS永远不会使用粉色的内存区域。

#### 问题二：内存虚拟化问题

保留的模块认为它们在物理地址上运行，因此它们包含物理地址的全局指针，甚至可能有硬编码的物理地址。由于很难调整所有这些引用到虚拟地址，处理这个问题的最佳方法是更改页表为恒等映射。我实际上使用了部分恒等映射，这在我去年的BlackHat演讲中介绍过，因此这里跳过细节。

#### 问题三：仅引导时资源问题

EFI系统表和EFI引导服务的一些成员指针在操作系统启动后被释放。这个问题的解决方案非常简单，你只需要在引导时复制它们，并在运行时解析它们。

另一个问题是UEFI变量。具有运行时属性的新UEFI变量仅在引导时可访问。但保留的BIOS代码会尝试访问非运行时UEFI变量，因为它们认为自己在引导时运行。这个问题的解决方案也很直接，我们可以挂钩`SetVariable`运行时服务，并为该变量创建一个副本，并添加运行时属性。

#### 问题四：设备设置被操作系统设备驱动程序重新初始化

我想以USB主机控制器为例解释这意味着什么。USB主机控制器有一个CRCR寄存器，用于保存命令环的内存地址。设备驱动程序将写入这个命令环，让硬件控制器执行某些操作。当驱动程序初始化控制器时，它做的一件事是在内存中准备这个命令环，并将其地址存储到CRCR寄存器中。现在的问题是，在引导时，UEFI驱动程序在内存中准备了它们的命令环。但在操作系统启动后，操作系统设备驱动程序将准备它们自己的命令环，并覆盖CRCR寄存器以指向它们的命令环。然而，保留的UEFI驱动程序认为CRCR寄存器仍然指向它们的命令环，因此你不能直接使用保留的UEFI协议。

**解决方案**：重新初始化来自UEFI驱动程序的设备，并将这些设备寄存器设置为适当的值，供BIOS在运行时使用。但请记住，我们不希望Shade BIOS包含设备特定的代码，因此我们不能直接读写这些寄存器。

那么，如何在不直接访问寄存器的情况下重新初始化设备呢？解决方案是利用UEFI驱动程序遵循UEFI驱动程序模型这一事实，使用`DisconnectController`引导服务和`ConnectController`引导服务。以网络接口卡为例，NIC的硬件控制器被抽象为一个特定的控制器句柄。如果你调用`ConnectController`引导服务并指定这个控制器句柄，每个与此控制器句柄相关的驱动程序绑定协议中的`Start`函数都会被调用。在这个`Start`函数中，它通过设置一些寄存器来初始化设备，并安装UEFI协议。另一方面，如果你调用`DisconnectController`引导服务，每个`Stop`函数都会被调用，所有这些协议都会被卸载，设备被重置。

**因此，为了从操作系统劫持设备控制：**
1.  首先，我们调用`DisconnectController`引导服务来重置设备，意味着清除硬件的寄存器，这样CRCR寄存器将不再指向操作系统的命令环。
2.  然后，我们调用`ConnectController`引导服务来为BIOS初始化设备，这样CRCR寄存器将指向BIOS的命令环。

现在，保留的UEFI驱动程序可以使用UEFI协议访问设备。但在恶意行为完成后，我们必须将设备控制权返回给操作系统。这相当困难，因为我们不知道操作系统的命令环在哪里，或者寄存器中设置了什么值，而且我们不能仅仅保存寄存器值并恢复它，因为我们不想包含特定的代码。

幸运的是，我们意识到我们不需要显式地将设备控制权返回给操作系统，因为它们会自我修复。因此，如果Shade BIOS使用NIC并结束其恶意行为，会有几个时刻网络连接中断，但会在不到三分钟内恢复。这可能不是一个优雅的解决方案，但既然我们必须使代码设备独立，我认为这是最好的选择。我们也可以说，这个设备控制权返回问题是Shade BIOS的主要挑战。

#### 问题五：独占控制问题

Shade BIOS会做很多有害的事情，比如更改页表，因此我们需要排除操作系统代码。这意味着我们需要禁用中断。禁用中断最流行的方法是使用CLI和STI指令。但这些不可靠，因为保留的BIOS代码中已经有很多CLI和STI指令。即使里面有一个STI指令，中断也会在之后被启用，操作系统会运行。因此，我们改用CR8寄存器或任务优先级寄存器，因为UEFI驱动程序很少使用这个。

禁用中断排除了操作系统代码，但有人可能会问，BIOS的中断呢？方便的是，UEFI BIOS除了定时器中断外不使用中断。UEFI驱动程序主要使用轮询。因此，大多数UEFI协议实际上在没有中断的情况下工作。定时器中断用于定时器事件，因此一些使用这个的UEFI协议会工作。但我们可以手动触发每个事件并模拟中断。因此，我们不会更改操作系统的IDT，而是模拟定时器中断。

定时器事件被管理为I事件结构的双向链表。例如，当你使用HTTP协议的请求函数时，一些事件结构被插入到这个列表中。每个I结构都有一个触发时间，如果系统时间大于触发时间，则执行事件的`Notify`函数。是定时器中断处理程序递增这个系统时间。因此，我们可以定位这个链表，并触发每个事件，而不管触发时间如何。这是一种相当粗暴的方式，但大多数事件在从调用函数返回时已经完成，所以这意外地奏效了。

---

## Shade BIOS的优势

现在，保留的代码应该可以正常工作了。接下来，我将通过比较现有的BIOS恶意软件和纯粹的BIOS恶意软件，展示我们如何实现设备独立。

左侧的现有UEFI恶意软件在用户态或内核态执行恶意行为。例如，当它们想要创建一个文件时，会使用C的`fopen` Windows API或`NtCreateFile`内核API。该API将向操作系统设备驱动程序发送请求，最终到达硬件。在这个过程中，存在很多被检测到的风险。在操作系统API中，有内置的日志记录功能；在设备驱动程序之间，有反病毒产品的过滤驱动程序等。虽然可以禁用这些，但如前所述，很难禁用所有东西，而且攻击者必须知道目标上运行的是什么杀毒软件，以及该杀毒软件使用什么内核驱动程序。

**另一方面，Shade BIOS将使用保留的UEFI驱动程序，而不是操作系统设备驱动程序。因此，它完全独立于操作系统检测和杀毒软件检测。**

关于设备依赖性：中间的图片是使用Shade BIOS进行命令与控制通信的代码。这段代码首先调用`ConnectController`引导服务，从操作系统劫持设备控制权。然后使用HTTP协议进行配置并向C2服务器发出请求。如你所见，没有直接访问I/O，没有直接读写寄存器，它只是使用抽象的接口，如EFI引导服务或EFI协议。因此，相同的代码可以在不同的机器上工作。

---

## 演示与检测

我将展示Shade BIOS如何工作的演示。左边是感染了Shade BIOS的受害设备，右边是在端口3033上监听的C2服务器。我想使用这个内核驱动程序，它也会连接到C2服务器，将其视为从现有UEFI恶意软件丢弃的内核级代码。并将其与Shade BIOS进行比较，看它是否会被上层安全机制检测到。在这种情况下，是Windows Defender防火墙。

首先，正常执行这个内核驱动程序，C2服务器收到了这些消息。接下来，我将使用Windows Defender防火墙阻止端口3333，然后再次加载并执行它。这次我们没有收到任何消息。如果我们查看调试消息，它收到了访问被拒绝的状态。

最后，我将使用Shade BIOS窃取这个进程数据。我将使用这个触发程序来触发Shade BIOS。Shade BIOS不需要客户端程序，但这只是为了在正确的时机触发它进行演示。现在执行这个，我收到了秘密数据，它与这个数据匹配。

**因此，我们可以说操作系统级安全不影响Shade BIOS。**

---

## 检测与缓解

Shade BIOS实际上需要一个内核功能，那就是`MmGetVirtualForPhysical` API。由于时间关系，我跳过原因，但这不会成为检测向量，因为即使检测逻辑被构建到API中，BIOS也可以将整个函数复制到其他地方，禁用安全逻辑，然后使用它。而且这不是一个很大的函数，所以很容易