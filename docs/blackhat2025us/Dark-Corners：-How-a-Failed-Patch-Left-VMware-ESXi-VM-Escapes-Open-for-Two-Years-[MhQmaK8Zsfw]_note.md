# 课程 1：一个失败的补丁如何让 VMware ESXi 虚拟机逃逸漏洞敞口两年 🕵️♂️

在本节课中，我们将学习一个关于 VMware ESXI 虚拟机逃逸漏洞的深度技术分析。我们将了解一个在 2021 年被报告但未能被正确修复的漏洞，如何直到 2024 年才被真正修补，以及研究人员如何利用它实现完整的虚拟机逃逸和沙箱突破。

## 概述与背景

大家好，我是 Yu Haojiang。今天，我和我的同事 Zmin 将介绍“黑暗角落：一个失败的补丁如何让 VMware ESXi 虚拟机逃逸漏洞敞口两年”。这项研究是我、Xinlei 和 Zmin 的合作成果。

我们是安全研究员，来自奇安信集团安全实验室，曾多次成功实现虚拟机逃逸，并在 2023 年获得了 Pwn2Own 奖项。

以下是我们的课程路线图：
*   首先，我们将简要介绍 ESXi 及其架构。
*   其次，我们将深入探讨 ESXi 虚拟机逃逸的两个主要组成部分：从虚拟机中逃逸，以及逃逸 ESXi 沙箱。
*   最后，我们将以一个演示视频作为总结。

现在，让我们从介绍部分开始。

在深入技术细节之前，先分享一下我们进行这项研究的背景。今年早些时候，VMware 披露了几个已被在野利用的漏洞。这突显了 ESXi 漏洞在真实世界场景中的潜在影响和危险性。

由于我们在 2023 年天府杯上成功演示了 VMware ESXi 虚拟机逃逸，我们认为来这里分享这个故事背后的一些有趣细节会很有价值。

## ESXi 架构简介 🏗️

现在，让我们看看 ESXi 的架构。作为一个虚拟化平台，它与 VMware Workstation 非常相似。然而，其底层主机操作系统被替换为 VMkernel，这是一个专门的虚拟机监控程序内核。

此外，它还有一个沙箱系统，为每个进程提供细粒度的权限控制。

## 虚拟机逃逸的攻击面分析

接下来，让我们转向虚拟机逃逸部分。首先，我们来审视 ESXi 虚拟机监控程序的攻击面。我整理了一个表格，这是去年演讲中表格的更新版本，添加了一些新信息。

它全面记录了近年来所有公开披露的关键漏洞及其影响的模块。

我们可以看到，当前 VMware 虚拟机监控程序的攻击面主要由虚拟设备和客户机 RPC 构成。2024 年之前的大多数漏洞都与 USB 相关。这些包括虚拟 USB 控制器和蓝牙设备。虚拟蓝牙设备通过 UHCI 控制器连接。然而，我注意到 VMware 后来移除了蓝牙设备，因此这个攻击面可能已不存在。

今年，我们看到了其他模块中出现的漏洞，例如 CSI、VMX、net3 和 VMCI。本质上，我们寻找的是可以从虚拟机内部触发，但不会受到客户机操作系统本身干扰的模块。

## 一个古老漏洞的故事

现在，让我们来谈谈一个故事。我们的故事始于一个古老的漏洞。2023 年，当我们决定参加天府杯时，我们开始研究 VMware。我们检查了当时最新修补的漏洞，即 2021 年天府杯期间报告的漏洞。这个漏洞是由来自昆仑实验室的 Way 发现的。我们可以看到，这是 xHCI USB 控制器中的一个释放后使用漏洞。

在继续分享我们的分析工作之前，让我简要介绍一些 xHCI 对象。蓝色部分来自 xHCI 规范，紫色部分是 VMware 特有的。

首先，**Slot** 对象代表一个 USB 设备。每个设备有 31 个端点，用于配置出站数据传输和入站数据传输。每个端点可以有字符串上下文，对应 TR 环，用于存储数据包。

现在，紫色部分是 VMware 特有的对象。**Pipe** 管理端点的数据传输，**URB** 代表正在处理的数据包。所有 URB 都由 Pipe 管理。

这个释放后使用漏洞的关键变化位于两个 HCI 命令环处理函数中。这些变化重新编排了 Slot 上下文重写和执行 xHCI 清除字符串上下文的顺序。

我们可以从下面源代码中的红色方框看到这一点。这意味着在旧版本中，我们可以在执行 xHCI 清除字符串上下文之前修改 Slot 上下文。

那么，我们能利用它做什么呢？让我们看看 `xHCI_ClearStringContext` 函数。它执行 `xHCI_DeleteStringContext`，并依次调用 `xHCI_FetchPipe` 和 `xHCI_CleanPipe`。

在 `xHCI_CleanPipe` 中，我们可以看到它首先检查临时端点变量中是否存在 Pipe。如果存在，它将执行 `CancelPipe`，这会释放该 Pipe 管理的所有 URB。

但这也意味着，如果 `xHCI_FetchPipe` 失败，`CancelPipe` 将完全不会被执行。

那么，在 `xHCI_FetchPipe` 中我们能做什么呢？我们可以看到，它从存储的上下文中读取内容，然后执行检查。如果检查失败，它直接返回 0。那么，这个临时端点变量中将不会有任何 Pipe。

所以流程是这样的：正常情况下，当我们删除字符串上下文时，它会执行 `CancelPipe` 释放 URB，最后释放字符串上下文。但是，如果我们能修改存储的上下文，它将跳过 Pipe 处理，直接执行后续代码。

现在，我们可以在字符串上下文被释放后，让 Pipe 不被释放。接下来我们能做什么？

我们发现 URB 有一个指向字符串上下文的指针。当一个 URB 完成时，它会从字符串上下文中减去 URB 数据包的大小。

由于在删除字符串上下文时我们可以跳过 Pipe 处理，URB 和 Pipe 得以保留，但字符串上下文已经被释放。因此，如果我们能手动清除 Pipe，它将释放 URB，导致它在已释放的字符串上下文中执行减法操作。这就是释放后使用漏洞。

## 补丁的失败与漏洞重现

在理解了这个旧漏洞后，我决定查看 VMware 当时的最新版本。我发现 VMware 在 `xHCI_FetchPipe` 函数中添加了新代码。本质上，它引入了一种获取 Pipe 的新方式。所以现在有两种基于 Slot 状态的方法。

这使我能够修改这个特定的 Slot 成员，以达到与原漏洞相同的效果，即在修改后无法找到 Pipe，从而完全不处理 Pipe。流程是这样的。但由于时间限制，这里不深入细节。

是的，所以我们发现了一个新漏洞，对吧？这看起来相当令人兴奋。

但是等等，故事没那么简单。实际上，这个亚洲漏洞隐藏着更多秘密。实际上，我们不需要新代码就能让 `HCI_FetchPipe` 函数失败。

我们发现这个补丁从未成功。让我们再看一下 `xHCI_ClearStringContext` 函数。它实际上有一个 EPID 参数来指定端点。

根据我们之前对 xHCI 对象的介绍，我们知道每个端点都有其对应的字符串上下文数组。这意味着 `xHCI_ClearStringContext` 只删除特定端点的字符串上下文。

但是整个 Slot 的内容已经被我们修改了。所以我们可以修改 Slot 内容，然后清除一个端点的字符串上下文。接着，我们可以执行一个禁用 Slot 的命令来清除所有端点的字符串上下文，从而触发释放后使用漏洞。

所以它从未被成功修补。

## 漏洞利用的挑战与突破

现在，让我们进入漏洞利用部分。让我们更仔细地看看这个释放后使用漏洞。这个漏洞实际上给我们的利用工作带来了巨大挑战。

这是一个约束条件非常严格的释放后使用漏洞。首先，它只影响已释放内存块偏移 `+0x205C` 处的值，而使用操作是从该地址的 4 字节值中减去一个值。

这带来了几个困难：
1.  `+0x205C` 不是一个 64 字节对齐的地址偏移。这意味着如果我们想用这个释放后使用漏洞来修改堆块中的指针，我们只能修改该指针的高 4 字节。但修改指针的高 4 字节对于利用来说完全没有意义，因为即使只加 1，也会使指针跨越 4GB 的内存空间。
2.  `+0x205C` 也是一个非常大的偏移值，这意味着我们在堆布局整理时需要做得更好。

所以我们需要一些方法来解决这个问题。这对于一个闭源目标来说也相当具有挑战性。

幸运的是，我找到了一个完美的原语。这个完美的原语就是**哈希表**。我相信你们都知道哈希表是什么。VMware 的哈希表是这样工作的：每个元素有一个值和一个键，它们存储在一个堆块中。当存储超过容量时，哈希表的大小会翻倍。

更妙的是，xHCI 字符串上下文哈希表正好拥有我们需要的结构。每个元素是一个 8 字节的指向字符串上下文的指针，加上一个 4 字节的 ID，总共正好是 12 字节。

这太完美了。我们的释放后使用漏洞现在可以修改第二个元素，其中指针起始于偏移 `+0xC` 处。现在，我们可以修改这个字符串上下文指针的低 4 字节。有了这个原语，我们受约束的释放后使用漏洞突然拥有了巨大的潜力。我们可以让这个指针指向一个我们可以控制的伪造字符串上下文。

## 可用的其他利用原语

让我们看看我们手头还有哪些其他原语。

第一个是 **URB** 对象。这是我们去年分享过的对象，我们用它开发了一套全新的利用原语。它非常强大。我们可以任意控制它的大小、分配或释放它。它有一个由 `lens` 成员管理长度的数据数组，并且它还有许多指针，使其在各个方面都非常有用。

在这里，我还想分享一些我们去年没有发现的事情。我们发现 VMware Linux 版本中的 VMware USB 仲裁程序没有剥离符号。因此，我们可以获得许多与 USB 相关的符号，例如 URB 的符号。这对我们正在进行的研究非常有帮助。

第二组原语是 **MOB Surface** 和 **GMR**。它们都属于 VMSVGA 模块，即图形模块。有关详细信息，您可以查看 VDI 在 2018 年发布的博客文章。通过这些对象，我们可以轻松地执行堆喷射和堆风水。

此时，我们实际上已经有了足够的可用原语。是时候将它们组合起来，完成我们的利用了。

## 完整的利用链构建

为了更好地与大家分享，我简化了相关内容。实际的堆布局和操作比这更复杂。

首先，我们需要执行信息泄露以获取堆地址。
1.  我们首先分配一个字符串上下文，然后触发漏洞。它会被释放，随后我们可以在其 `+0x205C` 偏移处减去一个值。
2.  接下来，我们分配一个大小为 `0x2050` 的 GMR 堆块，它将占据前部空间。此时，我们的能力变为修改后续堆块偏移 `+0xC` 处的值。
3.  然后，我们可以在 GMR 后面分配一个 URB，而 URB 的 `actual_lens` 字段恰好位于 `+0xC` 位置，非常完美。
4.  现在，当我们触发释放后使用漏洞中的“使用”操作时，我们可以将 URB 的 `actual_lens` 向下减去一个很大的值，从而允许我们对 URB 之后的内容进行越界读取。
5.  如果我们在该设置后面的内存区域中预先布置了包含堆地址的内容，我们就可以成功泄露这些地址。

在获取堆地址后，我们就可以开始在这次利用中伪造各种对象。由于我们使用字符串上下文哈希表作为原语，我们需要伪造字符串上下文。
1.  我们可以在后续内存中放置一个字符串上下文，然后触发漏洞。同样，我们只释放字符串上下文，然后使用哈希表占据适当的位置。
2.  当我们触发释放后使用漏洞的“使用”操作时，原始指针将被减去一个值，最终指向我们伪造的字符串上下文。
3.  虽然我们无法直接用这个伪造的字符串上下文做太多事情，但我们可以使用 `xHCI_ClearStringContext` 函数来释放它。此时，它仍然是 URB 堆块的一部分。因此，我们可以实现堆块重叠的能力。
4.  由于 ESXi 使用 GC 来管理堆，这种堆块重叠能力非常强大。

最后，我们可以进入控制流劫持步骤。现在我们有了堆地址和堆块重叠能力。下一步是找到一个可以调用函数指针的地方。

我们发现，从字符串上下文中减去 URB 大小的函数实际上是 URB 中存在的 VUSB 设备对象内的一个函数指针。因此，我们可以伪造 URB 的 VUSB 设备对象来实现任意地址调用。

此时，我们实际上已经完成了虚拟机逃逸。然而，为了执行后续的沙箱逃逸，我们需要执行任意 shellcode 的能力。执行 shellcode 的方法是找到用于栈迁移的 gadget，然后使用 ROP 创建可执行内存，复制 shellcode 并执行它。

## 总结与反思

至此，我们回顾了关于 ESXi 虚拟机逃逸的故事。现在，让我们回顾一下这一切背后的安全问题。

我们发现 CVE-2021-2205 从未被正确修补。我们在 2023 年报告了这个问题，它获得了一个新的 CVE 编号：CVE-2024-22252。然而，没有人指出这两个漏洞实际上是同一个。

我们还看到了 VMware 今年早些时候关于这些漏洞在野被利用的公告。这证明了 ESXi 逃逸的真实价值。

但另一方面，一个 2021 年的漏洞直到 2024 年才被真正修复。这种现象值得反思。

我认为有几个原因：
1.  首先，也是最重要的，漏洞赏金计划的奖励金额远低于这些漏洞的实际价值。这导致更少的人愿意向 VMware 报告关键漏洞。
2.  更多的安全研究人员选择在像天府杯和 Pwn2Own 这样的安全竞赛中使用这些漏洞。但这些一年一度的竞赛不可避免地延长了漏洞的生命周期。或者，更多的漏洞利用可能被用于在野攻击，而不是被披露给安全竞赛。
3.  其次，VMware 是闭源软件，入门门槛较高，导致研究 VMware 的研究人员非常少。
4.  这引出了我们的第三点：社区缺乏与 VMware 相关的技术分享。这也是我们这两年在本会议上分享 VMware 逃逸技术的动机。

---

# 课程 2：VMware ESXi 沙箱逃逸技术 🔓

上一节我们介绍了如何从 VMware ESXi 虚拟机中逃逸。本节中，我们来看看如何逃逸 ESXi 的沙箱。在实现虚拟机逃逸后，我们可以在主机系统上运行代码，但 VMX 进程仍然在沙箱内。这意味着我们无法执行许多操作，例如开启 SSH、关闭防火墙以获取主机的完全控制权。我们必须逃逸沙箱。

## ESXi 沙箱工作原理

首先，让我解释一下沙箱是如何工作的。一个 ESXi 系统只有一个用户，即 root 用户。它使用安全域来限制进程对文件、网络的访问。

在 shell 中，我们可以使用以下命令查看沙箱规则。ESXi 有超过 100 个沙箱域，每个进程驻留在其中一个域中。当虚拟机启动时，ESXi 为 VMX 进程创建一个新的沙箱域。我们重点关注它。

查看规则，我们可以看到对此系统调用的限制。有些规则很容易理解，比如 `ioctl`、`open` 等，但有些像 `vmcall`，我们需要知道它们的含义。

为了知道可以使用哪些系统调用，我们必须查看 VMkernel。带有符号的 VMkernel 可以从系统中的这个文件提取。我们可以使用 `find` 命令定位此文件。

检查内核代码后，我们了解到：`vmcall` 有三个系统调用表。使用的表取决于系统调用号。如果号码小于 400，它使用初始表，例如 `open`、`read`、`write`，与 Linux 相同。我们可以添加超过 700 个新的系统调用，就像图中所示。这似乎是一个更大的攻击面。

但并非所有系统调用都在沙箱中允许。沙箱对系统调用的限制主要在这个函数中。它执行两项检查：
1.  检查强制级别，类似于 Linux 安全增强模式域有强制、许可、禁用等级别。如果级别为 0（禁用），该函数直接返回成功。
2.  如果级别为强制，则检查访问掩码。每个域都有一个访问掩码，一个显示其能做什么的数字。`vmcall` 定义了许多访问类别类型，如 `generic`。每个访问掩码中的位代表一个类别，每个系统调用属于一个访问类别。例如，如果一个域同时具有 `generic` 和 `vmmax` 权限，其掩码将是 3。而这个函数是一个系统调用函数，它属于 `generic` 类别。

所以，如果我们能列出每个系统调用的访问类别，我们就知道可以使用哪些系统调用。

## 切换到其他沙箱域的方法

接下来，我将讨论如何切换到另一个沙箱域。有两种方法。

第一种方法是通过在此系统调用的参数中添加安全域。这个参数可以是一个整数（域索引）或字符串（域名）。如果你想在沙箱域中测试你的程序，有一个简单的方法，只需将此添加到命令行。

我们能通过这种方式逃逸沙箱吗？然而，只有特权域和转换域才能使用此方法。列表如图所示。

另一种切换到沙箱域的方法是当二进制文件具有 VMware 安全属性时。以下是 `getxattr` 函数。域的标签用于查找域对象，然后进行转换。

同样的问题：是否可以通过设置二进制文件的扩展属性来逃逸沙箱？答案是否定的。
1.  首先，此系统调用在沙箱中被阻止。我们需要 `VMK_SAYS` 权限。
2.  其次，安全域有一个加载目标列表。例如，VMX 域只能切换到 TPM 域，如图所示。一个链表用于存储允许转换的所有域。

## 发现沙箱逃逸的突破口

现在，我们可以完全理解沙箱规则了。该命令显示了四个部分的规则：文件、系统调用和转换。每个部分都可能成为攻击系统的途径。

在检查规则时，我看到了有趣的东西。VMX 进程对 CBT 设备具有读写访问权限。什么是 CBT？更改块跟踪用于跟踪虚拟机磁盘的哪些部分已更改。

让我们看看这个 CBT 驱动程序。CBT 驱动程序是一个文件设备服务驱动程序，通过此函数添加到内核。主要功能是 `CBT_IOCTL`。我们可以通过两种方式调用它：
1.  打开默认的控制设备，然后使用 `ioctl`。
2.  使用 `CBT_MakeDev` 创建一个新设备。例如，创建 `power1` 设备，打开并使用 `ioctl`。

这两种方式进入不同的代码路径。我们关注第二种方式。`CBT_MakeDev` 首先调用此函数，创建一个 CBT 设备对象，存储用户输入的填充句柄，并使用此函数获取文件大小。最后，基于文件大小创建一个位图对象。位图用于跟踪更改的块。

## CBT 驱动程序中的漏洞

此函数 `UpdateBitmap` 中存在一个漏洞，它基于用户提供的偏移和大小导致越界写入，但没有进行充分检查。所以，如果我们能进入此函数，我们就可以在位图末尾之后写入，获得越界写入原语。

但在此之前没有问题。代码调用此函数，它会检查偏移和大小不能大于文件大小。但是，这里有一个技巧：位图大小是在文件首次检查时设置的。但如果我们后来使文件变大，位图大小不会改变。所以，让我们向文件写入更多内容使其变大。现在，我们的偏移和大小可能小于新的文件大小，但位图仍然很小，因此我们可以写入其边界之外。现在我们有了一个越界写入原语。

现在，我们可以在堆对象上触发越界写入。我们可以覆盖哪个对象呢？首先，我想到在内核中寻找