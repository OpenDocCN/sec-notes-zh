# 课程：QUACK：通过静态鸭子类型防御反序列化攻击 🦆

![](img/516b4b049f3a6db78d47468f3e19034b_1.png)

## 概述

在本节课中，我们将学习一种名为QUACK的防御系统，它旨在通过静态程序分析技术来缓解PHP应用程序中的反序列化攻击。我们将首先了解反序列化攻击的工作原理，然后深入探讨QUACK如何利用“静态鸭子类型”来自动推断开发者的意图，并限制反序列化时可实例化的类，从而阻止攻击链。

---

## 反序列化攻击原理 🔓

![](img/516b4b049f3a6db78d47468f3e19034b_3.png)

上一节我们介绍了课程目标，本节中我们来看看反序列化攻击是如何工作的。

PHP提供了一个名为`unserialize()`的函数，它接收一个表示序列化对象的字符串，并将其重建为运行时的对象。如果攻击者能够控制输入给`unserialize()`的字符串，他们就可以操纵反序列化出的对象类型和属性。

**示例代码：**
```php
// 开发者期望反序列化一个 App 类的对象
$data = unserialize($user_input);
$data->run();
```

![](img/516b4b049f3a6db78d47468f3e19034b_5.png)

攻击者可以构造一个字符串，使得`unserialize()`返回一个完全不同的类（例如`CommandExecutor`）的实例。如果这个类恰好有与预期对象同名的方法（如`run()`），或者包含特殊的“魔术方法”（如`__wakeup`, `__destruct`），攻击者就可能执行恶意代码。

### 属性导向编程（POP Chains）

为了在真实、复杂的应用中利用漏洞，攻击者使用一种称为“属性导向编程”（Property-Oriented Programming, POP）的技术。

![](img/516b4b049f3a6db78d47468f3e19034b_7.png)

以下是POP链的基本步骤：
1.  攻击者选择一个包含有用魔术方法（如`__destruct`）的类作为入口点。
2.  通过设置该对象的属性，将其他类的对象嵌套进去。
3.  这些嵌套对象的类包含其他方法，当入口点的魔术方法被自动调用时，会触发一系列方法调用链。
4.  这条调用链最终会到达一个能执行危险操作（如`system()`）的函数。

**核心概念：** 攻击之所以能够成功，是因为攻击者能够创建和利用比开发者预期更多的类。

---

## 现有缓解措施及其局限性 🛡️

![](img/516b4b049f3a6db78d47468f3e19034b_9.png)

了解了攻击原理后，我们来看看现有的防御方法及其不足。

![](img/516b4b049f3a6db78d47468f3e19034b_11.png)

![](img/516b4b049f3a6db78d47468f3e19034b_13.png)

目前主要有三种推荐方案：
1.  **避免使用`unserialize()`**：改用JSON等格式存储简单数据。但对于需要存储复杂PHP对象的场景不适用。
2.  **使用加密签名确保数据完整性**：这要求应用程序自身生成序列化数据，并非总是可行。
3.  **使用`unserialize()`的`allowed_classes`参数**：这是PHP内置的最有效防御。开发者可以提供一个允许反序列化的类名列表。如果遇到列表之外的类，PHP会将其替换为一个无方法无属性的“虚对象”，从而阻断攻击。

![](img/516b4b049f3a6db78d47468f3e19034b_15.png)

![](img/516b4b049f3a6db78d47468f3e19034b_17.png)

![](img/516b4b049f3a6db78d47468f3e19034b_19.png)

**示例代码：**
```php
// 只允许反序列化 App 类
$data = unserialize($user_input, ['allowed_classes' => ['App']]);
```

![](img/516b4b049f3a6db78d47468f3e19034b_21.png)

然而，`allowed_classes`参数使用率极低（约0.1%），主要原因有两个：
*   开发者不了解反序列化的风险。
*   对于已存在的庞大代码库，手动找出每个`unserialize()`调用所期望的类非常繁琐。

**本节要点：** 现有缓解措施要么不通用，要么未被充分利用。我们需要一种能自动推断开发者意图的工具。

---

## QUACK系统设计 🛠️

![](img/516b4b049f3a6db78d47468f3e19034b_23.png)

上一节我们指出了手动防御的困难，本节中我们将介绍QUACK的解决方案。

QUACK的设计目标是：**自动推断在特定`unserialize()`调用点，开发者预期允许反序列化的类集合**，并利用`allowed_classes`参数实施限制。

![](img/516b4b049f3a6db78d47468f3e19034b_25.png)

QUACK的工作流程分为三步：
1.  **确定可用类集合**：分析程序，找出在特定`unserialize()`调用点可能被加载的所有类。
2.  **推断预期类集合**：通过静态分析，观察反序列化后的对象在代码中是如何被使用的，以此推断其可能的类型。
3.  **计算交集并应用**：取“可用类集合”和“预期类集合”的交集，作为`allowed_classes`的参数值。

**系统公式：**
`allowed_classes = AvailableClasses(at deserialization point) ∩ InferredExpectedClasses(usage of object)`

---

## QUACK核心技术：静态鸭子类型 🦆🔍

QUACK推断类型的关键技术是“静态鸭子类型”。鸭子类型是动态语言中的概念：**“如果一个对象走起来像鸭子，叫起来像鸭子，那么它就可以被当作鸭子。”** 即，对象类型由其拥有的方法和属性决定。

QUACK将这一概念应用于静态分析。它遍历代码，收集关于反序列化对象使用的“证据”，并应用类型推断规则。

以下是几个核心推断规则示例：

**规则1：方法调用**
如果对象被调用了`swim()`和`fly()`方法，QUACK会寻找同时定义了这两个方法的类。

**规则2：属性访问**
如果对象访问了`featherColor`属性，QUACK会寻找定义了该属性的类。

**规则3：函数参数类型提示**
如果对象被传递给一个具有类型提示（如`function feed(Duck $animal)`）的函数，QUACK会直接采用该类型。

**规则4：类型检查操作符**
如果对象用于`instanceof`操作符（如`$obj instanceof Duck`），QUACK会采用操作符指定的类型。

![](img/516b4b049f3a6db78d47468f3e19034b_27.png)

![](img/516b4b049f3a6db78d47468f3e19034b_29.png)

QUACK还会分析嵌套对象的属性访问，以确保整个对象图中所有可能被实例化的类都受到限制。

---

![](img/516b4b049f3a6db78d47468f3e19034b_31.png)

![](img/516b4b049f3a6db78d47468f3e19034b_33.png)

## 实战演示：QUACK防御漏洞 🛡️✅

![](img/516b4b049f3a6db78d47468f3e19034b_35.png)

![](img/516b4b049f3a6db78d47468f3e19034b_37.png)

让我们通过一个真实案例（Moodle学习平台的CVE）来看QUACK的防御效果。

1.  **攻击阶段**：攻击者上传一个包含恶意序列化字符串的XML文件，触发POP链，成功执行了`system(‘echo HACKED’)`命令。
2.  **分析阶段**：对Moodle代码运行QUACK。QUACK分析到漏洞点处的`unserialize()`调用，发现反序列化对象仅被访问了两个特定属性。根据鸭子类型规则，它推断出只有一个类同时拥有这两个属性，并且该类在可用类集合中。
3.  **防御阶段**：根据QUACK的输出，手动（或通过后处理脚本）修改漏洞代码，添加`allowed_classes`参数，仅允许那个特定的类。
4.  **验证阶段**：再次上传相同的恶意XML文件。此时，由于攻击链中的其他类不被允许，反序列化失败，恶意命令未能执行，而正常的课程导入功能不受影响。

---

## 效果评估与未来展望 📊🚀

我们对QUACK在多个真实漏洞上的表现进行了评估。

*   **有效性**：在15个易受攻击的`unserialize()`调用中，QUACK成功阻断了其中12个调用点的所有攻击方法。总体而言，它阻止了攻击者97%的可用方法。自动化漏洞利用工具在QUACK防护下无法再生成有效的攻击载荷。
*   **改进方向**：
    *   **正确性**：PHP语言特性复杂，QUACK作为研究原型，可能存在未覆盖的边角情况。我们希望社区能提供反馈，帮助完善。
    *   **可用性**：理想情况下，QUACK可以集成到IDE中，在开发者编写代码时实时提供`allowed_classes`建议，实现“左移”安全。
*   **适用范围与局限**：
    *   QUACK能有效限制攻击者可用的类数量，从而阻断POP链攻击。
    *   QUACK无法防御“纯数据攻击”，即攻击者使用合法类但篡改其属性值（如将`User->isAdmin`改为`true`）的攻击。这需要其他机制（如输入验证）来防御。
    *   QUACK的理念可以扩展到具有类似反序列化API的语言（如Java、C#），但对于Python `pickle`这类表达能力极强的模块则难以适用。

---

## 总结 🎯

本节课中我们一起学习了以下内容：

1.  **反序列化攻击的本质**：攻击者通过注入非预期的类对象，利用魔术方法和POP链劫持程序控制流。
2.  **现有防御的不足**：最有效的`allowed_classes`参数因难以确定预期类而很少被使用。
3.  **QUACK的解决方案**：通过静态程序分析，结合“可用类分析”和“静态鸭子类型推断”，自动计算出应被允许的类集合。
4.  **QUACK的效果与意义**：它能显著降低应用受反序列化攻击的风险，作为一种深度防御工具，与开发者谨慎的编码实践和其他安全机制相辅相成。

最后，给开发者的核心建议是：**审慎使用`unserialize()`，如果必须使用，请务必考虑使用`allowed_classes`参数，而QUACK可以帮助你确定该参数的取值。**

---
*（注：本教程根据技术演讲内容整理，聚焦于核心原理与流程，省略了部分演示细节和问答环节。）*