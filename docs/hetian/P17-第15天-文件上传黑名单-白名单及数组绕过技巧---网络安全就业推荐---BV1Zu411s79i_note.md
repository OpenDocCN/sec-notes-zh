# 网络安全就业推荐 P17：第15天：文件上传黑名单、白名单及数组绕过技巧 📁

在本节课中，我们将学习不安全的文件上传漏洞。我们将了解文件上传的基本概念、常见的检测方式，并重点学习如何绕过客户端和服务端的各种安全检测，最终掌握利用解析漏洞的方法。

---

## 一、 文件上传基础介绍

文件上传是指客户端将数据以文件形式封装，通过HTTP协议发送到服务端。服务端接收并解析数据后，将其存储在硬盘上。

**文件上传漏洞产生的原因**主要有以下几点：
1.  服务器配置不当，未对上传文件进行检测。
2.  文件上传限制被绕过，过滤机制不完整或无效。
3.  开源编辑器存在上传漏洞。
4.  Web服务器存在文件解析漏洞。

**文件上传漏洞的危害**在于，如果服务端未对上传文件进行严格验证，攻击者可以上传恶意文件（如Webshell），从而控制整个网站或服务器。

**漏洞常见位置**包括：
*   图片上传功能
*   头像上传功能
*   文档上传功能

---

![](img/f6de060fec22270a08fa25902e8e38bb_1.png)

![](img/f6de060fec22270a08fa25902e8e38bb_3.png)

## 二、 文件上传检测方式与绕过流程

![](img/f6de060fec22270a08fa25902e8e38bb_5.png)

![](img/f6de060fec22270a08fa25902e8e38bb_7.png)

![](img/f6de060fec22270a08fa25902e8e38bb_9.png)

上一节我们介绍了文件上传的基础概念，本节中我们来看看文件上传过程中常见的检测方式以及基本的绕过流程。

![](img/f6de060fec22270a08fa25902e8e38bb_11.png)

一般的文件上传检测方式包括：
1.  **客户端JS检测**：在前端通过JavaScript脚本检测文件扩展名。
2.  **服务端MIME类型检测**：检测HTTP请求头中的 `Content-Type` 字段。
3.  **服务端目录路径检测**：检测上传文件的目标路径。
4.  **服务端文件扩展名检测**：检测文件的后缀名。
5.  **服务端文件内容检测**：检测文件内容的合法性。

![](img/f6de060fec22270a08fa25902e8e38bb_13.png)

**文件上传绕过的基本流程**如下：
1.  使用抓包工具（如Burp Suite）拦截文件上传的HTTP请求包。
2.  根据服务端的检测点，修改请求包中的相应字段（如文件名、`Content-Type`、文件内容等）。
3.  将修改后的数据包发送给目标服务器。
4.  服务器响应，若绕过成功则文件被上传。

![](img/f6de060fec22270a08fa25902e8e38bb_15.png)

![](img/f6de060fec22270a08fa25902e8e38bb_17.png)

![](img/f6de060fec22270a08fa25902e8e38bb_19.png)

![](img/f6de060fec22270a08fa25902e8e38bb_21.png)

---

![](img/f6de060fec22270a08fa25902e8e38bb_23.png)

![](img/f6de060fec22270a08fa25902e8e38bb_25.png)

![](img/f6de060fec22270a08fa25902e8e38bb_27.png)

![](img/f6de060fec22270a08fa25902e8e38bb_29.png)

## 三、 绕过客户端检测 (JS检测)

![](img/f6de060fec22270a08fa25902e8e38bb_31.png)

客户端检测的原理是在上传页面的前端JavaScript代码中，对文件的类型或扩展名进行校验。

![](img/f6de060fec22270a08fa25902e8e38bb_33.png)

![](img/f6de060fec22270a08fa25902e8e38bb_35.png)

![](img/f6de060fec22270a08fa25902e8e38bb_37.png)

绕过方法的核心是**阻止前端JS代码执行**或**绕过其检测逻辑**。

![](img/f6de060fec22270a08fa25902e8e38bb_39.png)

![](img/f6de060fec22270a08fa25902e8e38bb_41.png)

![](img/f6de060fec22270a08fa25902e8e38bb_43.png)

以下是具体的绕过方法：

**方法一：禁用浏览器JS**
*   使用浏览器插件（如Firefox的`NoScript`）禁用页面JavaScript。

![](img/f6de060fec22270a08fa25902e8e38bb_45.png)

![](img/f6de060fec22270a08fa25902e8e38bb_46.png)

![](img/f6de060fec22270a08fa25902e8e38bb_48.png)

![](img/f6de060fec22270a08fa25902e8e38bb_49.png)

![](img/f6de060fec22270a08fa25902e8e38bb_51.png)

**方法二：删除前端检测代码**
*   通过浏览器开发者工具（F12）审查元素，找到并删除执行检测的JS函数或相关HTML属性（如`onsubmit`）。

![](img/f6de060fec22270a08fa25902e8e38bb_53.png)

![](img/f6de060fec22270a08fa25902e8e38bb_55.png)

![](img/f6de060fec22270a08fa25902e8e38bb_57.png)

![](img/f6de060fec22270a08fa25902e8e38bb_59.png)

**方法三：抓包改包**
这是最常用且有效的方法，步骤如下：
1.  先上传一个服务器允许的文件（如`shell.png`），并利用Burp Suite抓取此请求包。
2.  在Burp Suite中，将请求包里的文件名（`filename`字段）修改为恶意后缀（如`shell.php`）。
3.  将修改后的数据包转发给服务器。

由于前端JS检测已在上传合法文件时通过，而后续的请求包被我们篡改，从而成功绕过客户端检测。

![](img/f6de060fec22270a08fa25902e8e38bb_61.png)

![](img/f6de060fec22270a08fa25902e8e38bb_63.png)

---

![](img/f6de060fec22270a08fa25902e8e38bb_65.png)

## 四、 绕过服务端检测

上一节我们学习了如何绕过前端的检测，本节中我们来看看如何绕过更常见的服务端检测。服务端检测主要围绕三个点：MIME类型、文件后缀和文件内容。

### 1. 绕过MIME类型检测

![](img/f6de060fec22270a08fa25902e8e38bb_67.png)

![](img/f6de060fec22270a08fa25902e8e38bb_69.png)

服务端通过检查HTTP请求头中的 `Content-Type` 字段值来判断文件类型。

![](img/f6de060fec22270a08fa25902e8e38bb_71.png)

![](img/f6de060fec22270a08fa25902e8e38bb_73.png)

**绕过方法**：使用抓包工具，将请求包中的 `Content-Type` 字段值修改为服务端允许的类型。
*   例如，将 `Content-Type: application/php` 修改为 `Content-Type: image/png`。

![](img/f6de060fec22270a08fa25902e8e38bb_75.png)

![](img/f6de060fec22270a08fa25902e8e38bb_77.png)

### 2. 绕过文件后缀检测（黑名单/白名单）

服务端通过检查文件扩展名来过滤，主要采用两种策略：**黑名单**和**白名单**。

**黑名单策略**：名单内的后缀不允许上传。
以下是针对黑名单的常见绕过方法：

*   **后缀大小写绕过**：利用系统大小写不敏感的特性。例如，黑名单过滤了`.php`，但可以尝试`.Php`、`.pHp`等。
    *   示例文件名：`shell.Php`
*   **空格绕过**：在文件名后添加空格。某些系统在保存文件时会自动去除末尾空格。
    *   示例文件名：`shell.php `
*   **点号绕过**：在文件名后添加点号。原理同上。
    *   示例文件名：`shell.php.`
*   **Windows特性绕过**：利用Windows文件系统的特殊命名规则。
    *   示例文件名：`shell.php::$DATA` 或 `shell.php:1.jpg`
*   **配合解析漏洞**：利用Web服务器解析漏洞。例如Apache的解析特性是从右向左识别后缀，遇到不可识别后缀则继续向左判断。
    *   示例文件名：`shell.php.xxx.yyy` (`.xxx.yyy`为不可识别后缀)
*   **`.htaccess`文件攻击**：上传一个自定义的`.htaccess`文件，使服务器将特定文件（如图片）当作PHP脚本解析。
    *   `.htaccess`文件内容示例：
        ```apache
        <FilesMatch "shell.jpg">
        SetHandler application/x-httpd-php
        </FilesMatch>
        ```

**白名单策略**：只允许名单内的后缀上传，安全性更高。
针对白名单的绕过方法相对较少，主要利用**截断上传**：

*   **%00截断**：在文件名中插入URL编码的`%00`（空字符），服务端在解析时会忽略`%00`后的内容。
    *   **GET请求**：直接在URL中使用`%00`，如 `filename=shell.php%00.jpg`
    *   **POST请求**：需要将`%00`解码后的空字符（十六进制`00`）通过Hex编辑直接插入数据包中。例如，在Burp Suite的Hex视图中，将文件名字段中`jpg`前的空格（`20`）修改为`00`。
    *   最终服务端保存的文件名可能是`shell.php`。

### 3. 绕过文件内容检测

服务端会检测文件内容的合法性，主要有两种方式：

*   **检测文件幻数 (Magic Number)**：检查文件头部的特定字节，如图片文件常见的幻数。
    *   **绕过方法**：在恶意脚本文件的开头添加合法的文件幻数。
    *   常见文件幻数示例：
        *   JPEG: `FF D8 FF E0`
        *   PNG: `89 50 4E 47`
        *   GIF: `47 49 46 38` (即字符串`GIF89a`)
    *   可以使用十六进制编辑器（如WinHex）在PHP木马文件开头添加`GIF89a`。

*   **图像二次渲染**：服务端对上传的图片进行重新压缩或处理，会破坏注入到图片中的代码。
    *   这种情况较难绕过，通常需要寻找图像处理库本身的漏洞（如图像溢出漏洞）。

---

![](img/f6de060fec22270a08fa25902e8e38bb_79.png)

![](img/f6de060fec22270a08fa25902e8e38bb_81.png)

## 五、 Web服务器解析漏洞简介

![](img/f6de060fec22270a08fa25902e8e38bb_83.png)

![](img/f6de060fec22270a08fa25902e8e38bb_85.png)

除了绕过检测，某些Web服务器自身存在的解析漏洞也可能被利用来执行上传的恶意文件。虽然现在较少见，但仍需了解。

以下是几种常见的解析漏洞：

*   **Apache解析漏洞**：Apache在解析文件时，从右向左识别后缀，遇到不可识别后缀则向左跳过，直到遇到可识别后缀。
    *   例如：文件`shell.php.abc`，`.abc`不可识别，Apache会将其解析为`shell.php`。

*   **IIS 6.0解析漏洞**：
    1.  **目录解析**：如果目录名包含`.asp`、`.asa`、`.cer`等，则该目录下所有文件都会被当作ASP脚本解析。
        *   例如：创建目录`upload.asp`，然后上传文件`shell.jpg`，访问`/upload.asp/shell.jpg`时，`shell.jpg`会被当作ASP执行。
    2.  **分号解析**：IIS 6.0在解析时，会忽略分号`;`后面的内容。
        *   例如：文件`shell.asp;.jpg`会被解析为`shell.asp`。

*   **IIS 7.0/7.5 & Nginx解析漏洞**：在特定配置下，如果PHP的解析由FastCGI处理，且`cgi.fix_pathinfo`设置为1（默认值），则存在解析漏洞。
    *   例如：上传文件`shell.jpg`，访问`/shell.jpg/.php`，Nginx会将其交给PHP解析器，PHP解析器认为`/shell.jpg/.php`是一个文件路径，但`shell.jpg`文件存在，于是将其内容以PHP代码执行。
    *   同样可以利用`%00`截断：`/shell.jpg%00.php`

---

![](img/f6de060fec22270a08fa25902e8e38bb_87.png)

![](img/f6de060fec22270a08fa25902e8e38bb_89.png)

## 六、 课程总结与课后作业

本节课中我们一起学习了不安全的文件上传漏洞。我们从文件上传的基本概念入手，详细剖析了客户端（JS检测）和服务端（MIME类型、文件后缀黑/白名单、文件内容）的多种检测机制，并学习了对应的绕过技巧。最后，我们还简要介绍了几种Web服务器的历史解析漏洞。

![](img/f6de060fec22270a08fa25902e8e38bb_91.png)

**核心要点总结**：
1.  **客户端绕过**：抓包改包是王道。
2.  **服务端绕过**：针对检测点（类型、后缀、内容）进行精准伪造或利用特性（大小写、空格、截断、解析漏洞）。
3.  **综合利用**：在实际测试中，可能需要结合多种方法才能成功上传Webshell。

![](img/f6de060fec22270a08fa25902e8e38bb_93.png)

![](img/f6de060fec22270a08fa25902e8e38bb_95.png)

**课后作业**：
请完成提供的`upload-labs`靶场第1至17关。请先尝试运用本节课所学知识独立完成，并记录每关的绕过方法和步骤。下节课我们将详细讲解该靶场的通关思路。

![](img/f6de060fec22270a08fa25902e8e38bb_97.png)

![](img/f6de060fec22270a08fa25902e8e38bb_98.png)

---
*注意：本教程仅用于网络安全学习与合法授权测试，请勿用于非法用途。*