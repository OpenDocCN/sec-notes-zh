![](img/8340173d6001c2f118288da59c6b8a90_1.png)

![](img/8340173d6001c2f118288da59c6b8a90_3.png)

![](img/8340173d6001c2f118288da59c6b8a90_5.png)

![](img/8340173d6001c2f118288da59c6b8a90_7.png)

# P182：196-LUA多线程控制 🧵

![](img/8340173d6001c2f118288da59c6b8a90_8.png)

在本节课中，我们将学习如何在Lua脚本中实现多线程控制。通过将不同的功能模块（例如自动打怪和血量检测）分离到独立的线程中运行，可以使程序结构更清晰，控制更灵活。

---

## 场景假设与设计思路

上一节我们介绍了多线程的基本概念，本节中我们来看看一个具体的应用场景。

假设我们有两个Lua脚本任务：
1.  一个脚本用于循环执行打怪操作。
2.  另一个脚本用于持续检测角色血量，并在血量过低时自动使用补血物品。

将这两个功能写在同一个循环中会难以控制，因为它们的执行条件和等待时间可能不同。将它们设计成两个独立的线程则更为方便。例如，当需要停止打怪时，血量保护的线程可以继续独立运行。

---

## 代码结构示例

![](img/8340173d6001c2f118288da59c6b8a90_10.png)

以下是两个线程脚本的功能代码示例。

**自动打怪线程脚本** 主要包含选择怪物、使用技能或攻击，并等待一定时间后循环执行。
```lua
-- 选择怪物
-- 使用技能或攻击
-- 等待8秒
```
**血量检测与保护线程脚本** 则持续监控血量，并在低于设定值时使用物品。
```lua
-- 获取当前HP
if HP < 500 then
    -- 使用补血物品
end
```

---

## 实现多线程环境

![](img/8340173d6001c2f118288da59c6b8a90_12.png)

为了实现两个Lua脚本的并行执行，我们需要在宿主程序（如Java）中创建和管理多个Lua状态机。

首先，我们需要修改原有的Lua环境初始化函数。因为要使用多个Lua环境，之前的全局变量方式不再适用。我们将在注册函数时完成初始化工作。

核心步骤是创建两个独立的Lua状态环境指针。以下是关键操作的概念性代码描述：
```java
// 创建第一个Lua状态机，用于执行脚本A
lua_State* L1 = luaL_newstate();
// 创建第二个Lua状态机，用于执行脚本B
lua_State* L2 = luaL_newstate();

// 分别为两个状态机注册所需的函数库
// ...

![](img/8340173d6001c2f118288da59c6b8a90_14.png)

// 分别加载并执行对应的Lua脚本文件
// ...

// 程序退出时，关闭两个状态机
lua_close(L1);
lua_close(L2);
```
在创建和关闭状态机时，应加入适当的异常处理，确保程序的健壮性。

![](img/8340173d6001c2f118288da59c6b8a90_16.png)

---

## 总结

本节课中我们一起学习了Lua多线程控制的基本方法。我们通过一个游戏脚本的例子，演示了如何将自动打怪和血量保护两个功能模块分离到独立的线程中。实现的关键在于在宿主程序中创建多个Lua状态机（`lua_State*`）来并行执行不同的脚本任务，从而使程序结构更清晰，控制更灵活。