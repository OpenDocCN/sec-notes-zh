# 课程 P10：021 - 分析动作数组与攻击捡物功能 🎮

在本节课中，我们将学习如何分析游戏中的动作数组，并找到调用攻击和捡物等动作功能的关键代码。这是为后续实现自动挂机打怪功能做准备。

## 概述

游戏的功能通常封装在动作数组中。本节课的目标是找到这个数组，并分析出调用其中特定动作（如攻击怪物）的方法。我们的分析思路是：通过观察游戏界面变化时内存数据的变动，定位到存储动作信息的变量，进而找到整个动作对象数组及其调用函数。

## 分析动作数组

![](img/400ea10845f1850de4ba72c7bc70f876_1.png)

![](img/400ea10845f1850de4ba72c7bc70f876_2.png)

上一节我们概述了目标，本节中我们来看看具体的分析步骤。首先，我们需要定位到游戏内部存储“当前选中动作”的变量。

![](img/400ea10845f1850de4ba72c7bc70f876_4.png)

![](img/400ea10845f1850de4ba72c7bc70f876_6.png)

1.  打开调试器（CE），附加到游戏进程。
2.  在未选择任何动作时，该变量值可能为0。我们可以首次扫描数值0。
3.  在游戏界面选中“攻击”动作。此时，该变量会被写入一个非零值（可能是对象地址或ID），用于表示“攻击”。我们接着扫描“增加的数值”。
4.  在游戏界面取消选择（放回），变量值应恢复为0。我们扫描“变动的数值”。
5.  重复步骤3和4数次（选中攻击->扫描增加的数值；取消选中->扫描变动的数值），可以逐步缩小结果范围。
6.  最终，我们可能会定位到一个或几个内存地址。记录下选中不同动作时，这些地址的值。

![](img/400ea10845f1850de4ba72c7bc70f876_8.png)

![](img/400ea10845f1850de4ba72c7bc70f876_10.png)

![](img/400ea10845f1850de4ba72c7bc70f876_12.png)

以下是记录到的三个可能对象的地址（示例）：
*   对象一地址：`0x5050`
*   对象二地址：`0x5298`
*   对象三地址：`0x5410`

![](img/400ea10845f1850de4ba72c7bc70f876_14.png)

![](img/400ea10845f1850de4ba72c7bc70f876_16.png)

![](img/400ea10845f1850de4ba72c7bc70f876_18.png)

## 定位动作对象数组

![](img/400ea10845f1850de4ba72c7bc70f876_20.png)

我们取得了几个疑似动作对象的地址。如果它们属于同一个数组，那么在内存中应该是连续存放的。我们可以通过查看内存区域来验证。

![](img/400ea10845f1850de4ba72c7bc70f876_22.png)

![](img/400ea10845f1850de4ba72c7bc70f876_23.png)

1.  在调试器中查看 `0x5050` 附近的内存。发现它指向一片包含多个对象的数据区域。
2.  查看 `0x5298` 附近的内存。发现它指向一个包含恰好12个对象的干净数组。
3.  查看 `0x5410` 附近的内存。发现它指向的数据区域包含对象过多，不够“干净”。

![](img/400ea10845f1850de4ba72c7bc70f876_25.png)

![](img/400ea10845f1850de4ba72c7bc70f876_27.png)

![](img/400ea10845f1850de4ba72c7bc70f876_29.png)

通过对比，第二个地址（`0x5298`）指向的包含12个对象的数组最有可能是我们寻找的**动作对象数组**。因为游戏中的动作（攻击、打坐、捡物等）通常就是12个。

![](img/400ea10845f1850de4ba72c7bc70f876_31.png)

![](img/400ea10845f1850de4ba72c7bc70f876_33.png)

## 查找数组基地址与结构

我们找到了数组中的一个对象，但我们需要找到这个数组的**基地址**（起始地址），以便通过索引访问所有动作。

![](img/400ea10845f1850de4ba72c7bc70f876_35.png)

1.  对找到的数组对象地址下内存访问断点。
2.  在游戏中切换动作，触发断点。观察是哪条指令在读取这个地址。
3.  分析该指令的寻址公式。通常形式为：`[[基地址] + 偏移A] + 偏移B + 索引*步长]`。
4.  通过回溯，找到稳定的绿色基地址。最终我们找到了动作数组的基地址 `0x3129298`。

![](img/400ea10845f1850de4ba72c7bc70f876_37.png)

![](img/400ea10845f1850de4ba72c7bc70f876_39.png)

![](img/400ea10845f1850de4ba72c7bc70f876_41.png)

其访问公式可以总结为：
```
动作对象地址 = [[0x3129298] + 0x410] + 索引 * 4
```
其中，`索引` 对应动作的编号（0-11）。

![](img/400ea10845f1850de4ba72c7bc70f876_43.png)

## 分析动作调用功能（CALL）

找到了动作数组，接下来我们需要找到**使用**这些动作的功能函数（CALL）。我们的思路是：监视对攻击动作对象的访问，从而找到调用它的代码。

1.  在内存中定位到攻击动作对象的地址（例如，索引为2）。
2.  对该地址下内存访问断点。
3.  在游戏中使用“攻击”功能（右键点击怪物）。这会触发断点。
4.  断点触发后，观察附近的代码。通常，在取出动作对象后，附近会有判断和调用功能函数（CALL）的代码。
5.  通过跟踪和测试不同的动作（如下标为1的打坐，下标为3的捡物），我们发现一个关键的函数调用（CALL）。

这个CALL的调用参数如下：
*   `ECX` 寄存器：来源于基地址 `[[0x3129298] + 0x488]` 的值。
*   `EDX` 寄存器：来源于动作对象地址 `+ 0x4C` 的值。
*   动作下标：通过 `EBX` 寄存器传递。

![](img/400ea10845f1850de4ba72c7bc70f876_45.png)

调用攻击功能（下标为2）的示例汇编代码大致如下：
```assembly
mov edi, [0x3129298]    ; 读取基地址
mov edi, [edi+0x410]     ; 第一层偏移
mov eax, [edi+ebx*4]     ; 通过索引获取动作对象地址，ebx=2
mov edx, [eax+0x4C]      ; 获取参数EDX
mov ecx, [0x3129298]     ; 重新读取基地址
mov ecx, [ecx+0x488]     ; 获取参数ECX
call 0x6796B0            ; 调用动作功能函数
```
通过修改 `EBX` 的值（0-11），即可调用对应的12种游戏动作。

![](img/400ea10845f1850de4ba72c7bc70f876_47.png)

## 总结

![](img/400ea10845f1850de4ba72c7bc70f876_49.png)

![](img/400ea10845f1850de4ba72c7bc70f876_51.png)

![](img/400ea10845f1850de4ba72c7bc70f876_53.png)

![](img/400ea10845f1850de4ba72c7bc70f876_55.png)

本节课中我们一起学习了逆向分析游戏功能的基本流程：
1.  **定位数据**：通过内存扫描，找到与游戏界面交互相关的关键变量和对象数组。
2.  **分析结构**：确定数组的基地址、索引方式和对象结构。
3.  **查找功能**：通过下断点跟踪，定位到操作这些数据的关键功能函数（CALL），并分析其调用约定和参数。

![](img/400ea10845f1850de4ba72c7bc70f876_57.png)

![](img/400ea10845f1850de4ba72c7bc70f876_59.png)

![](img/400ea10845f1850de4ba72c7bc70f876_60.png)

我们成功找到了游戏的动作数组 `[[0x3129298]+0x410]` 及其调用函数 `call 0x6796B0`。这为下一节课封装这些数据与功能，进而实现自动挂机逻辑打下了坚实的基础。