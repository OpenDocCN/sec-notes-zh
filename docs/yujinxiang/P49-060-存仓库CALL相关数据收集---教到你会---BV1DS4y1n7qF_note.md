# 逆向教程 P49：060-存仓库CALL相关数据收集 🧠

在本节课中，我们将学习如何通过逆向分析，定位并理解游戏中“存物品到仓库”这一功能背后的函数调用（CALL）及其相关数据结构。我们将从附加调试器开始，逐步分析数据发送、参数变化，最终尝试调用这个函数。

## 概述与准备

上一节我们介绍了物品背包的数据结构。本节中，我们来看看如何将背包中的物品存放到仓库。

![](img/2846f6f50e6efbbe707eac33addbfaa6_1.png)

存仓库操作通常涉及向服务器发送数据，表明某个物品已被存放。发送的数据中必然包含物品的唯一标识。这个标识可能有两种形式：一是使用背包物品栏的**下标**，二是访问物品对象内部的**物品ID属性**。无论哪种情况，在存放物品时，程序都需要访问该物品对象的属性（如下标或ID）。此外，程序还会向服务器发送相关数据。

有了这些基本认识，我们开始进行动态分析。

## 动态分析与下断点

首先，我们打开调试器并附加到游戏进程。

![](img/2846f6f50e6efbbe707eac33addbfaa6_1.png)

一般的游戏可以在 `send` 函数处下断点来拦截网络封包。但针对本游戏，我们需要在 `WSASend` 函数处下断点。下断后，游戏会立即中断。但此时中断并非最佳时机，因为我们还没有执行存仓库操作。

正确的做法是：先在背包中**选中**一个想要存放的物品。选中操作会将物品对象写入某个选中地址。然后，我们再在 `WSASend` 处下断点。接着，用鼠标点击仓库格子进行存放操作。此时，程序会向服务器发送存放该物品的数据包，并触发断点。

![](img/2846f6f50e6efbbe707eac33addbfaa6_3.png)

## 回溯调用栈

断点触发后，我们按下 `Ctrl+F9`（执行到返回）或利用调用栈窗口，一层层向上回溯，寻找调用发送函数的代码。目标是找到负责处理“存仓库”逻辑的函数。

以下是回溯过程中的关键步骤与备注：

1.  第一层是发包函数本身。
2.  继续向上返回，到达调用发包函数的地方。我们在此处备注“存仓库1”并下断点。
3.  再次执行到返回，备注“存仓库2”并下断。
4.  重复此过程，可以多返回几层（例如5-6层），并依次备注（如存仓库3、4、5...）。
5.  回溯足够多层后，按 `Alt+B` 打开断点列表，先**禁用**所有断点，让游戏继续运行。
6.  然后，只**激活**我们认为最可能是“存仓库”逻辑的那个断点（例如“存仓库6”）。

## 分析函数行为与参数

激活断点后，尝试进行存仓库操作。如果断点正确触发，我们就可以开始分析该函数的参数。

观察栈窗口，可以看到压入函数的参数。例如，我们分别尝试将物品存到仓库的第1、2、4格：

*   存到第1格：某个参数值为 `0`
*   存到第2格：该参数值变为 `1`
*   存到第4格：该参数值变为 `3`

这个参数恰好对应**仓库格子的下标**（从0开始）。同时，我们发现另外两个参数的值在多次调用中保持不变。

然而，进一步测试发现，在背包内**移动物品**时，这个函数也会被断下。这说明它可能是一个更通用的“物品移动”函数，而非专用的“存仓库”函数。

## 区分移动类型

为了区分是“背包内移动”还是“存到仓库”，我们需要观察其他参数。

我们发现，有一个参数用于表示**目标容器类型**：
*   值为 `8` 时，表示移动到**仓库**。
*   值为 `1` 时，表示在**玩家个人背包**内移动。

此外，寄存器 `ECX` 的值（`this` 指针）在不同操作下也不同，可能指向源容器（如背包）或目标容器（如仓库）的对象。

以下是多次测试后总结的规律：

*   **从仓库取物到背包**：`ECX` 值为 `0x648`，目标类型参数为 `1`。
*   **从背包存物到仓库**：`ECX` 值为 `0x418`，目标类型参数为 `8`。
*   无论存或取，仓库下标参数都正常变化，另一个参数常为 `0`。

## 尝试调用函数

基于以上分析，我们可以尝试用代码调用这个“物品移动”函数来模拟存/取操作。

以下是调用示例（伪代码）：

```cpp
// 从仓库取物品到背包（需先选中仓库内物品）
call MoveItemFunction(ECX=0x648, 目标容器类型=1, 仓库下标, 其他参数...);

// 从背包存物品到仓库（需先选中背包内物品）
call MoveItemFunction(ECX=0x418, 目标容器类型=8, 仓库下标, 其他参数...);
```

**核心要点**：
1.  调用前必须**先选中**要操作的物品。
2.  `ECX` 值和**目标容器类型**参数共同决定了操作方向（存或取）。
3.  **仓库下标**参数指定了物品要移动到的具体格子位置。

如果直接调用而不先选中物品，函数调用将没有效果。

## 总结与下节预告

本节课中我们一起学习了如何定位和分析游戏中的“物品移动”函数。我们发现，通过组合 `ECX` 值和目标类型参数，可以复用这个函数来实现“存仓库”和“取仓库”两种操作。但这需要前置的“选中物品”步骤。

我们找到的这个函数是一个通用的**物品移动CALL**。在它的内部，应该封装了更具体的“存物品到仓库”和“从仓库取物品”的逻辑。因此，它仍然是一个关键的突破口。

下节课，我们将进一步分析在回溯过程中备注的“存仓库1”等函数，看看是否存在更直接、更简洁的专用仓库操作函数，以优化我们的调用方式。