# 天草高级班 - P5：服务器检测破解教程 🔍

在本节课中，我们将学习如何对一个带有服务器检测和网络验证功能的加壳程序进行破解分析。我们将从脱壳开始，逐步定位关键验证代码，并尝试修改程序逻辑以达到绕过验证的目的。

![](img/0b1d1b90ed5a5f76d828998063bc3332_1.png)

![](img/0b1d1b90ed5a5f76d828998063bc3332_3.png)

---

## 脱壳与初步分析 🛡️

上一节我们介绍了课程目标，本节中我们来看看如何对目标程序进行脱壳和初步分析。

程序被一个压缩壳保护。虽然加壳，但其导入地址表（IAT）和API调用仍然可见，这表明它并非加密壳，这简化了我们的分析工作。

以下是脱壳的具体步骤：

1.  使用调试器载入程序。
2.  在程序入口点，使用`F8`进行单步执行。
3.  注意观察堆栈指针（ESP）的变化规律。一种常见方法是：在ESP寄存器内容发生变化后，对栈地址下硬件访问断点。
4.  运行程序（`Shift+F9`），程序会在断点处中断。此时可能已接近原始程序入口点（OEP）。
5.  通过反复尝试和跟踪（例如，连续按`F8`四次），最终定位到程序的真实OEP。

此外，还可以尝试使用“ESP定律”或通过单步跟踪总结出的特定断点来快速到达OEP。找到OEP后，即可使用工具进行脱壳和修复。

---

## 定位验证关键点 🎯

成功脱壳后，我们接下来需要定位程序进行服务器验证的关键代码位置。

程序启动后会尝试连接服务器进行验证，并提示“Not Regist”等错误信息。我们的目标是找到生成这些提示的逻辑判断处。

以下是定位关键点的步骤：

1.  在脱壳后的程序中，搜索字符串“Not Regist”或相关错误信息。
2.  在找到的字符串引用处下断点。
3.  重新运行程序，程序会在验证逻辑处中断。
4.  分析断点附近的代码，通常会发现决定程序流程的关键跳转指令（如`jnz`, `je`）。

在本例中，分析发现一个关键跳转：若跳转实现，则提示未注册；若跳转未实现，则验证通过。我们的初步思路就是修改这个跳转。

---

## 深入分析与补丁制作 ⚙️

仅仅修改一个跳转可能并不完美。程序可能在多处调用验证函数，我们需要找到最根本的验证函数并进行处理。

上一节我们找到了一个关键跳转，本节中我们来看看如何系统地找到并修改核心验证逻辑。

为了找到所有验证相关的调用，我们可以采取以下方法：

1.  在代码中查找所有调用验证函数（`call`）的指令。
2.  对这些调用点逐一进行测试和分析，判断哪个是程序启动时执行的主验证流程。
3.  进入关键的`call`内部进行分析。通常，验证函数会检查机器码、邮箱地址等信息，并通过返回值（通常存放在`EAX`寄存器中）判断是否成功。
4.  我们的目标是让验证函数返回一个表示成功的值（例如`0`）。可以通过修改验证函数内部的比较指令或直接修改其返回值来实现。

例如，在分析中，我们发现验证函数内部会将`EAX`与`0`比较。我们可以将`test eax, eax`之类的指令修改为`xor eax, eax`，从而强制让`EAX`为`0`，使后续判断走向成功分支。

```
; 修改前，EAX值影响跳转
test eax, eax
jnz failed_label

; 修改后，强制EAX=0，确保跳转不实现
xor eax, eax
test eax, eax
jnz failed_label ; 此句将永远不会跳转
```

---

## 尝试制作内存补丁 💉

直接修改程序文件（打补丁）是另一种方法。但有时程序代码段没有足够空间写入新指令，我们可以尝试制作内存补丁。

上一节我们通过修改代码逻辑实现了破解，本节中我们来看看另一种方法——内存补丁。

内存补丁的思路是：在程序运行时，将一小段我们自己的代码注入到进程空间，由这段代码来修改关键的验证逻辑。

以下是基本步骤：

1.  定位需要修改的指令在内存中的确切地址。
2.  编写一小段汇编代码，用于修改目标地址的指令（例如，将`jnz`改为`jmp`）。
3.  这段补丁代码需要被插入到程序代码的“空隙”处（即全是`00`或`90`等无效数据的区域）。
4.  修改程序入口点或某个早期调用的函数，使其首先执行我们的补丁代码，然后再继续原流程。

然而，这种方法实施起来较为复杂，需要精确计算地址和跳转，并且找到合适的代码空隙也不容易。在本案例的尝试中，由于地址空间问题，未能成功制作出有效的文件补丁。

---

## 总结与练习 📝

本节课中我们一起学习了针对带服务器检测的加壳程序的完整破解流程。

我们首先对压缩壳进行了手动脱壳。接着，通过字符串检索定位到验证提示信息，并分析了关键跳转。为了更彻底地破解，我们深入追踪了验证函数的调用，并修改了其内部逻辑，强制返回验证成功。最后，我们还探讨了制作内存补丁的复杂性和挑战。

**核心要点总结：**
*   **脱壳**：观察IAT和ESP变化，使用断点法定位OEP。
*   **定位**：利用字符串检索找到程序验证逻辑入口。
*   **分析**：逆向关键`call`和跳转指令，理解验证流程。
*   **修改**：通过汇编指令（如`xor eax, eax`）改变程序执行路径。
*   **公式/代码表示关键修改：**
    ```assembly
    ; 关键修改：将影响流程的寄存器置零
    mov eax, 0 ; 或 xor eax, eax
    ; 替代了原本可能失败的比较或赋值操作
    ```

![](img/0b1d1b90ed5a5f76d828998063bc3332_5.png)

建议课后寻找类似软件进行练习，巩固脱壳、关键点定位和代码修改的技能。也可以尝试下载该软件的新版本，分析其验证机制是否发生变化。