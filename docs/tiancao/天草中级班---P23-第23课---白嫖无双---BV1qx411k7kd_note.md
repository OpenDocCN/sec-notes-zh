# 天草中级班 - P23：第23课 - 白嫖无双 🛡️➡️🔓

在本节课中，我们将学习如何对一个使用“address-protect”保护的软件进行脱壳与破解。该保护强度较高，我们将通过OllyDbg（OD）和Import REC等工具，定位关键跳转，修改关键数据，最终解除软件的功能限制。

---

![](img/1d0664eebbaab20063026fd242b97566_1.png)

## 一、 程序载入与初步分析 🔍

![](img/1d0664eebbaab20063026fd242b97566_3.png)

首先，我们使用OllyDbg载入目标程序。

![](img/1d0664eebbaab20063026fd242b97566_1.png)

载入后，程序停在入口点。

![](img/1d0664eebbaab20063026fd242b97566_3.png)

单步执行时，发现程序存在往回跳转的循环结构。这通常是壳进行解码或解压的典型特征。我们在该循环处下一个**硬件断点**（F2断点），以便分析。

![](img/1d0664eebbaab20063026fd242b97566_5.png)

---

## 二、 处理解码循环与定位OEP 🎯

![](img/1d0664eebbaab20063026fd242b97566_7.png)

程序内部存在大量花指令。在地址`2966`处，可以看到类似“石精制”的代码。`ECX`寄存器被赋值为`16`，然后跳转到`B96`。

![](img/1d0664eebbaab20063026fd242b97566_9.png)

按`F9`运行，程序会执行一次解码循环。如果循环次数很多，手动跟踪效率低下。我们可以尝试修改`EIP`（指令指针）直接跳过这个解码循环。

![](img/1d0664eebbaab20063026fd242b97566_5.png)

![](img/1d0664eebbaab20063026fd242b97566_11.png)

成功跳过循环后，我们打开内存映射窗口。首先忽略所有异常，然后在`.text`等代码区段上设置内存访问断点。

![](img/1d0664eebbaab20063026fd242b97566_7.png)

再次运行程序。

![](img/1d0664eebbaab20063026fd242b97566_9.png)

发现内存访问断点未能成功中断。我们换用**硬件执行断点**（F2）。

![](img/1d0664eebbaab20063026fd242b97566_13.png)

![](img/1d0664eebbaab20063026fd242b97566_11.png)

程序中断在一堆看似乱码的指令中，这是从壳的一个跳转过来的。我们观察堆栈，发现一个`CALL`指令，其参数可能指向原始程序入口点（OEP）。

![](img/1d0664eebbaab20063026fd242b97566_15.png)

在反汇编窗口中跟随该地址，并在此处下**硬件执行断点**。按`Shift+F9`（忽略异常运行）让程序继续执行。

程序中断后，观察`EDI`寄存器，其值就是我们要找的**OEP**。

![](img/1d0664eebbaab20063026fd242b97566_17.png)

我们直接跳转到`EDI`指向的地址，并在此处下断点。再次按`Shift+F9`运行，程序将停在OEP。

![](img/1d0664eebbaab20063026fd242b97566_19.png)

---

## 三、 脱壳与修复导入表 💾

![](img/1d0664eebbaab20063026fd242b97566_21.png)

成功到达OEP后，就可以进行脱壳了。打开`Import REC`工具。

![](img/1d0664eebbaab20063026fd242b97566_23.png)

![](img/1d0664eebbaab20063026fd242b97566_13.png)

![](img/1d0664eebbaab20063026fd242b97566_24.png)

在`Import REC`中，选择我们正在调试的进程，并填入OEP的地址（RVA值）。点击“自动查找IAT”，然后点击“获取输入表”。

![](img/1d0664eebbaab20063026fd242b97566_15.png)

此时可能会发现非常多的无效指针。点击“修复转储”，选择刚才从OD中脱壳保存出来的文件，`Import REC`会自动修复这些无效指针。

修复完成后，我们得到一个可运行的脱壳后程序。

![](img/1d0664eebbaab20063026fd242b97566_26.png)

![](img/1d0664eebbaab20063026fd242b97566_17.png)

运行脱壳后的程序。

![](img/1d0664eebbaab20063026fd242b97566_19.png)

![](img/1d0664eebbaab20063026fd242b97566_28.png)

程序界面显示许多功能被“锁”住了，并弹出提示框“I‘m sorry...”，表明这是一个试用版本，功能受限。

![](img/1d0664eebbaab20063026fd242b97566_21.png)
![](img/1d0664eebbaab20063026fd242b97566_23.png)
![](img/1d0664eebbaab20063026fd242b97566_24.png)

![](img/1d0664eebbaab20063026fd242b97566_30.png)

---

## 四、 分析并破解注册验证 🔑

![](img/1d0664eebbaab20063026fd242b97566_32.png)

我们的目标是解除这些功能锁。在OD中重新载入**脱壳后**的程序进行破解分析。

在反汇编窗口中**搜索字符串**，寻找关键提示信息。我们搜索到了包含“Tarot”的字符串。

![](img/1d0664eebbaab20063026fd242b97566_34.png)

![](img/1d0664eebbaab20063026fd242b97566_26.png)

找到了两处引用。我们先分析第一处。

![](img/1d0664eebbaab20063026fd242b97566_28.png)

该处是一个函数调用（如`Foo_Tarot`），这很可能是验证功能是否解锁的关键函数。我们在此处下断点。

![](img/1d0664eebbaab20063026fd242b97566_30.png)

在OD的异常设置中，忽略所有异常（勾选所有选项），以免影响程序运行。

![](img/1d0664eebbaab20063026fd242b97566_32.png)

运行程序，并点击菜单栏的“About”或触发验证的按钮，程序会在我们下的断点处中断。

![](img/1d0664eebbaab20063026fd242b97566_36.png)

![](img/1d0664eebbaab20063026fd242b97566_34.png)

观察中断处的代码：
```assembly
TEST AL, AL
JNZ SHORT XXXXXX
```
这段代码的意思是测试`AL`寄存器的值。如果`AL`不等于0（`JNZ`跳转成立），程序会跳转到“功能锁定”的流程；如果`AL`等于0，则不跳转，继续执行“功能解锁”的流程。

![](img/1d0664eebbaab20063026fd242b97566_38.png)

因此，我们的目标是让`AL`**不等于0**。

向上追溯`AL`值的来源，发现它来自局部变量`[EBP-2]`。

![](img/1d0664eebbaab20063026fd242b97566_40.png)

```assembly
MOV AL, BYTE PTR SS:[EBP-2]
```

![](img/1d0664eebbaab20063026fd242b97566_41.png)

我们在给`[EBP-2]`赋值的指令上下断点，发现它被赋值为`0`。

我们将此赋值语句的结果改为`1`。

![](img/1d0664eebbaab20063026fd242b97566_43.png)

![](img/1d0664eebbaab20063026fd242b97566_36.png)

修改后，继续单步执行。此时`AL=1`，`TEST AL, AL`的结果非零，`JNZ`条件成立，程序跳转到了我们希望的分支。

![](img/1d0664eebbaab20063026fd242b97566_45.png)

将此处修改保存到可执行文件。

![](img/1d0664eebbaab20063026fd242b97566_47.png)

![](img/1d0664eebbaab20063026fd242b97566_38.png)

运行破解后的程序，所有功能锁都已消失，软件可以正常使用。

![](img/1d0664eebbaab20063026fd242b97566_40.png)
![](img/1d0664eebbaab20063026fd242b97566_41.png)
![](img/1d0664eebbaab20063026fd242b97566_43.png)

![](img/1d0664eebbaab20063026fd242b97566_49.png)

---

## 五、 处理第二处验证点 ✅

之前我们发现了两个“Tarot”字符串引用。现在来验证并破解第二处。

在字符串列表中定位到第二个“Tarot”引用，并跟随到反汇编代码处。

![](img/1d0664eebbaab20063026fd242b97566_51.png)

![](img/1d0664eebbaab20063026fd242b97566_49.png)

![](img/1d0664eebbaab20063026fd242b97566_53.png)

其代码结构与第一处非常相似。同样在关键判断处下断点，运行程序使其中断。

![](img/1d0664eebbaab20063026fd242b97566_51.png)

![](img/1d0664eebbaab20063026fd242b97566_55.png)

采用同样的方法，找到决定`AL`值的源头，并将其从`0`修改为`1`。

![](img/1d0664eebbaab20063026fd242b97566_56.png)

保存修改。

![](img/1d0664eebbaab20063026fd242b97566_58.png)

![](img/1d0664eebbaab20063026fd242b97566_53.png)

![](img/1d0664eebbaab20063026fd242b97566_60.png)

运行程序，软件启动后直接显示为已注册的“复活”版本，所有功能均可正常使用。

![](img/1d0664eebbaab20063026fd242b97566_62.png)

![](img/1d0664eebbaab20063026fd242b97566_55.png)
![](img/1d0664eebbaab20063026fd242b97566_56.png)
![](img/1d0664eebbaab20063026fd242b97566_58.png)

至此，两处关键验证均已破解，达到了解除软件限制的目的。

![](img/1d0664eebbaab20063026fd242b97566_64.png)

![](img/1d0664eebbaab20063026fd242b97566_60.png)
![](img/1d0664eebbaab20063026fd242b97566_62.png)
![](img/1d0664eebbaab20063026fd242b97566_64.png)

![](img/1d0664eebbaab20063026fd242b97566_66.png)

---

## 六、 总结与延伸思考 🤔

本节课中，我们一起学习了针对一个较强保护壳的完整脱壳与破解流程：

1.  **脱壳阶段**：使用OllyDbg跟踪解码循环，通过硬件断点定位原始程序入口点（OEP），然后利用Import REC工具成功脱壳并修复导入表。
2.  **破解阶段**：在脱壳后的程序中，通过搜索关键字符串定位验证函数。分析关键跳转逻辑（`TEST AL, AL / JNZ`），逆向追踪关键数据的来源，并通过修改其值（将`0`改为`1`）来改变程序执行流程，最终解除了软件的功能限制。

需要注意的是，本次破解的程序可能未启用最强的保护选项。如果启用了更多反调试或代码混淆技术，破解难度会增大，甚至可能出现假死等现象。建议大家课后可以寻找更多相关资料进行深入研究与实践。

![](img/1d0664eebbaab20063026fd242b97566_68.png)

![](img/1d0664eebbaab20063026fd242b97566_66.png)
![](img/1d0664eebbaab20063026fd242b97566_68.png)

再见。