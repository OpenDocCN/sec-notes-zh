# 天草高级班 - P15：WinMPG VideoConvert 破解教程 🔓

在本节课中，我们将学习如何破解 WinMPG VideoConvert 软件。我们将从尝试不同的破解思路开始，逐步分析程序逻辑，最终找到关键跳转并修改代码，实现软件的完全破解。整个过程涉及动态调试、回溯分析、内存修改和补丁制作。

---

## 概述与初步尝试

运行程序后，会看到一个注册窗口。输入错误的注册码会提示错误。注册信息保存在特定位置。

首先尝试直接载入程序进行分析，但发现程序结构特殊，跳转指令（JMP）非常多，直接跟踪容易迷失方向，这是第一种方案，但效果不佳。

![](img/776fed27c2901c3aa766ed66eee030b0_1.png)

---

![](img/776fed27c2901c3aa766ed66eee030b0_3.png)

## 第二种思路：利用错误提示回溯

![](img/776fed27c2901c3aa766ed66eee030b0_5.png)

上一节我们尝试直接跟踪但失败了。本节中我们来看看利用程序的错误提示信息进行回溯分析的方法。

![](img/776fed27c2901c3aa766ed66eee030b0_7.png)

程序有明确的错误提示，这为我们提供了切入点。使用暂停执行的方法（如F12暂停），在错误提示出现的代码行设置断点。

![](img/776fed27c2901c3aa766ed66eee030b0_9.png)

以下是回溯分析的核心步骤：

![](img/776fed27c2901c3aa766ed66eee030b0_11.png)

1.  在错误提示出现的代码行设置断点。
2.  程序中断后，向上回溯调用栈，寻找导致错误的分支跳转来源。
3.  由于跳转极多，需要耐心地、逐层向上跟踪，并在关键跳转处设置断点作为路标，防止跟错。
4.  回溯的目标是找到一个非无条件跳转（如 `JZ`, `JNZ` 等条件跳转指令），它决定了程序是走向成功还是错误分支。

![](img/776fed27c2901c3aa766ed66eee030b0_13.png)

![](img/776fed27c2901c3aa766ed66eee030b0_15.png)

![](img/776fed27c2901c3aa766ed66eee030b0_17.png)

![](img/776fed27c2901c3aa766ed66eee030b0_19.png)

这个过程相当有难度，因为程序几乎全部使用 `JMP` 指令来模拟函数调用，导致调用链非常扁平且混乱。

![](img/776fed27c2901c3aa766ed66eee030b0_21.png)

![](img/776fed27c2901c3aa766ed66eee030b0_23.png)

---

![](img/776fed27c2901c3aa766ed66eee030b0_25.png)

![](img/776fed27c2901c3aa766ed66eee030b0_27.png)

## 发现关键跳转与初步修改

![](img/776fed27c2901c3aa766ed66eee030b0_29.png)

![](img/776fed27c2901c3aa766ed66eee030b0_31.png)

通过艰难的回溯，我们最终找到了一个关键的条件跳转指令 `JE`。该跳转依赖于 `EAX` 寄存器的值。

![](img/776fed27c2901c3aa766ed66eee030b0_33.png)

![](img/776fed27c2901c3aa766ed66eee030b0_35.png)

![](img/776fed27c2901c3aa766ed66eee030b0_37.png)

*   **关键逻辑**：`EAX` 为 0 时跳转，导致注册失败；`EAX` 不为 0 时则不跳，可能走向成功。
*   **修改尝试**：在调试器中修改该 `JE` 指令为 `NOP`（空操作）或直接修改 `EAX` 寄存器的值为 1。

![](img/776fed27c2901c3aa766ed66eee030b0_39.png)

进行此修改后，程序提示注册成功，界面上的“华军购买”按钮变成了“访问主页”。然而，关闭程序重新启动后，依然弹出注册窗口，这说明存在重启验证。

![](img/776fed27c2901c3aa766ed66eee030b0_41.png)

---

![](img/776fed27c2901c3aa766ed66eee030b0_43.png)

![](img/776fed27c2901c3aa766ed66eee030b0_45.png)

## 第三种思路：从界面变化入手

上一节我们虽然找到了一个关键点，但未能解决重启验证。本节我们来看看一个更有效的突破口：程序界面在注册成功后的变化。

我们注意到，注册成功后，程序界面上的“华军购买”字样会变为“访问主页”。这是一个明确的标志，我们可以通过搜索内存中这些字符串的引用地址来定位关键代码。

以下是具体操作步骤：

![](img/776fed27c2901c3aa766ed66eee030b0_47.png)

1.  在内存中搜索字符串“访问主页”。
2.  在找到的引用地址处设置断点。
3.  运行程序并尝试注册，观察断点何时被触发。
4.  分析断点附近的代码，特别是哪些指令或函数调用决定了这个字符串的显示。

通过跟踪，我们发现了一个关键的函数调用（CALL）。这个函数负责处理注册状态并更新界面。进一步跟踪这个函数，我们发现了决定注册状态的核心机制。

---

## 深入核心：分析验证算法与内存修改

跟踪到关键函数内部后，我们使用内存转存功能监视相关数据的变化。

我们发现一个重要现象：程序会将我们输入的注册名的前四个字符的内存区域清零。例如，注册名 `“WYNEYR”`，在内存中其前四个字符 `“WYNE”` 对应的字节被置为 `00`。

*   **关键内存地址**：例如 `0012C8B8`，此处存放了处理后的注册名信息。
*   **关键指令**：存在类似 `MOV BYTE PTR [EAX], 00` 的指令，将内存字节清零。
*   **破解关键**：我们需要阻止这个清零操作，或者将清零后的值改为有效值（如 `01`）。

我们在调试器中手动将清零后的内存字节从 `00` 改为 `01`，程序界面立即显示为已注册状态，并且重启后验证也通过了。这证实了我们的分析是正确的。

![](img/776fed27c2901c3aa766ed66eee030b0_49.png)

![](img/776fed27c2901c3aa766ed66eee030b0_51.png)

---

![](img/776fed27c2901c3aa766ed66eee030b0_53.png)

![](img/776fed27c2901c3aa766ed66eee030b0_55.png)

## 编写补丁代码

![](img/776fed27c2901c3aa766ed66eee030b0_57.png)

![](img/776fed27c2901c3aa766ed66eee030b0_59.png)

![](img/776fed27c2901c3aa766ed66eee030b0_61.png)

由于直接修改内存只是临时生效，我们需要修改程序文件本身。目标地址的代码空间有限，我们需要写入自定义的汇编代码。

![](img/776fed27c2901c3aa766ed66eee030b0_63.png)

![](img/776fed27c2901c3aa766ed66eee030b0_65.png)

我们需要实现的功能是：在程序试图将关键内存位置清零时，我们将其设置为 `01`。

![](img/776fed27c2901c3aa766ed66eee030b0_67.png)

**补丁代码逻辑如下：**
```assembly
; 原指令可能是：MOV BYTE PTR [EAX], 00
; 我们将其修改为：
MOV BYTE PTR [EAX], 01 ; 将00改为01
; 然后继续执行原程序后续的指令（可能需要一个JMP跳回原流程）
```
由于空间不足，我们可能需要将原指令替换为一个 `JMP` 指令，跳转到程序文件其他空白区域执行我们编写的上述代码，然后再跳转回来。

![](img/776fed27c2901c3aa766ed66eee030b0_69.png)

![](img/776fed27c2901c3aa766ed66eee030b0_71.png)

![](img/776fed27c2901c3aa766ed66eee030b0_73.png)

使用十六进制编辑器或专用补丁工具，将找到的 `00` 字节修改为 `01`，并妥善处理代码跳转。修改后保存文件，即可获得破解版。

![](img/776fed27c2901c3aa766ed66eee030b0_75.png)

![](img/776fed27c2901c3aa766ed66eee030b0_77.png)

![](img/776fed27c2901c3aa766ed66eee030b0_79.png)

---

![](img/776fed27c2901c3aa766ed66eee030b0_81.png)

![](img/776fed27c2901c3aa766ed66eee030b0_83.png)

## 制作补丁程序

![](img/776fed27c2901c3aa766ed66eee030b0_85.png)

![](img/776fed27c2901c3aa766ed66eee030b0_86.png)

为了方便分发，我们可以制作一个补丁程序（Patch）。补丁程序会自动比较原始文件和已破解文件的差异，并将差异部分应用到用户的本机程序上。

可以使用如 `“Patch Maker”` 之类的工具。流程如下：
1.  选择原始文件（`Original`）和已破解的文件（`Patched`）。
2.  工具会自动比较差异。
3.  设置补丁程序的界面信息（如皮肤、图标）。
4.  生成一个独立的 `EXE` 补丁程序。用户运行此补丁，选择其本机的原始程序，即可自动完成破解。

![](img/776fed27c2901c3aa766ed66eee030b0_88.png)

![](img/776fed27c2901c3aa766ed66eee030b0_90.png)

![](img/776fed27c2901c3aa766ed66eee030b0_92.png)

---

## 总结与思路回顾

本节课中我们一起学习了破解 WinMPG VideoConvert 软件的完整过程。

我们尝试并总结了三种思路：
1.  **直接跟踪法**：因程序跳转过多而失败，但这是最初的尝试。
2.  **错误提示回溯法**：通过错误信息定位，逆向回溯找到关键跳转。此方法可行但过程繁琐，找到了一个关键点，但未解决重启验证。
3.  **界面特征分析法**：通过观察注册成功后的界面变化（“华军购买”变“访问主页”），搜索字符串引用，定位到核心验证函数。通过内存转存跟踪，发现了程序将注册名前四字符清零的验证逻辑，并通过修改内存和最终编写补丁代码实现了完美破解。

**核心技巧**包括：利用程序反馈信息、字符串搜索、内存断点与转存分析、以及在小空间内编写并注入自定义汇编代码。

![](img/776fed27c2901c3aa766ed66eee030b0_94.png)

破解的关键在于**思路的灵活转换**和**对程序行为的细致观察**。从失败的方法中吸取教训，找到更有效的突破口，是逆向工程中的重要能力。请务必按照这三种思路多练习几次，以深刻理解其中的每一步。