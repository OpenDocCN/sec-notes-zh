# 天草高级班 - P3：跳过服务器检测 🛡️

![](img/04a15dd0ef0b65972ebfcf688ab0d249_1.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_3.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_5.png)

在本节课中，我们将学习如何逆向分析一个具有网络验证功能的软件，并跳过其服务器检测，从而实现“白嫖”使用。整个过程涉及脱壳、定位关键跳转、修改程序逻辑等步骤。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_7.png)

## 概述与脱壳 🧩

首先，我们面对的是一个需要连接服务器进行验证的软件。它提供试用功能，但我们的目标是绕过这个验证。

我们首先需要对软件进行脱壳处理。该软件使用了SPEC壳，我们使用Proxylin工具进行脱壳。脱壳完成后，我们找到了程序的原始入口点（OEP）。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_9.png)

## 定位关键代码与提示框 🔍

![](img/04a15dd0ef0b65972ebfcf688ab0d249_11.png)

上一节我们完成了脱壳，本节中我们来看看如何定位程序中的验证逻辑。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_13.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_15.png)

我们使用F12暂停法来寻找程序弹出提示框的相关代码。当程序运行并弹出提示框时，我们暂停它，然后在调用堆栈中寻找返回地址。

以下是定位关键调用过程的步骤：
1.  在程序运行时按下F12暂停。
2.  在调用堆栈（Stack）中右键点击返回地址，选择“在反汇编中跟随”。
3.  这样就定位到了调用提示框函数的位置。我们在该调用的起始处（断首）下一个断点。
4.  重新载入程序，运行后会断在我们下的断点处。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_17.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_19.png)

## 分析并修改验证跳转 ⚙️

找到了关键调用后，我们需要分析其周围的判断逻辑。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_21.png)

我们单步执行（F8）代码，观察寄存器和跳转指令。关键点通常是一个比较（`CMP`）指令后跟一个条件跳转（如`JE`或`JNZ`）。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_23.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_25.png)

例如，我们可能看到类似这样的代码：
```
CMP EBX, 0
JE SHORT 跳过验证
CALL <验证函数>
```
我们的目标是让程序执行`JE`跳转，从而绕过`CALL <验证函数>`。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_27.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_29.png)

直接修改`JE`为无条件跳转`JMP`是一种方法，但有时修改的字节较多。另一种更精巧的方法是修改前面的代码，确保比较条件成立。例如，如果`CMP EBX, 0`判断`EBX`是否为0，我们可以在前面添加指令将`EBX`清零：
```
MOV EBX, 0
NOP
NOP
```
这样就能保证跳转发生。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_31.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_33.png)

## 处理网络验证与版本判断 🌐

![](img/04a15dd0ef0b65972ebfcf688ab0d249_35.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_37.png)

跳过了本地提示框后，程序可能还会尝试连接服务器进行网络验证。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_39.png)

我们继续使用断点法，寻找连接服务器或进行网络验证的`CALL`指令。找到之后，我们的目标通常是直接“NOP掉”（用空指令`0x90`填充）这个调用，或者修改其前面的跳转逻辑，使其无法执行。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_41.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_43.png)

此外，软件可能有“标准版”和“专业版”之分，验证结果会影响显示的版本。我们需要找到判断版本的代码位置。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_45.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_47.png)

以下是修改的关键点列表：
1.  **网络验证调用**：找到类似`CALL [API函数]`或`CALL <内部验证函数>`的指令，将其NOP掉。
2.  **版本标志判断**：寻找比较版本字符串（如“Standard”和“PRO”）的代码，修改跳转，让程序始终走向“专业版”分支。
3.  **多处修改**：此类验证通常不止一处，需要耐心寻找并修改所有相关跳转和调用。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_49.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_51.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_53.png)

在修改过程中，建议使用OD的笔记插件记录下每个修改的地址和内容，方便后续管理和保存补丁。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_55.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_57.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_58.png)

## 测试与总结 ✅

完成所有修改后，保存对程序的更改（打补丁），然后运行测试。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_60.png)

本节课中我们一起学习了逆向分析中跳过服务器检测的完整流程：
1.  **脱壳**：为分析原始代码做准备。
2.  **定位**：使用F12暂停法定位关键函数调用。
3.  **分析**：阅读汇编代码，理解验证逻辑和关键跳转。
4.  **修改**：通过修改指令或数据，改变程序执行流程，绕过验证和版本限制。
5.  **测试**：验证修改是否成功，软件功能是否正常。

![](img/04a15dd0ef0b65972ebfcf688ab0d249_62.png)

![](img/04a15dd0ef0b65972ebfcf688ab0d249_64.png)

这个过程锻炼了代码跟踪、逻辑分析和手动打补丁的能力。请务必自行练习，巩固所学知识。