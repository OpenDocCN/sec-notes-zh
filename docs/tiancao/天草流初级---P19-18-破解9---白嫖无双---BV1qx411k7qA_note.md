![](img/8fdba40f007dc6c259a07c1ee01c0f11_1.png)

# 天草流初级破解教程 - P19：第18课 - 破解重启验证型软件 🔍

在本节课中，我们将学习如何破解一个具有“重启验证”机制的软件。这类软件在注册成功后，需要重新启动程序才能生效，其验证信息通常存储在注册表或文件中。我们将通过定位关键验证代码、分析注册表操作，最终实现破解。

---

## 一、 目标程序与初步分析 🎯

本节课的目标程序是一个带有注册验证功能的工具。运行程序时，可能会提示“使用期已满”。

![](img/8fdba40f007dc6c259a07c1ee01c0f11_1.png)

如果您的程序未提示过期，请将系统时间调整到较早的日期（例如2006年或2007年），以触发验证界面。

首先，我们使用查壳工具检查程序。结果显示程序由 **BC++ (Borland C++)** 编写。对于这类程序，一个常见的分析思路是使用 **F12暂停法** 来定位关键代码。

---

## 二、 定位按钮事件 🔘

上一节我们确认了程序类型，本节我们来看看如何定位其验证逻辑的入口。

程序界面有多个按钮，我们需要找到触发注册验证的那个按钮事件。

1.  使用相关工具（如SPY++或ResHacker）查看按钮属性。
2.  发现“注册”按钮的标识为 **`Button register`**，“确定”按钮的标识为 **`Button OK`**。
3.  我们的目标是找到 **`Button OK`** 的点击事件处理函数。

以下是记录的关键标识：
*   `Button register` - 对应“购买”
*   `Button OK` - 对应“确定”（验证按钮）

---

## 三、 动态调试与寻找关键跳转 ⚙️

找到按钮事件后，我们使用OD（OllyDbg）载入程序进行动态调试。

1.  在OD中，在 **`Button OK`** 的事件处理函数入口处下断点。
2.  运行程序，输入任意注册码并点击“确定”，程序会在断点处中断。
3.  单步执行（F8），观察程序流程。
4.  很快会遇到一个条件跳转指令，其下方是“注册码无效”的提示字符串。

```assembly
CMP ... ; 比较指令
JNZ ... ; 条件跳转，跳向“注册码无效”
```

5.  记录下这个跳转的地址。如果让这个跳转实现（即跳转），则提示失败；如果**修改标志位或NOP掉跳转指令**，使其不跳转，程序会继续执行。
6.  尝试NOP掉这个跳转后，程序提示“注册码正确，但已过期”。这说明我们找到了一个验证点，但并非最终关键。

---

## 四、 发现重启验证机制 🔄

上一节我们修改了一个跳转，但并未完全成功。本节中我们来看看程序更深层的验证机制。

当我们尝试让程序显示“注册码正确”并关闭后重新启动时，程序依然提示“使用期已满”。这表明程序存在 **重启验证** 机制。

重启验证意味着：
*   程序在本次运行时，会将注册成功的信息写入某个持久化位置（如注册表或文件）。
*   下次启动时，程序会从该位置读取信息进行验证。

因此，我们的破解思路需要转向：**找到程序写入和读取注册信息的位置**。

---

## 五、 追踪注册表操作 📝

既然程序验证与重启相关，我们需要监控其对系统的操作。以下是查找其存储位置的方法。

**方法一：字符串搜索**
在OD中搜索所有字符串，发现了一些与注册表路径相关的片段（如`Software\...`），但信息不完整。

**方法二：API断点法（本节课核心）**
更高效的方法是直接对操作注册表的API函数下断点。我们关注 **`RegOpenKey`** 和 **`RegQueryValue`** 这类函数。

1.  在OD中按 `Ctrl+N` 打开API调用窗口。
2.  查找 **`RegOpenKeyA/Ex`** 函数。
3.  右键点击该函数，选择 **“在每个参考上设置断点”**。
4.  运行程序，OD会在每次程序尝试打开注册表项时中断。
5.  通过观察堆栈或函数参数，可以判断程序正在读取哪个路径。我们过滤掉系统相关的无关操作，直到找到程序读取我们输入的“用户名”和“注册码”的键值（例如名为`3800CC`的键值）。

这个过程直接定位到了程序验证数据的源头。

---

## 六、 分析并修改验证逻辑 💡

找到读取注册信息的代码后，我们在其附近进行分析。

1.  单步跟踪，会发现另一处**关键比较和跳转**。此处的逻辑结构与之前找到的类似，但它是决定是否显示“0用户授权”或“站点授权”的核心判断。
2.  程序会比较从注册表读取的数据与某种算法生成的结果。
3.  我们找到这个决定最终授权状态的关键跳转（`JNZ`或`JE`），并将其**NOP掉或修改为相反逻辑**。

```assembly
; 修改前，跳转则失败
CMP EAX, EBX
JNZ SHORT 失败地址

; 修改后，强制跳转失效，走向成功流程
CMP EAX, EBX
NOP
NOP
; 或者直接改为 JMP 到成功地址
```

4.  修改后，保存程序。再次运行，无论注册表内信息如何，程序都会显示正确的授权信息（如“站点授权”）。

---

## 七、 总结与要点 ✅

本节课中我们一起学习了破解具有重启验证机制软件的全过程。

**核心步骤总结：**
1.  **初步分析**：查壳，确定开发语言，使用F12暂停法定位入口。
2.  **定位事件**：找到验证按钮的事件处理函数。
3.  **动态调试**：在OD中跟踪，找到第一个验证跳转（通常为明码比较）。
4.  **识别机制**：发现修改后仍需重启生效，从而判定为重启验证型。
5.  **追踪数据**：使用 **API断点法**（对`RegOpenKey`设断）高效定位程序读写注册表的关键代码。
6.  **破解关键**：在读取注册表数据后的验证逻辑处，找到并修改最终的核心跳转指令。

**关键技巧：**
*   对于重启验证，重点追踪程序对**文件或注册表**的读写操作。
*   **`Ctrl+N` 查找API并下参考断点**，是快速定位系统调用的高效方法。
*   破解的最终目标通常是让验证函数**无论输入何值都返回成功状态**。

通过本课的学习，你应该掌握了应对简单重启验证软件的基本思路和实战方法。关键在于耐心跟踪数据流，并熟练运用调试工具的各种断点功能。

![](img/8fdba40f007dc6c259a07c1ee01c0f11_3.png)

![](img/8fdba40f007dc6c259a07c1ee01c0f11_3.png)