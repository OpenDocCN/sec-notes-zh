![](img/1a017bc136190fbb202c3486a49d0dc4_1.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_3.png)

# 课程 P20：021 - 引爆事件驱动宝库：基于WMI的用户空间攻击使SIEM失明 🎯

在本节课中，我们将学习Windows管理规范（WMI）的架构、其在安全领域中的应用，以及一系列针对WMI的新型攻击技术。这些攻击能够使依赖WMI进行设备遥测收集的安全解决方案（如EDR、SIEM）失效。我们还将探讨如何检测和防御这些攻击。

## WMI架构与特性概述 🏗️

Windows管理规范（WMI）是Windows操作系统对WBEM（基于Web的企业管理）和CIM（公共信息模型）标准的实现。它提供了一个标准化的框架，用于通过通用接口与消费者和提供者通信。

WMI架构的核心组件包括：
*   **WMI提供者**：以WMI对象的形式生成设备遥测数据。
*   **WMI客户端**：消费这些事件和数据。
*   **CIM标准**：负责构建、查询和传输WMI对象。
*   **WMI存储库**：存储类定义、命名空间定义及其关联属性，以及持久性WMI对象。
*   **MOF（托管对象格式）**：一种面向对象的语言，用于定义WMI构件。
*   **WQL（WMI查询语言）**：一种类似SQL的语言，用于过滤事件。
*   **WMI服务**：作为`WinMgmt`服务在`svchost`中运行。

## WMI提供者与事件 🔌

![](img/1a017bc136190fbb202c3486a49d0dc4_5.png)

WMI提供者以COM DLL或内核驱动形式实现。一个提供者是`__Win32Provider`标准类的一个实例，由其类ID标识。在Windows 11中，有超过4000个内置WMI提供者。

![](img/1a017bc136190fbb202c3486a49d0dc4_7.png)

WMI事件允许攻击者和防御者对几乎所有的操作系统事件进行操作。WMI的一个重要特性是能够注册**永久事件订阅**，这在系统重启后依然有效，常被攻击者用于持久化。

事件分为两类：
*   **内部事件**：反映WMI命名空间内对象的创建、修改或删除。
*   **外部事件**：由提供者显式触发，不直接与WMI对象生命周期关联。

## 过滤器、消费者与持久化订阅 ⛓️

![](img/1a017bc136190fbb202c3486a49d0dc4_9.png)

上一节我们介绍了WMI事件，本节中我们来看看如何利用过滤器和消费者来创建持久化机制。

**事件过滤器**是`__EventFilter`类的一个实例，用于指定哪些事件应被传递给绑定的消费者。其关键属性包括事件命名空间、查询语言（WQL）以及查询表达式本身。

![](img/1a017bc136190fbb202c3486a49d0dc4_11.png)

以下是WQL查询的一般语法示例：
```sql
SELECT * FROM __InstanceOperationEvent WITHIN PollingInterval WHERE TargetInstance ISA 'ClassName'
```

**WMI消费者**定义了当绑定的过滤器触发时要执行的操作。标准提供了五种事件消费者，用于执行记录日志、运行脚本或命令行、发送通知等操作。

![](img/1a017bc136190fbb202c3486a49d0dc4_13.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_15.png)

创建持久化订阅通常分为三步：
1.  创建一个描述触发条件的事件过滤器。
2.  创建一个描述触发后要执行的操作的消费者。
3.  使用`__FilterToConsumerBinding`实例将过滤器与消费者绑定，从而将触发器与操作链接起来。

## CIM存储库与取证分析 🗄️

![](img/1a017bc136190fbb202c3486a49d0dc4_17.png)

CIM存储库是WMI的数据库，存储类定义和持久化对象。它由三种类型的文件组成：
*   **索引文件（.BTR）**：包含B+树结构的索引。
*   **对象数据文件**：包含实际的类定义和持久化对象。
*   **映射文件**：将逻辑页号转换为物理页号。

解析存储库的基本流程如下：
1.  使用命名空间、类和实例的标识符构造搜索路径。
2.  在索引文件（.BTR）中进行搜索，找到对应的索引记录，该记录包含目标数据在对象数据文件中的逻辑页号。
3.  使用映射文件将逻辑页号转换为物理页号。
4.  在对象数据文件的对应物理页中，按记录查找目标数据。

![](img/1a017bc136190fbb202c3486a49d0dc4_19.png)

## 攻击者与防御者对WMI的利用 ⚔️

![](img/1a017bc136190fbb202c3486a49d0dc4_21.png)

对于防御者，WMI是收集设备遥测的强大工具。对于攻击者，WMI则是进行恶意活动的理想“就地取材”基础设施。

![](img/1a017bc136190fbb202c3486a49d0dc4_23.png)

威胁行为者利用WMI进行侦察、反病毒检测、持久化、代码执行和数据存储等。例如，攻击者可以创建一个在系统启动后触发的过滤器，该过滤器会启动一个命令行消费者，执行隐藏在WMI类属性（如`Description`）中的PowerShell脚本，从而部署第二阶段的有效载荷。

## WMI攻击模型与危险性 ⚠️

![](img/1a017bc136190fbb202c3486a49d0dc4_25.png)

WMI攻击模型涉及多个层面：
*   WMI服务通过高级LPC端口与客户端和提供者通信。
*   WMI文件（存储库、提供者DLL）。
*   注册表配置。
*   WMI服务进程内部的数据。

我们将攻击分为五类：
1.  针对文件和注册表配置的攻击。
2.  针对WMI服务进程内部数据的攻击。
3.  针对LPC连接的攻击。
4.  使用用户模式攻击对WMI进行沙箱化。
5.  使用DCOM攻击对WMI进行沙箱化。

![](img/1a017bc136190fbb202c3486a49d0dc4_27.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_29.png)

这些攻击之所以危险，是因为：
*   WMI在设计之初并非用于安全解决方案，而是用于设备遥测。
*   WMI服务不被视为关键进程，缺乏PPL等保护。
*   安全解决方案通常无法检测WMI是否被禁用或篡改。
*   许多攻击利用了架构性缺陷，无法通过简单补丁修复。

![](img/1a017bc136190fbb202c3486a49d0dc4_31.png)

## 针对文件和注册表的攻击 🗂️

![](img/1a017bc136190fbb202c3486a49d0dc4_33.png)

攻击者可以修改或删除代表数据库的磁盘文件、提供者DLL，或限制对它们的访问。在注册表中，可以修改服务配置和其他WMI内部设置。

例如，存在一个名为`EnableEvents`的注册表值。当新的WMI客户端连接时，系统会读取此值。如果其值不为`1`，则事件初始化会失败。攻击者只需将该值修改为非`1`的数字并重启WMI服务，即可禁用整个WMI事件基础设施。

## 针对进程内部数据的攻击（标志位篡改） 🎛️

![](img/1a017bc136190fbb202c3486a49d0dc4_35.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_37.png)

这是一种常见的攻击模式。许多WMI DLL在内存中维护全局标志位来控制其功能（如是否允许新连接、是否传递事件）。

攻击流程如下：
1.  DLL加载时，标志位初始化为默认值（例如`false`或`0`）。
2.  在初始化函数中，标志位被设置为允许操作的值（例如`true`或`1`）。
3.  当有操作请求（如新连接、事件传递）时，代码会检查该标志位。
4.  如果标志位为`true`，则正常处理请求。
5.  攻击者将进程内存中的该标志位修改为`false`。
6.  后续的操作请求在检查标志位时失败，错误路径被触发，请求被丢弃。

例如，在`WMICore.dll`中有一个`g_fDoNotAllowNewConnections`标志。攻击者将其从`false`改为`true`后，任何新的WMI连接尝试都会收到“服务器正在停止”的错误。

![](img/1a017bc136190fbb202c3486a49d0dc4_39.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_41.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_43.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_44.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_46.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_48.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_49.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_51.png)

## 检测工具：WMI Check 🔍

![](img/1a017bc136190fbb202c3486a49d0dc4_52.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_54.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_56.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_58.png)

为了应对上述攻击，研究人员开发了**WMI Check**工具。它由一个控制台应用程序和一个内核驱动程序组成，可以扫描进程并解析WMI内部对象，支持对特定进程或整个系统进行扫描。通过对比攻击前后的内存快照，WMI Check能够检测到内部标志位等数据的篡改。

![](img/1a017bc136190fbb202c3486a49d0dc4_60.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_61.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_63.png)

## 针对WMI事件传递的攻击 🚫

![](img/1a017bc136190fbb202c3486a49d0dc4_64.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_66.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_67.png)

类似地，在`CEvents`类的会话字段中存在一个控制事件传递的内部标志（偏移`0xC`）。当`WBEMCore.dll`加载时，事件传递被设置为`false`；在服务启动时设为`true`，停止时设为`false`。

![](img/1a017bc136190fbb202c3486a49d0dc4_69.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_71.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_72.png)

攻击者将该内存标志位修改为`false`，导致`DeliverIntrinsicEvent`函数失败，从而禁用所有内部事件的传递。依赖这些事件的安全监控将失效。

![](img/1a017bc136190fbb202c3486a49d0dc4_73.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_75.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_76.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_78.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_79.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_81.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_82.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_84.png)

---

![](img/1a017bc136190fbb202c3486a49d0dc4_86.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_88.png)

![](img/1a017bc136190fbb202c3486a49d0dc4_90.png)

本节课中我们一起学习了WMI的核心架构、其在攻防两端的应用，并深入探讨了多种针对WMI的用户空间攻击技术，特别是通过篡改内存中关键标志位来禁用WMI功能的方法。这些攻击利用了WMI架构的固有弱点，能够有效规避依赖WMI遥测的安全检测。最后，我们介绍了像WMI Check这样的工具，它们能够帮助检测此类内存篡改攻击，是防御体系中的重要一环。理解这些攻击手法对于构建更具弹性的安全监控和事件响应能力至关重要。